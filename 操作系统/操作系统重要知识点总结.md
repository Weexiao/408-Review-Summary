# 一些重要数据结构

1. 中断向量表

   不同的中断信号有不同的中断处理程序处理，==当CPU检测到中断信号后，会根据中断信号类型去查询中断向量表，以此来找到中断处理程序(内核程序)在内存中的位置==

2. 进程控制块

   用来描述进程的基本情况和运行状态，进而控制和管理进程

   ![进程控制块 PCB](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%20PCB.png)

3. 线程控制块TCB

   存放线程控制信息，每个线程有唯一标识的线程ID

# 一些重要寄存器

主要能分为两类，用户程序可见寄存器(存数据)和控制与状态寄存器

1. 指令寄存器 IR

   存放指令

2. 程序计数器 PC

   下一条要执行的指令在主存中的位置

3. 程序状态字寄存器

   PSW(程序状态字)：描述程序动态执行的行为，内容有：程序计数器、指令寄存器、条件码、中断位、中断允许位、中断屏蔽位、处理器模式位、主存保护位等

   即保存程序状态字的寄存器，大部分计算机都有

4. 通用寄存器

   存储其他重要信息

   

# 一些重要结论

## C语言中数据存放大致分区

1. 正交段：代码+赋值数据(二进制代码+常量)
2. 数据堆：动态分配存储区
3. 数据栈：临时使用变量

# ==进程与线程==

必考重点，**进程概念、进程调度、信号量机制实现同步和互斥、进程死锁**乃是重中之重，其中==信号量机制实现同步和互斥、进程调度算法和死锁都可能出综合题==

## 进程和线程

### 进程的概念和特征

1. 概念

   程序：静态的，存放在磁盘上的可执行文件，即一系列指令集合

   进程：动态的，程序的一次执行过程，故同一个程序可以对应多个线程，“运行着的程序”

2. 组成

   进程控制块PCB：用来描述进程的基本情况和运行状态，进而控制和管理进程

   ![进程控制块 PCB](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%20PCB.png)

   PCB+程序+数据=进程实体(进程映像)

   Note: 进程与进程实体之间的区别

   - 进程是动态的，是进程实体的运行过程
   - 进程实体是静态的(可能会变)，反应某一时刻进程的状态

   > 在没有引入线程时，进程是系统进行资源分配和调度的基本单位
   >
   > 引入线程后，进程是系统进行资源分配的基本单位，线程是系统进行调度的最小单位

3. 特征

   - 动态性

     进程是程序的一次执行过程，是动态地产生、变化和消亡的

     **==进程的最基本特征==**

   - 并发性

     内存中可同时有多个进程，各进程之间并发执行

   - 独立性

     进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位

   - 异步性

     进程执行具有异步性

   - 结构性

     每个进程都有PCB

### 进程的状态与转换 & 进程的组织

1. 进程的状态与转换

   - 创建态

     时间：进程正在创建时

     **操作系统为进程分配资源，初始化PCB**

   - 就绪态

     时间：进程创建完成后

     进程已具备执行条件，但无空闲CPU，故不能执行；**系统可能有很多进程都在就绪态**

   - 运行态

     时间：进程在CPU上运行时

     CPU会执行进程对应的程序；对单核CPU来说，一个时刻只可能有一个进程在运行态，而多核CPU，一个时刻可能有多个进程在运行态

   - 阻塞态(等待态)

     进程可能在请求某个时间的发生(如等待某种资源的分配或等待其他进程的响应)，该事件发生前，此进程无法运行，则进入阻塞态，发生后则进入就绪态

   - 结束态(终止态)

     进程运行结束，执行exit系统调用，请求操作系统终止该进程，进入终止态；

     回收内存空间等资源，最后回收PCB

   ![image-20220725223200080](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220725223200080.png)

2. 进程的转化

	链接方式(大多数)

	![image-20220726214432065](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220726214432065.png)

	![image-20220726214440728](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220726214440728.png)

	索引方式

	![image-20220726214449773](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220726214449773.png)

### 进程控制

主要功能

​	主要负责对计算机中的进程进行管理，主要有创建新进程、撤销进程、进程的阻塞和唤醒、进程状态切换等功能

实现方式

​	通过原语实现

> 为什么进程控制需要原子性？
>
> ​	防止进程控制过程中遇到中断被迫停止
>
> ​	若有一个进程需要从阻塞态切换到就绪态，假如没有原子性，则可能会出现PCB中状态已经是就绪态，而进程还在阻塞对列中的现象
>
> 为什么原语需要原子性？
>
> ​	防止原语在运行过程中被打断
>
> 原语实现方法
>
> ​	通过“关中断指令”和“开中断指令”实现，这两个指令运行在内核态，若运行在用户态，则可能出现恶意用户关掉中断一直运行

1. 进程创建

	![进程的创建](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA.png)

2. 进程终止

	![进程的终止](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2.png)

3. 进程阻塞和唤醒

	![进程的阻塞和唤醒](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92.png)

4. 进程切换

	![进程的切换](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2.png)

### ==进程通信==

​	进程间通信指两个进程之间产生数据通信，由操作系统内核支持，原因是各进程拥有的内存地址空间相互独立且进程不能访问其他进程

#### 共享内存

##### 基于存储区的共享

​	在进程之间存在一块共享空间，通过对共享空间的读/写操作实现进程的通信

​	特点：

- 操作系统只负责划分共享空间，怎么存，存什么都由进程决定
- ==一种高级通信方式==，通信方式很快

##### 基于数据结构的共享

​	比如在共享空间中放一个大小为10的数组，以此来实现进程通信

​	通信方式很慢，限制很多，==低级通信方式==

> 在Linux中使用共享内存
>
> ```c
> int shm_open(); // shm_open系统调用，申请共享内存区
> void * mmnp(); // 通过mmnp系统调用，将共享内存区映射到进程自己的地址空间
> ```
>
> 原理：通过增加页表项/段表项，即可将同一片共享内存区映射到各个进程的地址空间中

#### 消息传递

​	以格式化的信息为个体，通过操作系统提供的“发送信息/接受信息“两个原语进行数据交换

> 格式化的信息包括信息头和信息体
>
> 信息头主要有发送进程ID、接受进程ID、消息长度等格式化的信息

##### 直接通信方式

​	需要指定接受进程的ID

​	发送进程直接将信息发送给接受进程，并将它挂载在接受进程的信息缓冲队列上，接受进程从信息缓存队列上去除信息

> 发送信息原语send(Q, msg) —> 接受原语receive(P, &msg) —> 取消息

##### 间接通信方式(信箱通信方式)

​	发送进程将信息发送到某中间实体，接受进程从中间实体中取得消息，这种中间实体(通过系统调用申请)一般称为信箱

> 广泛运用于计算机网络中，相应通信系统为电子邮箱系统

#### 管道通信

​	**==半双工，大小受内存影响，可看作是读者写者问题==**

​	管道：用于连接写进程与读进程以实现它们之间通信的一个共享文件(pipe文件)

​	向管道提供输入的发送进程(写进程)，==以字符流形式将数据写入管道==，接受管道输出的接受进程则从管道中接受数据

> 为了完成通信，需要有互斥、同步和确定双方存在的能力，否则信息传输一定出错
>
> ![image-20220726224831223](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220726224831223.png)
>
> 与共享内存区别：
>
> ​	**共享内存可以在其中任意存取，无论头尾；而管道只能按顺序存取**
>
> 写进程往管道写数据，即使管道没写满，只要管道没空，读进程就可读
>
> 读进程从管道读数据，即使管道每读空，只要管道没满，写进程就可写

### ==线程和多线程模型==

#### 线程的基本概念

概念：线程是一个基本的CPU执行单元，也是程序执行流的最小单位

引入线程后，不仅进程之间可以并发，进程内的各线程也可并发，从而进一步提升了系统的并发度，也使一个进程可以并发处理各类任务

> 线程从属于进程，无独立线程
>
> 进程中各线程执行的代码可同可不同
>
> 线程，可看做轻量级线程，即运行着的函数
>
> 二者区别
>
> - ![进程与线程区别](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB.png)

#### 线程的特性

- 线程唯一标识符及线程状态信息(有线程控制块)
- 线程是一条执行路径，**有独立的程序计数器**
- 线程有执行栈和存放局部变量的私有存储空间
- 可访问所属进程的主存和资源，并与该进程中的其他线程共享该资源

> 引入线程后进程结构
>
> ![8451350910B0AFBE0C0C4F748CEC620D](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/8451350910B0AFBE0C0C4F748CEC620D.png)
>
> 此时进程可分为两部分：资源集合和线程集合。进程封装管理信息，包括对指令代码、全局数据、打开的文件和信号量等共享部分的管理，线程封装执行信息，包括对状态信息、寄存器、执行栈(用户栈和核心栈)和局部变量、过程调用参数、返回值等私有部分的管理

#### 进程的属性

> 多线程操作系统把线程作为独立运行(或调度)的基本单位，此时的进程已不是一个基本的可执行实体，但其仍具有与执行相关的状态
>
> ==所谓进程处于执行状态，实际上是指该进程中的某线程正在执行==

- 线程是一个轻型实体，几乎不拥有系统资源，但每个线程都有一个唯一标识符(线程ID)和线程控制块(TCB)，记录线程执行的寄存器和栈等现场状态

- 不同的线程可以执行相同的程序

- 同一进程中的线程共享该进程拥有的资源

- 线程是处理机的独立调度单位，多个线程可以并发执行

	单CPU中各线程交替使用；多CPU中，各线程可以同时占用不同CPU

- 线程也有**就绪、执行、终止**三种基本状态

- 由于共享内存地址空间，同一进程内的线程沟通不需要系统干预

- 同一进程内线程切换不需要进程切换(系统开销小)

	不同进程的线程切换需要进程切换(系统开销大)

#### 线程的实现方式

##### 用户级线程(ULT)—代码逻辑载体

早期操作系统只支持进程，不支持线程，通过线程库实现(逻辑上实现，编译语言提供，实现创建运行销毁)

由应用程序管理线程，由应用程序切换线程，不需要CPU切换状态，**操作系统意识不到用户级线程**

> pros：线程切换在用户态即可，不需要切换到内核态，线程管理的系统开销小，效率高
>
> cons：
>
> 1. 当一个用户线程阻塞时，整个进程都被阻塞
> 2. 不能发挥多处理器的优势，因为处理器分配给一个进程的资源只有一个CPU，所以进程中只有一个线程能运行

##### 内核级线程(KLT)—运行机会载体

由操作系统支持的线程(Windows、Linux)

KLT的管理工作由操作系统内核完成；线程调度、切换都由内核态完成

操作系统会为每个线程建立线程控制块TCB，通过TCB对其进行管理，**操作系统可以看到KLT**

> pros：当一个线程被阻塞时不影响其他线程，并发能力强，多线程可以在多核处理器上并发执行
>
> cons：一个ULT会对应多个KLT，线程切换时成本高，开销大
>
> ![image-20220727220129623](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220727220129623.png)

##### 多线程模型

在支持KLT的系统中引入ULT，根据二者对应关系可分为三类

1. 一对一模型

	一个ULT映射一个KLT，每个用户进程都有与ULT同数量的KLT

	> pros：同KLT
	>
	> cons：同KLT

2. 多对一模型

	一个用户进程映射一个KLT(多个ULT映射一个KLY)

	> pros：同ULT
	>
	> cons：同ULT

	**==操作系统只能看到KLT，只有KLT才是处理器分配单位==**

3. 多对多模型

	n个ULT映射m个KLT($n \ge m$)，每个用户进程对应m个KLT

	> 既克服了一对一开销大，也克服了多对一并发度不高的缺点
	>
	> ![image-20220727220720824](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220727220720824.png)



## 处理器调度

### 调度的概念

由于资源优先，无法同时处理，就需要某种规则来决定处理顺序，这便是调度研究的问题

#### 调度层次

1. 作业调度(高级调度)

	按照一定的顺序从外存的作业后备队列中挑选一个作业放入内存，并创建进程

	> - 每个作业只调入一次，调出一次。调入创建PCB，调出销毁PCB
	> - 由于内存有限，无法将用户提交的作业都放入内存
	> - 作业是以一个具体的任务，用户系统提交一个作业=用户让操作系统运行一个程序(处理一个具体任务)

2. 内存调度(中级调度)

	内存不够时，将某些暂时无法运行的进程换出内存，此时该内存处于挂起状态，放在挂起队列；==当进程可以运行且内存足够时再调入内存==，调入的规程可以看作是内存调度

3. 进程调度(低级调度)

	按某种规律从就绪队列中选取一个进程，将处理器分配给它。

	最基本的一种调度，一般操作系统中都有

	![image-20220728212736285](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220728212736285.png)

	> 发生频率：
	>
	> $低级调度 \gt 中级调度 \gt 高级调度$

> 补充：进程的挂起状态和七状态模型
>
> 1. 暂时调到外存等待的进程状态为挂起状态，可分为就绪挂起和阻塞挂起
>
> 2. 七状态模型
>
> 	![image-20220728213046065](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220728213046065.png)

Note:三层调度联系、对比

|                    |                     要做什么                     |    调度发生在     | 发生频率 |                    对进程状态的影响                    |
| :----------------: | :----------------------------------------------: | :---------------: | :------: | :----------------------------------------------------: |
| 高级调度(作业调度) | 按某种规律从外存的作业后备队列中选取作业放入内存 |  $外存 \to 内存$  |   最少   |               $无 \to 创建态 \to 就绪态$               |
| 中级调度(内存调度) |   当进程可以继续运行且内存足够时将进程换入内存   |  $外存 \to 内存$  |   中等   | $就绪挂起态 \to 就绪态 \\ or \\ 阻塞挂起态 \to 阻塞态$ |
| 低级调度(进程调度) |  按某种规则从就绪队列中选一个进程为其分配处理器  | $内存 \to 处理器$ |   最多   |                  $就绪态 \to 运行态$                   |

### 调度的时机、方式、切换与过程

#### 时机

![调度的时机](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA.png)

> **==临界区相关概念==**
>
> **临界资源：一个时间段内只允许一个进程使用的资源**，多进程需要交替访问
>
> **临界区：访问临界资源的那段代码**
>
> 内核程序临界区：一般用来访问某种内核数据结构，如就绪队列
>
> ==为什么在内核程序临界区不能切换，而在临界区便可切换？==
>
> - ![image-20220728220010643](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220728220010643.png)

#### 方式

1. 非剥夺调度方式(非抢占式)：**只允许进程主动放弃处理器**

	实现简单，系统开销小但无法及时处理任务，适用于早期批处理系统

2. 剥夺调度方式(抢占式)：允许优先级更高的进程抢占正在运行的处理机的时间片

	可以优先处理紧急进程，也可按时间片处理，适用于分时系统(无优先级)、实时系统(有优先级)

#### 切换与过程

进程切换：切换处理机中的进程，即将进程1切换为进程2

狭义进程切换：指从就绪队列中选中一个要运行的进程，可以选刚下来的进程或另一个进程

广义进程切换：指选一个进程+进程切换

> 狭义进程切换与进程切换的区别
>
> 狭义进程切换指从就绪队列中选中一个要运行的进程，可以选刚下来的进程或另一个进程，若选择另一个进程就需要进程切换
>
> 进程切换过程主要完成了
>
> 1. 保存原来进程的各种数据
> 2. 对新进程数据的保存(PC、PSW、各种数据寄存器，一般都在PCB中)

### 调度算法评价指标

1. CPU利用率
	$$
	CPU利用率=\frac{CPU运行时间}{总时间}
	$$
	
2. 系统吞吐量

	单位时间内完成的作业量
	$$
	系统吞吐量=\frac{总作业量}{总时间}
	$$

3. 周转时间

	指从作业提交到作业完成所经历的时间，是作业等待、在就绪队列中排队、在处理机上运行及输入/输出操作所花费时间的总和
	$$
	周转时间=完成时间-提交时间 \\
	平均周转时间=\frac{周转时间总和}{作业量} \\
	带权周转时间=\frac{周转时间}{作业运行时间} \\
	平均带权周转时间=\frac{带权周转时间之和}{作业量}
	$$

4. 等待时间

	进程/作业处于等待状态时间之和

	> 进程：进程建立后等待被服务时间总和，故I/O时间不计入
	>
	> 作业：不仅要考虑建立后等待被服务时间总和，还要加上作业在后备队列中等待时间
	>
	> 由于CPU占用时间和I/O设备时间实际上是固定不变的，故==调度算法本质上影响的是进程/作业的等待时间==

5. 响应时间

	从用户提交到首次响应所花时间

### ==调度算法==

见一些重要算法

## ==进程同步==

基本必考一道大题，重点在PV操作

### 基本概念

1.  同步

	在一些异步问题中，进程必须按照一定的顺序运行，进程同步就可解决上述问题

	**同步(直接制约关系)**：为了完成某种任务建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系，**进程之间的直接制约关系源于它们需要相互合作**

2. 互斥

	进程的并发需要共享的支持，进程不可避免的需要共享一些临界资源

	资源共享方式：1.同时：一段时间多个；2.互斥：一段时间一个

	**互斥(间接制约关系)**：当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待，当前进程访问结束并释放资源后另一个进程才能访问

	> 可将临界资源的访问分为四个阶段：
	>
	> 1. 开始区
	> 2. 临界区：访问临界资源的代码
	> 3. 结束区
	> 4. 剩余区
	>
	> 开始区和结束区用来实现互斥

	==互斥基本原则==

	- 空闲让进：临界区空闲时，当有进程申请进入临界区则让进
	- 忙则等待：当前临界区正忙时，要求申请进入临界区的进程等待
	- 有限等待：申请进入临界区的进程应在有限时间内满足要求(防止饥饿)
	- 让权等待：当进程不能进入临界区时，进程立即放弃处理机

### **==实现临界区互斥的一些算法==**

#### 软件实现方法

##### 单标志法

算法思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，即==每个进程的访问权限由另一个进程赋予==

![image-20220731211453949](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731211453949.png)

cons：只能$P_0 \to P_1 \to P_0 \to P_1 \to ……$这样轮流访问(不能空闲让进)；这种轮流访问带来的问题是，如果此时进入临界区的是$P_0$，其一直不访问临界区，则此时临界资源空闲$P_1$也不好使

##### 双标志法先检查

算法思想：设置一个布尔数组flag[]，数组+各个元素用来标记各进程想进入临界区。比如flag[0]=true表示0号进程想进入临界区。==每个进程在进入临界区之前先检查有没有其他进程想进入临界区，如果没有则把flag[i]=true，之后开始访问临界区==

![image-20220731212028764](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731212028764.png)

> 违反忙则等待原因：可能会出现两个进程都进入临界区的情况

##### 双标志法后检查

算法思想：上一个的改进，先上锁再检查

![image-20220731212222277](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731212222277.png)

> 违反空闲让进的原因：可能$P_0$上锁后一直不用，导致临界资源空闲但$P_1$也用不到
>
> 违反有限等待的原因：可能$P_0$上锁后一直不用，导致$P_1$一直等待

##### Peterson’s Algorithm

算法思想：结合单标志、双标志的思想，即在表达自己想用的同时谦让

![image-20220731212536708](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731212536708.png)

用软件方法实现了进程互斥问题，遵循了空闲让进、忙则等待、有限等待原则，但没有实现让权等待

> 假象场景
>
> 1. $P_0$想用，$P_1$不用
>
> 	则此时flag[0]=true flag[1]=false turn=1，$P_0$能进去(空闲让进)
>
> 2. $P_0$在用，$P_1$想用
>
> 	则此时flag[0]=true flag[1]=true turn=0，$P_1$只能等待(忙则等待)
>
> 3. $P_0$想用，$P_1$想用，且指向顺序为126738……
>
> 	则此时flag[0]=true flag[1]=true turn=0，$P_0$能进去而$P_1$需要等待(有限等待)

#### 硬件实现方法

##### 中断屏蔽方法

使用“开/关中断指令”实现(在开始访问到结束访问临界区这段时间不允许被打断)

![image-20220731213521892](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731213521892.png)

- pros：简单、高效
- cons：不适用于多处理机系统(因为开关中断指令只对当前CPU有用，其他CPU还是可以访问)；只适用于操作系统内核进程

##### 硬件指令方法

###### TestAndSet指令(TS指令、TSL指令)

用硬件实现，执行过程中不允许中断

![image-20220731214025737](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731214025737.png)

###### Swap指令(Exchange指令、XCHG指令)

用硬件实现，执行过程中不允许中断

![image-20220731214233004](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731214233004.png)

### ==**信号量**==

用户使用原语来读信号量进行操作，以此实现进程互斥、进程同步

信号量：一种变量(整数或记录型变量)，用信号量来表示系统中某种资源的数量，如有一台打印机，则对应信号量可设置为1

操作原语：wait(s) - 和signal(s) + ，又叫P、V操作

#### 整型信号量

![image-20220731214850017](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731214850017.png)

#### 记录型信号量

可以实现进程同步互斥，且整型不能有限等待，记录型可解决该问题

Note：默认使用记录型信号量

![image-20220731215040978](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731215040978.png)

> $S.value \le 0$表示当前还存在等待该资源的进程，故需要唤醒一个进程
>
> $S.value \lt 0$表示当前不存在资源了，需要等待

#### 使用信号量实现进程同步、互斥

> P(S)：申请一个资源，若资源不够则阻塞等待
>
> V(S)：释放一个资源，若有进程在等待就唤醒

##### 互斥

1. 分析并发进程的关键活动，划定临界区
2. 设置互斥信号量mutex初值为1
3. 在进入区P(mutex)—申请
4. 在退出区V(mutex)—释放

> 对不同的临界资源设置不同的信号量，PV操作需要同步出现
>
> ![image-20220731215928588](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731215928588.png)

##### 同步

1. 分析在什么地方需要同步，即必须保证一前一后执行的两个操作
2. 设置同步信号量S，初值为0
3. 在前操作后执行V(S)
4. 在后操作前执行P(S)，即先V后P

> ![image-20220731220139713](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731220139713.png)

##### 前驱关系

每个前驱关系实际上都是一个进程同步问题

1. 为每个前驱关系设置一个同步信号量
2. 前V后P

> ![image-20220731220302308](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220731220302308.png)

### 经典同步问题

见经典同步问题.md

> 实现互斥的P一定要在实现同步的Pho

# ==一些重要算法==

## 调度算法

### FCFS 先来先服务算法

算法规则：先到达的作业/进程线上处理机

用于作业/进程调度不同点

- 用于作业时，考虑谁先进后备队列
- 用于进程时，考虑谁先进就绪队列

是否可抢占：不可

优缺点

- 公平，实现简单
- 对长作业有利，对短作业不利

是否导致饥饿：不会

### SJF 短作业优先

算法规则：最短的作业/进程优先服务(服务时间最短)

用于作业/进程调度不同点：

- 暂无，用于进程叫SPF

是否可抢占：可以，最短剩余时间优先算法(SRTN)

优缺点

- “最短的”平均等待时间，平均周转时间
- 对短作业有利，对长作业不利

是否导致饥饿：会

> 默认非抢占

### HRRN 高响应比优先算法

算法思想：综合考虑作业/进程等待时间和要求服务时间

算法规则：在每次调度时计算作业/进程的响应比，为最大的服务
$$
响应比=\frac{等待时间+要求服务时间}{要求服务时间} \ge 1
$$
用于作业/进程调度不同点：暂无

是否可抢占：非抢占，只有前者运行结束后才能继续计算响应比

优缺点

- 综合考虑了等待时间和运行时间，避免长作业饥饿的问题

是否导致饥饿：不会

> Note：前三者多用于批处理系统，无交互性

### RR 时间片轮转

算法思想：公平轮转，让每个进程都有机会运行

算法规则：按各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，若进程时间片结束则回到就绪队列末尾重新排队

用于作业/进程调度不同点：

- 只能用在进程调度，因为要上处理机

是否可抢占：可，由时钟中断控制

优缺点

- 公平，响应快，适用于分时操作系统
- 没有优先级，开销较大

是否导致饥饿：不会

> **若时间片太长，则会退化为先来先服务算法；若时间片太短，则会一直切换进程，系统开销大**

### 优先级调度算法

算法思想：根据任务优先级调度

算法规则：每个作业/进程都有自己的优先级，算法按照优先级调度，优先级最高的优先处理

用于作业/进程调度不同点：暂无，甚至可用于I/O调度

是否可抢占：可以抢占可以不抢占

优缺点

- 有优先级，可处理紧急任务
- 可能饥饿

是否导致饥饿：会

> ![image-20220729213507958](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220729213507958.png)

### 多级反馈队列调度算法

算法思想：是上述算法的折中平衡

算法规则

1. 设置多级就绪队列，各组队列**优先级从高到低，时间片从小到大**
2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用户时间片到但进程还未运行结束，则进入下一级队尾，若此时已经是最后一级，则重新放在该队列队尾
3. **只有等第k级队列为空时才为第k+1级分配时间片**

用于作业/进程调度不同点：**用于进程**

是否可抢占：抢占式

- 若在k级队列进程运行过程中，其更上级(1~k-1)中进入了一个新进程，由于新进程处于更高优先级队列中，因此新进程会抢占处理机，原来的进程放在k级队列队尾

优缺点

- 综合上述所有算法
- 可能饥饿

是否导致饥饿：会

> 后三个用于交互性系统，Linux用6