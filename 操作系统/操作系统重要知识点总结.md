# 一些重要数据结构

1. 中断向量表

   不同的中断信号有不同的中断处理程序处理，==当CPU检测到中断信号后，会根据中断信号类型去查询中断向量表，以此来找到中断处理程序(内核程序)在内存中的位置==

2. 进程控制块

   用来描述进程的基本情况和运行状态，进而控制和管理进程

   ![进程控制块 PCB](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%20PCB.png)

3. 线程控制块TCB

   存放线程控制信息，每个线程有唯一标识的线程ID

# 一些重要寄存器

主要能分为两类，用户程序可见寄存器(存数据)和控制与状态寄存器

1. 指令寄存器 IR

   存放指令

2. 程序计数器 PC

   下一条要执行的指令在主存中的位置

3. 程序状态字寄存器

   PSW(程序状态字)：描述程序动态执行的行为，内容有：程序计数器、指令寄存器、条件码、中断位、中断允许位、中断屏蔽位、处理器模式位、主存保护位等

   即保存程序状态字的寄存器，大部分计算机都有

4. 通用寄存器

   存储其他重要信息

   

# 一些重要结论

## C语言中数据存放大致分区

1. 正交段：代码+赋值数据(二进制代码+常量)
2. 数据堆：动态分配存储区
3. 数据栈：临时使用变量

# ==进程与线程==

必考重点，**进程概念、进程调度、信号量机制实现同步和互斥、进程死锁**乃是重中之重，其中==信号量机制实现同步和互斥、进程调度算法和死锁都可能出综合题==

## 进程和线程

### 进程的概念和特征

1. 概念

   程序：静态的，存放在磁盘上的可执行文件，即一系列指令集合

   进程：动态的，程序的一次执行过程，故同一个程序可以对应多个线程，“运行着的程序”

2. 组成

   进程控制块PCB：用来描述进程的基本情况和运行状态，进而控制和管理进程

   ![进程控制块 PCB](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97%20PCB.png)

   PCB+程序+数据=进程实体(进程映像)

   Note: 进程与进程实体之间的区别

   - 进程是动态的，是进程实体的运行过程
   - 进程实体是静态的(可能会变)，反应某一时刻进程的状态

   > 在没有引入线程时，进程是系统进行资源分配和调度的基本单位
   >
   > 引入线程后，进程是系统进行资源分配的基本单位，线程是系统进行调度的最小单位

3. 特征

   - 动态性

     进程是程序的一次执行过程，是动态地产生、变化和消亡的

     **==进程的最基本特征==**

   - 并发性

     内存中可同时有多个进程，各进程之间并发执行

   - 独立性

     进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位

   - 异步性

     进程执行具有异步性

   - 结构性

     每个进程都有PCB

### 进程的状态与转换 & 进程的组织

1. 进程的状态与转换

   - 创建态

     时间：进程正在创建时

     **操作系统为进程分配资源，初始化PCB**

   - 就绪态

     时间：进程创建完成后

     进程已具备执行条件，但无空闲CPU，故不能执行；**系统可能有很多进程都在就绪态**

   - 运行态

     时间：进程在CPU上运行时

     CPU会执行进程对应的程序；对单核CPU来说，一个时刻只可能有一个进程在运行态，而多核CPU，一个时刻可能有多个进程在运行态

   - 阻塞态(等待态)

     进程可能在请求某个时间的发生(如等待某种资源的分配或等待其他进程的响应)，该事件发生前，此进程无法运行，则进入阻塞态，发生后则进入就绪态

   - 结束态(终止态)

     进程运行结束，执行exit系统调用，请求操作系统终止该进程，进入终止态；

     回收内存空间等资源，最后回收PCB

   ![image-20220725223200080](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220725223200080.png)

2. 进程的转化

	链接方式(大多数)

	![image-20220726214432065](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220726214432065.png)

	![image-20220726214440728](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220726214440728.png)

	索引方式

	![image-20220726214449773](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220726214449773.png)

### 进程控制

主要功能

​	主要负责对计算机中的进程进行管理，主要有创建新进程、撤销进程、进程的阻塞和唤醒、进程状态切换等功能

实现方式

​	通过原语实现

> 为什么进程控制需要原子性？
>
> ​	防止进程控制过程中遇到中断被迫停止
>
> ​	若有一个进程需要从阻塞态切换到就绪态，假如没有原子性，则可能会出现PCB中状态已经是就绪态，而进程还在阻塞对列中的现象
>
> 为什么原语需要原子性？
>
> ​	防止原语在运行过程中被打断
>
> 原语实现方法
>
> ​	通过“关中断指令”和“开中断指令”实现，这两个指令运行在内核态，若运行在用户态，则可能出现恶意用户关掉中断一直运行

1. 进程创建

	![进程的创建](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA.png)

2. 进程终止

	![进程的终止](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2.png)

3. 进程阻塞和唤醒

	![进程的阻塞和唤醒](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92.png)

4. 进程切换

	![进程的切换](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2.png)

### ==进程通信==

​	进程间通信指两个进程之间产生数据通信，由操作系统内核支持，原因是各进程拥有的内存地址空间相互独立且进程不能访问其他进程

#### 共享内存

##### 基于存储区的共享

​	在进程之间存在一块共享空间，通过对共享空间的读/写操作实现进程的通信

​	特点：

- 操作系统只负责划分共享空间，怎么存，存什么都由进程决定
- ==一种高级通信方式==，通信方式很快

##### 基于数据结构的共享

​	比如在共享空间中放一个大小为10的数组，以此来实现进程通信

​	通信方式很慢，限制很多，==低级通信方式==

> 在Linux中使用共享内存
>
> ```c
> int shm_open(); // shm_open系统调用，申请共享内存区
> void * mmnp(); // 通过mmnp系统调用，将共享内存区映射到进程自己的地址空间
> ```
>
> 原理：通过增加页表项/段表项，即可将同一片共享内存区映射到各个进程的地址空间中

#### 消息传递

​	以格式化的信息为个体，通过操作系统提供的“发送信息/接受信息“两个原语进行数据交换

> 格式化的信息包括信息头和信息体
>
> 信息头主要有发送进程ID、接受进程ID、消息长度等格式化的信息

##### 直接通信方式

​	需要指定接受进程的ID

​	发送进程直接将信息发送给接受进程，并将它挂载在接受进程的信息缓冲队列上，接受进程从信息缓存队列上去除信息

> 发送信息原语send(Q, msg) —> 接受原语receive(P, &msg) —> 取消息

##### 间接通信方式(信箱通信方式)

​	发送进程将信息发送到某中间实体，接受进程从中间实体中取得消息，这种中间实体(通过系统调用申请)一般称为信箱

> 广泛运用于计算机网络中，相应通信系统为电子邮箱系统

#### 管道通信

​	**==半双工，大小受内存影响，可看作是读者写者问题==**

​	管道：用于连接写进程与读进程以实现它们之间通信的一个共享文件(pipe文件)

​	向管道提供输入的发送进程(写进程)，==以字符流形式将数据写入管道==，接受管道输出的接受进程则从管道中接受数据

> 为了完成通信，需要有互斥、同步和确定双方存在的能力，否则信息传输一定出错
>
> ![image-20220726224831223](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220726224831223.png)
>
> 与共享内存区别：
>
> ​	**共享内存可以在其中任意存取，无论头尾；而管道只能按顺序存取**
>
> 写进程往管道写数据，即使管道没写满，只要管道没空，读进程就可读
>
> 读进程从管道读数据，即使管道每读空，只要管道没满，写进程就可写

### ==线程和多线程模型==

#### 线程的基本概念

概念：线程是一个基本的CPU执行单元，也是程序执行流的最小单位

引入线程后，不仅进程之间可以并发，进程内的各线程也可并发，从而进一步提升了系统的并发度，也使一个进程可以并发处理各类任务

> 线程从属于进程，无独立线程
>
> 进程中各线程执行的代码可同可不同
>
> 线程，可看做轻量级线程，即运行着的函数
>
> 二者区别
>
> - ![进程与线程区别](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8C%BA%E5%88%AB.png)

#### 线程的特性

- 线程唯一标识符及线程状态信息(有线程控制块)
- 线程是一条执行路径，**有独立的程序计数器**
- 线程有执行栈和存放局部变量的私有存储空间
- 可访问所属进程的主存和资源，并与该进程中的其他线程共享该资源

> 引入线程后进程结构
>
> ![8451350910B0AFBE0C0C4F748CEC620D](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/8451350910B0AFBE0C0C4F748CEC620D.png)
>
> 此时进程可分为两部分：资源集合和线程集合。进程封装管理信息，包括对指令代码、全局数据、打开的文件和信号量等共享部分的管理，线程封装执行信息，包括对状态信息、寄存器、执行栈(用户栈和核心栈)和局部变量、过程调用参数、返回值等私有部分的管理

#### 进程的属性

> 多线程操作系统把线程作为独立运行(或调度)的基本单位，此时的进程已不是一个基本的可执行实体，但其仍具有与执行相关的状态
>
> ==所谓进程处于执行状态，实际上是指该进程中的某线程正在执行==

- 线程是一个轻型实体，几乎不拥有系统资源，但每个线程都有一个唯一标识符(线程ID)和线程控制块(TCB)，记录线程执行的寄存器和栈等现场状态

- 不同的线程可以执行相同的程序

- 同一进程中的线程共享该进程拥有的资源

- 线程是处理机的独立调度单位，多个线程可以并发执行

	单CPU中各线程交替使用；多CPU中，各线程可以同时占用不同CPU

- 线程也有**就绪、执行、终止**三种基本状态

- 由于共享内存地址空间，同一进程内的线程沟通不需要系统干预

- 同一进程内线程切换不需要进程切换(系统开销小)

	不同进程的线程切换需要进程切换(系统开销大)

#### 线程的实现方式

##### 用户级线程(ULT)—代码逻辑载体

早期操作系统只支持进程，不支持线程，通过线程库实现(逻辑上实现，编译语言提供，实现创建运行销毁)

由应用程序管理线程，由应用程序切换线程，不需要CPU切换状态，**操作系统意识不到用户级线程**

> pros：线程切换在用户态即可，不需要切换到内核态，线程管理的系统开销小，效率高
>
> cons：
>
> 1. 当一个用户线程阻塞时，整个进程都被阻塞
> 2. 不能发挥多处理器的优势，因为处理器分配给一个进程的资源只有一个CPU，所以进程中只有一个线程能运行

##### 内核级线程(KLT)—运行机会载体

由操作系统支持的线程(Windows、Linux)

KLT的管理工作由操作系统内核完成；线程调度、切换都由内核态完成

操作系统会为每个线程建立线程控制块TCB，通过TCB对其进行管理，**操作系统可以看到KLT**

> pros：当一个线程被阻塞时不影响其他线程，并发能力强，多线程可以在多核处理器上并发执行
>
> cons：一个ULT会对应多个KLT，线程切换时成本高，开销大
>
> ![image-20220727220129623](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220727220129623.png)

##### 多线程模型

在支持KLT的系统中引入ULT，根据二者对应关系可分为三类

1. 一对一模型

	一个ULT映射一个KLT，每个用户进程都有与ULT同数量的KLT

	> pros：同KLT
	>
	> cons：同KLT

2. 多对一模型

	一个用户进程映射一个KLT(多个ULT映射一个KLY)

	> pros：同ULT
	>
	> cons：同ULT

	**==操作系统只能看到KLT，只有KLT才是处理器分配单位==**

3. 多对多模型

	n个ULT映射m个KLT($n \ge m$)，每个用户进程对应m个KLT

	> 既克服了一对一开销大，也克服了多对一并发度不高的缺点
	>
	> ![image-20220727220720824](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220727220720824.png)



## 处理器调度