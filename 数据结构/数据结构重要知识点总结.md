# 一些重点算法

## 串的模式匹配算法

1. 暴力求解法

  ```c
  // O(mn)
  int Index_Traverse(SString S, SString T){
      int i = 1, n = StrLength(S), m = StrLength(T);
      SString sub;
      while (i <= n-m+1)
      {
          SubString(&sub, S, i, m);
          if (StrCompare(sub, T) != 0)
          {
              i++;
          }
          else{
              return i;
          }
      }
      return 0;
  }
  ```

2. 跳跃求解法

  ```c
  // 最好O(m)，最差O(mn)
  // 跳跃着实现，因为子串比较实际上只需要主串i动即可
  int Index_Jump(SString S, SString T){
      int i=1, j=1;
      while (i<=S.length && j<=T.length)
      {
          if (S.ch[i] == T.ch[i])
          {
              ++i, ++j;
          }
          else
          {
              i = i-j+2;          //跳到下一个子串的第一个位置
              j=1;
          }
      }
      if (j > T.length)
      {
          return i-T.length;
      }
      else
      {
          return 0;
      }
  }
  ```

3. KMP算法

  <iframe height=498 width=510 src="//player.bilibili.com/player.html?aid=714697013&bvid=BV16X4y137qw&cid=311669862&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

  分两步，一步求解next数组(若匹配失败j要回溯到的位置)，第二步模式匹配

  > 求Next数组方法
  >
  > 设主串为$S_1S_2……S_n$，模式串为$P_1P_2……P_m$，设不匹配时应为第k个($k<j$)字符开始比较
  > $$
  > \begin{aligned}
  > & \because S_i \ne P_j \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} \dots S_{i-1} \qquad k \lt j \\
  > & 又\because P_1 \dots P_{j-1} = S_{i-j+1} \dots S_{i-1} \\
  > & \therefore P_{j-k+1} \dots P_{j-1} = S_{i-k+1} \dots S_{i-1} \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1} \\
  > & \therefore k就是P头一个k-1字符与P尾k-1个字符相等的最大值 \\
  > & \therefore next[j] = 
  > \begin{cases}
  > 0 & j=1 \\
  > max\{k | 1 \lt k \lt j 且 P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1}\} \\
  > 1 & 其他情况
  > \end{cases}
  > \end{aligned}
  > $$
  > 例如
  >
  > | 序列       |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
  > | ---------- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
  > | 模式串元素 |  a   |  b   |  a   |  a   |  b   |  c   |  a   |  c   |
  > | next数组   |  0   |  1   |  1   |  2   |  2   |  3   |  1   |  2   |
  >
  > next[1]，next[2]一定分别为0 1；next[j]=第j位字符组成的子串的前后缀重合字符数
  >
  > 故求解过程如下：
  >
  > 1. next[3]：看next[2]与next[1]，发现两个不一样，推到next[2]和next[0]，此时出现0故直接赋值为1
  > 2. next[4]：看next[3]与next[1]，发现一样，故next[3]+1为2
  > 3. next[5]：看next[4]与next[2]，发现不一样，看next[4]与next[1]，一样，则赋值为2
  > 4. next[6]：看next[5]与next[2]，发现一样，故next[5]+1为3
  > 5. next[7]：看next[6]与next[3]，不一样，看next[6]与next[1]不一样，看next[6]与next[0]，出现0直接赋值为1
  > 6. next[8]：看next[7]和next[1]，发现一样，则next[7]+1=2
  >
  > 在不匹配位置前面，划开一条分界线，模式串一步一步往后退，直到分界线前能对上，或模式串完全跨过分解线位置
  >
  > ![image-20220808191752236](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220808191752236.png)
  >
  > ![image-20220810182338505](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220810182338505.png)

```c
int Index_KMP(SString S, SString T, int next[]){
    int i=1, j=1;
    while (i <= S.length && j<=T.length){
        if (j == 0 || S.ch[i] == T.ch[j]){
            ++i;
            ++j;
        } else{
            j = next[j];
        }
    }
    if (j > T.length)
        return i-T.length;
    else
        return 0;
}

int GetNext(SString T, int length, int next[]){
    next[1] = 0;
    int i=1,j=0;
    while (i < length){
        if (j==0 || T.ch[i]==T.ch[j]) next[++i] = ++j;
        else j=next[j];
    }
}
```

# ==栈和队列==

见栈和队列.xmind

# ==树与二叉树==

## 树的基本概念

### 基本术语

#### 概念

树是n ($n \ge 0$) 个结点的有限集合，$n=0$是，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：

1. 有且仅有一个特定的称为根的结点
2. 当$n \gt 1$时，其余结点可分为m ($m \gt 0$) 个互不相交的有限集合$T_1,T_2, \dots ,T_m$，其中每个集合本身又是一个树，并且称为根结点的子树

$\emptyset$：空树，结点数为0的树

非空树特性：

1. 树有且只有一个根结点
2. 只有根结点没有前驱，只有叶子结点没有后继
3. 除了根结点之外，其他结点有且仅有一个前驱

树是一种递归定义的树形结构，即树可以看成是根节点与若干不相交的子树的集合

![image-20220810190101560](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220810190101560.png)

#### 关系描述

祖先结点：从前驱$\to$根结点上的所有结点

子孙结点：自己下面的所有结点

双亲结点：前驱

孩子：后继

兄弟：同层，同双亲结点

堂兄弟：同层，不同双亲结点

路径：从上到下

路径长度：经过几条边

#### 结点，树的属性描述

深度(层次)：从上往下数第几层

结点高度：从下往上数第几层

树的高度：总共多少次

度：有几个分支

树的度：各结点的度的最大值

#### 有序树、无序树

有序：逻辑上看，树中各子树从左到右有次序，不能互换

无序：逻辑上看，树中各子树从左到右无次序，可以互换

#### 树、森林

树：一棵

森林：m ($m \ge 0$) 棵互不相交的树的集合

### ==性质==

1. 结点数=度数+1

2. 度为m的树和m叉树的区别

	|      |             度为m的树             |               m叉树               |
	| :--: | :-------------------------------: | :-------------------------------: |
	| 概念 |        各结点度的最大值为m        |      各结点度的最大值不超过m      |
	| 性质 | 任意结点的度$\le$m（最多m个孩子） | 任意结点的度$\le$m（最多m个孩子） |
	|      | 至少有一个结点度$=$m（有m个孩子） |     允许所有结点的度都$\lt$m      |
	|      |   一定是非空树，至少有m+1个结点   |            可以是空树             |

3. 度为m的树第i层最多有$m^{i-1}$个结点，m叉树第i层最多有$m^{i-1}$个结点

4. 高度为h的m叉树(度为m的树)至多有$m^0+m^1+ \dots +m^{h-1}=\frac{1*(1-m^h)}{1-m}=\frac{m^h-1}{m-1}$个结点

5. 高度为h的m叉树至少有h个结点，高度为h的度为m的树至少有m+h-1个结点

6. 有n个结点的m叉树的最小高度为$h= \lceil \log_m(n(m-1)+1) \rceil$
	$$
	\begin{aligned}
	& \because \frac{m^{h-1}-1}{m-1} \lt n \le \frac{m^h-1}{m-1} \\
	& \therefore m^{h-1} \lt n(m-1)+1 \le m^h \\
	& \therefore h-1 \lt \log_m(n(m-1)+1) \le h \\
	& \therefore h= \lceil \log_m(n(m-1)+1) \rceil
	\end{aligned}
	\tag{1}
	$$

## 二叉树

### 定义及其主要特性

#### 定义

二叉树是n（$n \ge 0$）个结点的有序集合

1. 或者为空二叉树，即$n=0$
2. 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一颗二叉树

特点

1. 每个结点有且仅有两棵子树
2. 左右子树不能颠倒(二叉树是有序树)

五种状态

1. 空二叉树
2. 只有根结点
3. 只有左子树
4. 只有右子树
5. 左右子树都有

#### 几个特殊的二叉树

- 满二叉树

	高度为h且含有$2^h-1$个结点的二叉树；$n=1+2+ \dots +2^{h-1}=\frac{2^h-1}{2-1}=2^h-1$

	特点

	1. 只有最后一层才有叶子结点
	2. 不存在度为1的结点
	3. 按层序开始编号，i结点左孩子为2i，右孩子为2i+1，其父节点为$\lfloor i/2 \rfloor$（若存在）

- 完全二叉树

	当且仅当每个结点都与高度为h的满二叉树中编号为1-n的结点一一对应时称其为完全二叉树

	特点

	1. 只有最后两层有叶子结点
	2. 只存在一个度为1的结点
	3. 按层序开始编号，i结点左孩子为2i，右孩子为2i+1，其父节点为$\lceil i/2 \rfloor$（若存在）
	4. $i \le \lfloor n/2 \rfloor$为分支结点，反之为叶子结点

	![image-20220812184623452](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220812184623452.png)

- 二叉排序树—搜索、排序

	左子树上的所有结点的关键字都小于根结点上的关键字

	根结点上的关键字都小于右子树上的所有结点上的关键字

	左右子树又是二叉排序树

	![image-20220812184732800](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220812184732800.png)

- 平衡二叉树—搜索效率更高

	二叉排序树的改进版，其任意结点左右子树高度差$\le$1

#### 性质

##### 普通二叉树性质

1. 设二叉树中度为0、1、2的结点个数分别为$n_0$、$n_1$、$n_2$，则
	$$
	\begin{aligned}
	& \because n_0+n_1+n_2=n_1+2*n_2+1 \\
	& \therefore n_0=n_2+1
	\end{aligned}
	\tag{1}
	$$

2. 二叉树第i层至多有$2^{i-1}$个结点，m叉树第i层至多有$m^{i-1}$个结点（$i \ge 1$）

3. 高度为h的二叉树至多有$2^h-1$个结点，此时其为满二叉树；高度为h的m叉树至多有$m^h-1$个结点

##### 完全二叉树性质

1. 有n个（$n \gt 0$）结点的完全二叉树的高度h为$\lceil \log_2(n+1) \rceil$或$\lfloor \log_2(n) \rfloor+1$
	$$
	\begin{aligned}
	& \because 2^{h-1}-1 \lt n \le 2^{h}-1 \\
	& \therefore 2^{h-1} \lt n+1 \le 2^{h} \\
	& \therefore {h-1} \lt \log_2(n+1) \le h \\
	& \therefore h=\lceil \log_2(n+1) \rceil \\
	& or \\
	& \because 2^{h-1} \le n \lt 2^{h} \\
	& \therefore {h-1} \le \log_2(n) \lt h \\
	& \therefore h=\lfloor \log_2(n) \rfloor +1 \\
	\end{aligned}
	\tag{2}
	$$

2. 对于完全二叉树，可以由结点数n推出度为0、1、2结点的个数$n_0$、$n_1$、$n_2$
	$$
	\begin{aligned}
	& \because n_0=n_2+1  且 n_1=0orn_1=1 \\
	& \therefore n_0+n_2一定为奇数 \\
	& \therefore 完全二叉树有2k个结点，则n_0=k,n_1=1,n_2=k-1 \\
	& 完全二叉树有2k+1个结点，则n_0=k+1,n_1=0,n_2=k
	\end{aligned}
	\tag{3}
	$$

### 二叉树的存储结构

#### 顺序存储

顺序存储只使用于完全二叉树和满二叉树

可以让第一个位置空缺，保持数组下标与结点编号一致

> 对于完全二叉树or满二叉树而言，第i个结点：
>
> - 左孩子: 2i
> - 右孩子: 2i+1
> - 父节点: $\lfloor i/2 \rfloor$
> - 所在层次: $\lfloor \log_2(n) \rfloor+1$or$\lceil \log_2(n+1) \rceil$
>
> 完全二叉树有n个结点，则
>
> - 是否有左孩子: $2i \le n$
> - 是否有右孩子: $2i+1 \le n$
> - 是否是叶子结点: $i \gt \lfloor n/2 \rfloor$

若存储的不是完全二叉树或满二叉树，则结点编号无法反应逻辑关系；解决方法：强行将树与完全二叉树的结点编号联系起来，但其无法使用i与n的关系求是否存在左右孩子

```c
// 顺序存储
#define MAXSIZE 100
typedef struct TreeNode
{
    int value;
    int isEmpty;
}TreeNode;

// TreeNode t[MAXSIZE];  定义长度为MaxSize的数组，从上到下从左往右依次存储完全二叉树中的各个结点

void InitTree(TreeNode t[]){
    for (int i = 0; i < MAXSIZE; i++)
    {
        t->isEmpty = 1;
    }
}
```

#### 链式存储

对于链式存储，树假如有n个结点，则总共会有2n个指针域，而被链接的结点只有n-1个，故还有n+1个指针域被空闲，这些空闲的指针域可以用来构建线索二叉树

```c
// 链式存储，找孩子方便，找父亲困难
typedef struct BiTNode
{
    int data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
// 链式存储，找父亲方便
typedef struct BiTNode
{
    int data;
    struct BiTNode *lchild, *rchild;
    struct BiTNode *parent;
}BiTNode, *BiTree;
```

## 二叉树的遍历与线索二叉树

### 二叉树的遍历

共有三种深度遍历方法与一种广度遍历方法

- 深度遍历

	- 先序遍历：根，左，右
	- 中序遍历：左，根，右
	- 后序遍历：左，右，根

- 广度遍历

	使用队列辅助实现，先放入根节点，然后从队头取出时依次放入当前结点的左右子树结点，以此循环往复直到队空

#### 前期准备工作

分别编写初始化二叉树与生成二叉树的方法；

```c
int InitBiTree(BiTree *tree){
    (*tree) = (BiTree)malloc(sizeof(BiTNode));
    if ((*tree)==NULL)
    {
        return 0;
    }
    (*tree)->data=-1;
    (*tree)->lchild=NULL;
    (*tree)->rchild=NULL;
    return 1;
}

BiTree AssignBiTree(BiTree *tree){
    int i;
    printf("请输入树结点数据\n");
    scanf("%d", &i);
    if (i == -1)
        *tree = NULL;
    else{
        InitBiTree(tree);
        (*tree)->data = i;
        AssignBiTree(&((*tree)->lchild));
        AssignBiTree(&((*tree)->rchild));
    }
}
```

#### 深度遍历

##### 先序遍历

二叉树结点为空则什么都不做，不为空则访问根节点，前序访问左子树，前序访问右子树

```c
void PreOrder(BiTree tree){
    if (tree != NULL)
    {
        printf("%d ", tree->data);
        PreOrder(tree->lchild);
        PreOrder(tree->rchild);
    }
}
```

##### 中序遍历

二叉树结点为空则什么都不做，不为空则中序访问左子树，访问根节点，中序访问右子树

```c
void InOrder(BiTree tree){
    if (tree != NULL)
    {
        InOrder(tree->lchild);
        printf("%d ", tree->data);
        InOrder(tree->rchild);
    }
}
```

##### 后序遍历

二叉树结点为空则什么都不做，不为空则后序访问左子树，后序访问右子树，访问根节点

```c
void PostOrder(BiTree tree){
    if (tree != NULL)
    {
        PostOrder(tree->lchild);
        PostOrder(tree->rchild);
        printf("%d ", tree->data);
    }
}
```

> **每个结点都要路过三次**，先序遍历在第一次路过访问，中序遍历在第二次路过访问，后序遍历在第三次路过访问

#### 求树深度

```c
int BiTreeDepth(BiTree tree){
    if (tree == NULL)
    {
        return 0;
    }
    else
    {
        int l = BiTreeDepth(tree->lchild);
        int r = BiTreeDepth(tree->rchild);
        // 树深度等于左右子树深度最大值+1
        return l>r ? l+1 : r+1; 
    }
}
```

#### 层序遍历

1. 初始化一个辅助队列
2. 根结点入队
3. 若队列非空则队头结点出队，访问该结点，并将其左右孩子放入队列

```c
void LevelOrder(BiTree tree)
{
    LinkQueue Q;
    InitLQueue(&Q);
    BiTree p;
    EnLQueue(&Q, T);
    while (!LQueueEmpty(Q))
    {
        DeLQueue(&Q, p);
        printf("%d ", p->data);
        if (p->lchild!=NULL)
        {
            EnLQueue(&Q, p->lchild);
        }
        if (p->rchild!=NULL)
        {
            EnLQueue(&Q, p->rchild);
        }
    }
}
```

#### 由遍历序列构造二叉树

若只有二叉树的前/中/后/层序遍历结果则无法唯一确认二叉树，若有前+中/后+中/层+中则可以唯一确认一个二叉树

##### 前+中

> 中序：EAFDHCBGI
>
> 前序：DAEFBCHGI
>
> ```mermaid
> graph TD
> D --> A
> D --> B
> A --> E
> A --> F
> B --> C
> B --> G
> C --> H[H左]
> G --> I[I右]
> ```

##### 后+中

> 后序：EFAHCIGBD
>
> 中序：EAFDHCBGI
>
> ```mermaid
> graph TD
> D --> A
> D --> B
> A --> E
> A --> F
> B --> C
> B --> G
> C --> H[H左]
> G --> I[I右]
> ```

##### 层+中

> 层序：ABCDE
>
> 中序：ACBED
>
> ```mermaid
> graph TD
> A --> B[B右]
> B --> C
> B --> D
> D --> E[E左]
> ```

#### 二叉树的非递归遍历算法

##### 先序遍历

使用栈即可实现，主要思想是先将根结点压入栈，然后结点出栈并访问结点，然后依次将结点的右孩子、左孩子压入栈，直到栈为空为止

```c
void PreOrderIter(BiTree T){
    if(T == NULL) return;
    Stack s;
    InitStack(&s);
    push(&s, T);
    while(!IsEmpty(s)){
        BiNode *t;
        Pop(&s, t);
        visit(t);
        if(t->rchild != NULL)
            Push(&s, t->rchild);
        if(t->lchild != NULL)
            Push(&s, t->lchild);
    }
}
```

另一种使用栈的方法，当左子树遍历完后，需要回溯并访问右子树，每次Pop出结点时都是回溯到父节点的过程，即左子树已空，可以访问右子树了

```c
void PreOrderIter(BiTree T){
    Stack s;
    InitStack(&s);
    BiNode *t = T;
    while(t != NULL || !IsEmpty(s)){
        if(t != NULL){
            visit(t);
            Push(&s, t);
            t = t->lchild;
        }
        else{
            Pop(&s, t);
            t = t->rchild;
        }
    }
}
```

##### 中序遍历

也使用栈实现，与先序遍历算法2类似，但算法访问结点时机不同

```c
void InOrderIter(BiTree T){
    Stack s;
    InitStack(&s);
    BiNode *t = T;
    while(t != NULL || !IsEmpty(s)){
        if(t != NULL){
            Push(&s, t);
            t = t->lchild;
        }
        else{
            Pop(&s, t);
            visit(t);
            t = t->rchild;
        }
    }
}
```

##### 后序遍历

可以使用两个栈实现后序遍历非递归算法，可以将后序算法看作是先访问根节点，再访问右孩子之后访问左孩子的逆过程，算法步骤如下：

1. Push结点到第一个栈s中
2. 从第一个栈s中Pop出一个结点，并将其Push到第二个栈Output中
3. 然后依次Push结点的左、右孩子到第一个栈s中
4. 重复2、3步直到栈s为空
5. 完成后，所有结点都在output栈里，而且按后序遍历的顺序存放，直接全部Pop出来就是二叉树后序遍历结果

```c
void PostOrderIter(BiTree t){
    Stack s, output;
    InitStack(&s);
    InitStack(&output);
    
    BiNode *temp;
    Push(&s, t);
    while(!IsEmpty(s)){
        Pop(&s, temp);
        Push(&output, temp);
        if(temp->lchild!=NULL)
            Push(&s, temp->lchild);
        if(temp->rchild!=NULL)
            Push(&s, temp->rchild);
    }
    
    while(!IsEmpty(output)){
        Pop(&output, temp);
        visit(temp);
    }
}
```

### 线索二叉树

#### 基本概念

对于普通二叉树，每次遍历必须从根结点开始，且对于二叉树内结点p求其遍历序列中的前驱和后继必须进行遍历才能找到

> 从根节点出发，重新进行遍历，指针q记录当前访问节点，节点pre记录前驱
>
> - 求前驱
>
> 	q==p，pre\==p前驱
>
> - 求后继
>
> 	pre==p，q\==p后继

故对于普通二叉树，求前驱和后继都很不方便

线索二叉树：因为n个节点的指针有2n个指针域且有n-1个节点被指，故有n+1个空域可以用来存储前驱和后继关系(左孩子存前驱，右孩子存后继)

> 中序线索二叉树例子
>
> ![image-20220815190048535](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220815190048535.png)

#### 存储结构

```c
typedef struct ThreadNode{
    int data;
    struct ThreadNode *lchild, *rchild;     // 左右子树
    int ltag, rtag;                         // 左右线索标志
}ThreadNode, *ThreadTree;
```

#### 线索化二叉树

1. 中序线索化

	```c
	// 全局遍历pre，记录节点前驱
	ThreadNode *pre=NULL;
	void visit(ThreadNode *q){
	    if (q->lchild == NULL){
	        // 左孩子为空则指向前驱
	        q->lchild = pre;
	        q->ltag = 1;
	    }
	    if (pre != NULL && pre->rchild == NULL){
	        // 创建前驱的后继节点
	        pre->rchild = q;
	        pre->rtag = 1;
	    }
	    pre = q;
	}
	void InThread(ThreadTree *T){
	    if (*T != NULL){
	        InThread(&((*T)->lchild));
	        visit(*T);
	        InThread(&((*T)->rchild));
	    }
	}
	void CreateInThread(ThreadTree *T){
	    pre = NULL;
	    if (*T != NULL){
	        InThread(T);
	        if (pre->rchild == NULL)
	            pre->rtag = 1;
	    }
	}
	```

2. 先序线索化

	```c
	void PreThread(ThreadTree *T){
	    if (*T != NULL){
	        visit(*T);
	        if ((*T)->ltag == 0)
	            PreThread(&((*T)->lchild));
	        PreThread(&((*T)->rchild));
	    }
	}
	void CreatePreThread(ThreadTree *T){
	    pre = NULL;
	    if (*T != NULL){
	        PreThread(T);
	        if (pre->rchild == NULL)
	            pre->rtag = 1;
	    }
	}
	```

	只改PreThread，因为先序遍历可能出现前序节点为自己的上级，且自己无左孩子，若不修改PreThread，则由于visit时已将左孩子修改为上级，则此时访问左节点便又会回到上级节点，如

	![image-20220816184403008](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220816184403008.png)

	D前驱为B，在visit前D左孩子为空，visit后D左孩子为B，ltag=1，若不检查ltag则会继续访问D左孩子即B出现死循环

3. 后序

	都不变

	```c
	void PostThread(ThreadTree *T){
	    if (*T != NULL){
	        PreThread(&((*T)->lchild));
	        PreThread(&((*T)->rchild));
	        visit(*T);
	    }
	}
	void CreatePostThread(ThreadTree *T){
	    pre = NULL;
	    if (*T != NULL){
	        PostThread(T);
	        if (pre->rchild == NULL)
	            pre->rtag = 1;
	    }
	}
	```

	访问P时左右孩子已经访问结束，不可能访问左子树指向的子树

#### 在线索二叉树中找前驱和后继节点

1. 中序线索二叉树

  - 后继

	第一个节点必为最左下角的节点

	找下一个节点：p->rtag==1 next=p->rchild; p->rtag\==0 next=p节点右孩子最左下角节点

  - 前驱

	最后一个节点必为最右下角的节点

	找前一个结点：p->ltag==1 next=p->lchild; p->ltag\==0 next=p节点左孩子最右下角节点

  ```c
  // 中序遍历第一个节点
  ThreadNode *InFirstNode(ThreadNode *p){
  	while(p->ltag==0)
          p = p->lchild;
  	return p;
  }
  // 中序遍历后继
  ThreadNode *InNextNode(ThreadNode *p){
  	if(p->rtag == 1)
          return p->rchild;
   	else
          return InFirstNode(p->rchild);
  }
  // 中序遍历，非递归
  void InOrder(ThreadTree T){
  	for(ThreadNode *p=InFirstNode(T);p!=NULL;p=InNextNode(p))
          printf("%d ", i->data);
      printf("\n");
  }
  
  // 倒序输出中序遍历
  // 中序遍历最后一个节点
  ThreadNode *InLastNode(ThreadNode *p){
      while(p->rtag==0)
          p=p->rchild;
      return p;
  }
  // 中序遍历前驱
  ThreadNode *InPreNode(ThreadNode *p){
  	if(p->ltag==1)
          return p->lchild;
      else
          return InLastNode(p->lchild);
  }
  // 逆中序遍历，非递归
  void RevInOrder(ThreadTree p){
      for (ThreadNode *i = InLastNode(p); i != NULL; i=InPreNode(i)) {
          printf("%d ", i->data);
      }
      printf("\n");
  }
  ```

2. 前序线索二叉树

  - 后继

	p->rtag==1 next=p->rchild

	p->rtag==0 p->ltag\==0(即本结点左右子树都有故后继为左子树) next=p->lchild

	p->rtag==0 p->ltag\==1(即本届点右子树不空而左子树空故后继为右子树)next=p->rchild

  - 前驱

	p->ltag==1 next=p->lchild

	p->ltag==0则只能重新遍历找前驱

	```c
	if(p为根结点)
		// 无前驱
		return NULL;
	else
		从头遍历找到其父节点
		if(p为左孩子)
			return 父节点;
		if(p为右孩子，且左孩子为空)
			return 父节点;
		if(p为右孩子，且左孩子不为空)
			return 左孩子最后一个被访问的结点;
	```

3. 后序线索二叉树

- 前驱

	p->ltag=1 prior=p->lchild

	p->ltag=0 p->rtag=0 prior=p->rchild

	p->ltag=0 p->rtag=1 prior=p->lchild

- 后继

	p->rtag=1 next=p->rchild

	p->rtag==0则只能重新遍历找前驱

	``` c
	if(p为根结点)
		// 无后继
		return NULL;
	else
		从头遍历找到其父节点
		if(p为右孩子)
			return 父节点;
		if(p为左孩子，且右孩子为空)
			return 父节点;
		if(p为左孩子，且右孩子不为空)
			return 右孩子第一个被访问的结点;
	```

## 树、森林

### 树的存储结构

#### 双亲表示法

优点：找父节点方便；缺点：找孩子节点困难

每个节点中保存指向双亲的指针，顺序存储

```c
// 树的双亲表示法，顺序存储
typedef struct PTNode
{
    int data;
    int parent;
}PTNode;
typedef struct PTree
{
    PTNode nodes[MAXSIZE];
    int n;   //结点数
};
```

![image-20220822182747388](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220822182747388.png)

|      | data | parent |
| :--: | :--: | :----: |
|  0   |  A   |   -1   |
|  1   |  B   |   0    |
|  2   |  C   |   0    |
|  3   |  D   |   0    |
|  4   |  E   |   1    |
|  5   |  F   |   1    |
|  6   |  G   |   2    |
|  7   |  H   |   3    |
|  8   |  I   |   3    |
|  9   |  J   |   3    |
|  10  |  K   |   4    |

增加节点直接在树中添加信息即可；删则会让双亲度减1且需要移动后面的元素，若删除的是叶子节点则直接删除，若不是则需要遍历删除

#### 孩子表示法(顺序+链式存储)

优点：找孩子方便；缺点：找父亲困难

```c
// 树的孩子表示法，顺序+链式存储
struct CTNode
{
    int child;                  // 孩子结点在数组中的位置
    struct CTNode *next;            // 下一个孩子结点
};
typedef struct CTBox
{
    int data;
    struct CTNode *firstChild;      //第一个孩子
}CTBox;
typedef struct CTree
{
    CTBox nodes[MAXSIZE];
    int n, r;       // 结点数与根所在的位置
}CTree;
```

上图中的树用孩子表示法即

![image-20220822184541937](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220822184541937.png)

#### 左孩子右兄弟表示法(链式存储)

如此就可以使用二叉树的操作来操作树

![image-20220822184549773](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220822184549773.png)

```c
// 树的左孩子右兄弟表示法，链式存储
typedef struct CSNode
{
    int data;
    struct CSNode *firstChild, *nextSibling;        // 左孩子右兄弟
}CSNode, *CSTree;
```

#### 森林与二叉树的转化

森林是n ($n \gt 0$) 棵互不相交的树的集合，采用左孩子右兄弟方法，将各树根结点看做兄弟结点

![image-20220822185115871](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220822185115871.png)

### 树、森林的遍历

#### 树的遍历

![image-20220822185619825](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220822185619825.png)

##### 深度遍历—DFS

###### 先根遍历

若树非空，先访问根结点，之后再依次对其子树进行先根遍历

```c
// 树的先根遍历
void PreOrder(CSTree T){
    if(T != NULL){
        visit(T);			// 访问根节点
        while(结点还有下一个子树R)
            PreOrder(R);	// 先根遍历其子树
    }
}
```

故上图中的树先根遍历序列为：ABEKFCGDHIJ

**可见树的先根遍历序列与其二叉树表示方式的先序遍历序列一致**

###### 后根遍历

若树非空，则先对每个子树进行后根遍历，之后再访问根节点

```c
void InOrder(CSTree T){
    if(T != NULL){
        while(T有其他子树R)
            InOrder(R);
        visit(T);
    }
}
```

故上图中的树后根遍历序列为：KEFBGCHIJDA

**可见树的后根遍历序列与其二叉树表示方式的中序遍历序列一致**

##### 广度遍历—BFS

1. 若树非空，则根结点入队
2. 若队列非空，则队头元素出队并访问，同时将该元素的所有孩子都依次入队
3. 重复2直到队空

#### 森林遍历

![image-20220823182058962](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220823182058962.png)

##### 先序遍历

对各个树先根遍历，对应二叉树的先序

若森林非空，则

1. 访问第一棵树的根结点
2. 先序遍历第一颗树中根节点的子树森林
3. 先序遍历除去第一颗树之后剩余的树构成的森林

BEKLFCGDHMIJ

##### 中序遍历

对每个树后根遍历，对应树二叉的中序

若森林非空，则

1. 先序遍历第一颗树中根节点的子树森林
2. 访问第一颗树的根结点
3. 先序遍历除去第一颗树之后剩余的树构成的森林

KLEFBGCMHIJD

## ==树与二叉树的应用==

### 二叉排序树(BST)

#### 定义—有序组织搜索元素

二叉排序树(BST)，也可以叫二叉查找树，有如下性质的二叉树或空二叉树：

- 左子树上的所有结点上的关键字都小于根节点上的关键字
- 右子树上的所有结点上的关键字都大于根结点上的关键字
- 左右子树也是二叉排序树

此时只要进行中序遍历，其结果就是递增的序列

#### 查找

若树非空，则将结点的关键字与当前值相比

1. 若相等则成功
2. 若不相等则失败，小于则去左子树，大于则去右子树

成功就返回结点指针，失败就返回null

```c
// 非递归查找
BSTNode *NoRBST_Search(BSTree T, int key){
    // 如果节点不为空且节点值不相等则继续循环
    while (T != NULL && key != T->key)
    {
        if (key < T->key)
            T = T->lchild;
        else
            T = T->rchild;
    }
    return T;
}
// 递归查找
BSTNode *BST_Search(BSTree T, int key){
    if (T == NULL)
        return NULL;
    else if (key == T->key)
        return T;
    else if (key < T->key)
        return BST_Search(T->lchild, key);
    else
        return BST_Search(T->rchild, key);
}
```

#### 插入

若原来为空树，则直接插入；若key小于结点，则去其左子树；反之就去右子树

易得到不同关键字顺序可以有同一种二叉树，也可能不同

```c
// 递归插入，最差空间复杂度为O(n)
int BST_Insert(BSTree *Tree, int key){
    if ((*Tree) == NULL){
        // 直接插入
        (*Tree) = (BSTree)malloc(sizeof(BSTree));
        (*Tree)->key = key;
        (*Tree)->lchild = (*Tree)->rchild = NULL;
        return 1;
    }
    if (key == (*Tree)->key)
        return 0;
    else if (key < (*Tree)->key)
        return BST_Insert(&((*Tree)->lchild), key);
    else
        return BST_Insert(&((*Tree)->rchild), key);
}
// 非递归插入，最差空间复杂度为O(1)
int NoRBST_Insert(BSTree *Tree, int key){
    // 若树为空，则直接插入
    if ((*Tree) == NULL){
        // 直接插入
        (*Tree) = (BSTree)malloc(sizeof(BSTree));
        (*Tree)->key = key;
        (*Tree)->lchild = (*Tree)->rchild = NULL;
        return 1;
    }

    // 树不为空，则记录上一个节点与自己
    BSTree pre = NULL;
    BSTree pnow = (*Tree);
    while (pnow != NULL){
        // 找到最后一个节点
        if (key == pnow->key)
            return 0;
        else if (key < pnow->key){
            // 往左走
            pre = pnow;
            pnow = pnow->lchild;
        } else{
            // 往右走
            pre = pnow;
            pnow = pnow->rchild;
        }
    }

    // 之后判断key值与pre的关系
    if (key < pre->key){
        BSTNode *now = (BSTNode *)malloc(sizeof(BSTNode));
        (*now).key = key;
        (*now).lchild = (*now).rchild = NULL;
        pre->lchild = now;
    } else{
        BSTNode *now = (BSTNode *)malloc(sizeof(BSTNode));
        (*now).key = key;
        (*now).lchild = (*now).rchild = NULL;
        pre->rchild = now;
    }
    return 1;
}
```

#### 删除

首先找到目标结点

1. 若被删除结点为叶子结点，则直接删除

2. 若被删除结点只有一棵左子树或右子树，则让左子树或右子树成为目标结点的子树，代替他的位置

3. 若被删除结点有左右子树，则令目标结点的直接后继(直接前驱)代替目标结点，然后在二叉树中删除该直接后继(直接后继)，这样就转化为了第1或第2两种情况

	这里的直接前驱/后继表示中序遍历的前驱后继

#### 查找效率分析

若树高为n，则最多比较n次，故时间复杂度为$O(\log_2(n))$，最差为$O(n)$

查找长度：在查找运算中，需要对比关键字次数，反应了查找操作时间复杂度

> ![image-20220824184304210](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220824184304210.png)
>
> - 查找成功平均查找长度ASL
>
> 	1：$\frac{1+2*2+3*4+4}{8}=2.625$
>
> 	2：$\frac{1+2*2+3+4+5+6+7}{8}3.75$
>
> 	故1优于2
>
> - 查找失败平均查找长度ASL
>
> 	1：$\frac{7*3+4*2}{9}=3.22$
>
> 	2：$\frac{3*2+3+4+5+6+7*2}{9}=4.22$

### 平衡二叉树(AVL)

#### 定义

平衡二叉树，简称平衡树(AVL)，即树上任一结点左右子树高度差不超过1

结点平衡因子=左子树高-右子树高

#### 插入

从插入点往回找到第一个不平衡结点，调整该结点为根的子树，每次调整对象都是最小不平衡子树，调整后其他结点都会平衡

1. LL平衡旋转(右单旋转)

	由于在结点A的左子树(L)的左孩子(L)上插入新结点，A的平衡因子由1增至2，故可以以A为根的子树做一次向右的旋转操作，如下：

	![image-20220825182840856](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825182840856.png)

2. RR平衡旋转(左单旋转)

	由于在结点A的右子树(R)的右孩子(R)上插入新结点，A的平衡因子由-1减至-2，故可以以A为根的子树做一次向左的旋转操作，如下：

	![image-20220825183018123](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825183018123.png)

3. LR平衡旋转(先左后右双旋转)

	由于在结点A的左子树(L)的右孩子(R)上插入新结点，A的平衡因子由1增至2，故可以以A为根的子树做一次先左后右的旋转操作，如下：

	![image-20220825183348530](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825183348530.png)

4. RL平衡旋转(先右后左旋转)

	由于在结点A的右子树(R)的左孩子(L)上插入新结点，A的平衡因子由-1减至2，故可以以A为根的子树做一次先右后左的旋转操作，如下：

	![image-20220825183413776](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825183413776.png)

> {40， 72，38，35，67，51，90，8，55，21}构建平衡二叉树
>
> ![image-20220825184023973](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825184023973.png)
>
> {34，23，15，98，115，28，107}构建平衡二叉树
>
> ![image-20220825184534833](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825184534833.png)

##### 代码实现思路

1. LL & RR

	对LL来说，即实现f向右下旋转，p向右上旋转，其中f为父节点A，p为其左孩子B，gf为f的父节点

	```c
	f->lchild=p->rchild;
	p->rchild=f;
	gf->lchild/rchild=p;
	```

	对RR来说，即实现f向左下旋转，p向左上旋转，其中f为父节点A，p为其右孩子B，gf为f的父结点

	```c
	f->rchild=p->lchild;
	p->lchild=f;
	gf->lchild/rchild=p;
	```

2. LR & RL

	对LR来说，即实现f向右下旋转，p向右上旋转，而g相对不变，其中f为父节点A，p为其左孩子B，g为p的右孩子C，gf为f的父节点

	```c
	// f、p实现左旋
	p->rchild=g->lchild;
	g->lchild=p;
	// f->lchild=g; 下一句就重新定义了故省去
	// f、g实现右旋
	f->lchild=g->rchild;
	g->rhild=f;
	gf->lchild/rchild=g;
	```

	对RL来说，即实现f向左下旋转，p向左上旋转，而g相对不变，其中f为父节点A，p为其右孩子B，g为p的左孩子C，gf为f的父节点

	```c
	// 实现p、g之间的右旋
	p->lchild=g->rchild;
	g->rchild=p;
	// f->rchild=g; 下一句就重新定义了故省去
	// 实现g、f之间的左旋
	f->rchild=g->lchild;
	g->lchild=f;
	gf->lchild/rchild=g;
	```

> 为什么调整最小不平衡树会让其他祖先重新平衡
>
> - 因为是插入导致的最小不平衡树高度+1，经调整后该树高度恢复

故查找效率$\le O(h)$，h为树高，最大为$O(\log_2n)$，平均查找长度也是$O(\log_2n)$

### 哈夫曼树和哈夫曼编码

#### 定义

给结点赋值，表示结点重要性

带权路径长度：从树的根到该结点的路径长度(经过的边数)与该结点上的权值的乘数

树的带权路径长度：树的所有叶子结点的带权路径长度之和，即$WPL=\sum_{i=1}^nW_il_i$

哈夫曼树：含有n个带权叶结点的二叉树，其中带权路径长度(WPL)最小的二叉树成为哈夫曼树，也称最优二叉树

#### 构造

给定n个权值分别为$W_1$、$W_2$、……、$W_n$的结点，构造哈夫曼树的算法描述如下

- 将这n个结点分别作为n棵仅剩一个结点的二叉树，构成森林F
- 构造一个新节点，从F中选取两颗节结点权值最小的树作为新节点的左右子树，并且将新节点的权值置为左右子树上根结点的权值之和
- 从F中删除刚才选中的两棵树，同时将新得到的树加入F中
- 重复2、3直到F中只剩一棵树为止

![image-20220826183527123](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220826183527123.png)

> Note
>
> 1. 每个初始节点最终都是叶子结点，且权值越小的结点到根结点的路径长度越大
>
> 2. 哈夫曼树的结点个数为2n-1，即无度为1的结点
>
> 	n个叶子，度为2(n-1)，故共2n-1个结点
>
> 3. **哈夫曼树无度为1结点**
>
> 4. 哈夫曼树不唯一，但WPL一定最小

#### 哈夫曼编码—前缀编码

使用哈夫曼树(构树时左0右1)让编码长度(可变长度编码，允许对不同值用不同长度编码)也就是树带权长度最小

**不使用哈夫曼编树构造的可变长度编码可能存在歧义问题**

**没有一个编码是另一个编码的前缀，则这种编码就是前缀编码，故非前缀编码可能存在歧义**

哈夫曼编码不唯一，可用于数据压缩

# ==图==

## 图的基本概念

### 图的定义

图由**顶点集V和边集E**组成，记为$G=\{V,E\}$，其中$V(G)$表示图G中顶点的有限非空集；$E(G)$表示图中顶点之间的关系(边)集合。若$V=\{v_1,v_2, \dots,v_n\}$，则用**$|V|$表示图G中顶点的个数，也称图G的阶**；$E=\{(u,v)|u \in V,v \in V\}$，用**$|E|$表示图G中边的条数**

> 线性表可以空，树可以空，图不能空(指**结点集V一定非空，而边集E可空**)

1. 无向图

  ![image-20220826185555037](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220826185555037.png)

2. 有向图

  ![image-20220826185636262](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220826185636262.png)

3. 简单图、多重图

  简单图：无重复边，无结点到自身的边

  多重图：某两点之间的边多于1条，或允许结点通过一条边与自己链接

  ![image-20220826190015007](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220826190015007.png)

4. 完全图(简单完全图)

  无向完全图：任意两个结点之间都有边的无向图，故n个结点就有$C_{n}^2$条边

  有向完全图：任意两个结点之间都有边的有向图，故n个结点就有$2C_{n}^2$条边

  边很少的图为稀疏图($|E| \lt |V|log|V|$)，反之为稠密图

5. 顶点的度、入度、出度

  对无向图来说，顶点的度指依附于顶点v的边数目，记为$TD(v)$；$\sum_{i=1}^nTD(v_i)=2e$

  对有向图来说，顶点的入度是以顶点v为终点的边数目，记为$ID(v)$；顶点的出度是以顶点v为起点的边数目，记为$OD(v)$；$\sum_{i=1}^nID(v_i)=\sum_{i=1}^nID(v_i)=e$；顶点的度=入度

6. 顶点之间关系描述

	![image-20220829182345878](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220829182345878.png)

7. 连通图、强连通图

	连通图(无向)：任意两个结点都连通

	强连通图(有向)：任意两个结点都强连通

	对无向图：连通至少要n-1条边，非连通最多$C_n^2$

	对有向图：连通最少n条边(一个回路)

8. 子图

	![image-20220829182857030](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220829182857030.png)

	边都有就是生成子图

9. 连通分量(无向图)

	无向图中的极大连通子图(子图连通，尽可能多的顶点和边)称为连通分量

10. 强连通分量

	有向图中的极大强连通子图(子图强连通，尽可能多的顶点和边)称为连通分量

11. 生成树、生成森林

	连通图(无向)的生成树是包含图中全部顶点的一个极小连通子图(不唯一)，n个顶点n-1条边

	在非联通图中，连通分量的生成树构成生成森林

12. 边的权、带权图/网

	边的权：一个图中，每条边都可以标上具有某种含义的数值，即边的权

	带权图/网：边上有权值的图

	带权路径长度：当图为带权图时，一条路径上所有边的权值之和

13. 特殊的图—树、森林

	有向树：只有一个顶点入度为0，其出度均为1的图

	![image-20220829183704773](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220829183704773.png)

14. ==常见考点==

	对于n个顶点的无向图G

	- 所有顶点度的和=2$|E|$
	- 若G为连通图，则最少有n-1条边
	- 若$|E| \gt n-1$，则一定存在回路
	- 若G为连通图，则最多可能有$C_n^2$条边
	- 无向完全图有$C_n^2$条边

	对于n个顶点的有向图G

	- 顶点的入度和=顶点的出度和=$|E|$
	- 所有顶点度的和=2$|E|$
	- 若G为连通图，则最少有n条边
	- 有向完全图有2$C_n^2$条边

## 图的存储及基本操作

### 邻接矩阵法

在确定顶点序号后，表示方法唯一

```c
# define MaxVertexNum 100
typedef char VertexType;            // 顶点的数据类型
typedef int EdgeType;               // 带权图中边上权值的数据类型
typedef struct {
    VertexType Vex[MaxVertexNum];   // 顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];  // 邻接矩阵，边表
    int vexnum, arcnum;                         // 图当前的顶点数和弧数
}MGraph;                            // 无向图
```

$$
A[i][j]=
\begin{cases}
1 & 若(v_i,v_j)或<v_i,v_j>是边 \\
0 & 若(v_i,v_j)或<v_i,v_j>不是边
\end{cases}
\tag{1}
$$

若为带权图，则在临接矩阵中放权值，若无边则放无穷

空间复杂度—$O(n^2)$，适合稠密图，对无向图(对称矩阵)可以进行压缩存储

性质：设图G的邻接矩阵为A(元素为0、1)，则$A^n$的元素$A^n[i][j]$等于由顶点i到j长度为n的路径的数目

### 邻接表法

```c
// 邻接表法
// 边
typedef struct ArcNode{
    int adjvex;                     // 边指向那个结点
    typedef struct ArcNode *next    // 指向下一条边的指针
    InfoType info;                  // 权值
}ArcNode;
// 顶点
typedef struct VNode{
    VertexType data;                // 顶点信息
    ArcNode *first;                 // 第一条边
}VNode, AdjList[MaxVertexNum];
// 图
typedef struct {
    AdjList vertices;               // 顶点与边
    int vexnum, arcnum;             // 图当前的顶点数和弧树
}ALGraph;
```

空间复杂度

- 无向图：$O(|V|+2|E|)$
- 有向图：$O(|V|+|E|)$

度

- 无向图：边链表个数
- 有向图：入度+出度
	- 入度：遍历所有结点记录
	- 出度：边链表个数

> 图的邻接表法表示方法不一致，适合稀疏图

### 十字链表 & 邻接多重表

邻接矩阵空间复杂度高，邻接表有向图查入度困难

#### 十字链表法

有向图的一种存储方式，顶点之间顺序存储

![image-20220830181751060](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220830181751060.png)

空间复杂度：$O(|V|+|E|)$

```c
// 十字链表法
// 边
typedef struct ArcNode{
    int tailvex;                    // 弧尾结点
    int headvex;                    // 弧头结点
    InfoType info;                  // 弧权值
    ArcNode *hlink;                 // 弧头相同的下一条弧
    ArcNode *tlink;                 // 弧尾相同的下一条弧
}ArcNode;
// 顶点
typedef struct VNode{
    VertexType data;                // 顶点信息
    ArcNode *firstin;               // 该顶点作为弧头的第一条边
    ArcNode *firstout;              // 该顶点作为弧尾的第一条边
}VNode, AdjList[MaxVertexNum];
// 图
typedef struct {
    AdjList vertices;               // 顶点与边
    int vexnum, arcnum;             // 图当前的顶点数和弧树
}ALGraph;
```

#### 邻接多重表法

每条边都有两份冗余信息，删除结点、边等操作时时间复杂度高；无向图的一种存取方式

![image-20220830182802969](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220830182802969.png)

空间复杂度为$O(|V|+|E|)$

```c
// 邻接多重表法
// 边
typedef struct ArcNode{
    int i;                    // 弧尾结点
    int j;                    // 弧头结点
    InfoType info;                  // 弧权值
    ArcNode *ilink;                 // 依附于结点i的下一条弧
    ArcNode *jlink;                 // 依附于结点j的下一条弧
}ArcNode;
// 顶点
typedef struct VNode{
    VertexType data;                // 顶点信息
    ArcNode *first;               	// 与该顶点香玲的第一条边
}VNode, AdjList[MaxVertexNum];
// 图
typedef struct {
    AdjList vertices;               // 顶点与边
    int vexnum, arcnum;             // 图当前的顶点数和弧树
}ALGraph;
```

### 存储结构之间对比

|              |                邻接矩阵                |                 邻接表                  |   十字链表   |  邻接多重表  |
| :----------: | :------------------------------------: | :-------------------------------------: | :----------: | :----------: |
|  空间复杂度  |               $O(|V|^2)$               | 无向图$O(|V|+2|E|)$；有向图$O(|V|+|E|)$ | $O(|V|+|E|)$ | $O(|V|+|E|)$ |
|   找相邻边   |     遍历对应行或列找到第一个正常数     |  一般较简单，但要找有向图的入边很困难   |     方便     |     方便     |
| 删除边或顶点 | 删除边很方便，删除顶点需要移动大量数据 |       无向图删除边或结点都很困难        |     方便     |     方便     |
|    适用于    |                 稠密图                 |                 稀疏图                  |    有向图    |    无向图    |
|   表示方式   |                  唯一                  |                 不唯一                  |    不唯一    |    不唯一    |

### 图的基本操作

![image-20220830183803696](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220830183803696.png)

1. Adjacent(G, x, y)：判断图G是否有边<x, y>或(x, y)

  |        |            邻接矩阵             |                         邻接表                         |
  | :----: | :-----------------------------: | :----------------------------------------------------: |
  | 无向图 | G\[x][y]!=0；时间复杂度为$O(1)$ | G[x]的链表遍历；时间复杂度最好为$O(1)$，最差为$O(|V|)$ |
  | 有向图 | G\[x][y]!=0；时间复杂度为$O(1)$ | G[x]的链表遍历；时间复杂度最好为$O(1)$，最差为$O(|V|)$ |

2. Neighbors(G, x)：列出与x邻接的边

	|        |                     邻接矩阵                     |                            邻接表                            |
	| :----: | :----------------------------------------------: | :----------------------------------------------------------: |
	| 无向图 | G\[x][y]的行或列不为0的值；时间复杂度为$O(|V|)$  |      G[x]的链表；时间复杂度最好为$O(1)$，最差为$O(|V|)$      |
	| 有向图 | G\[x][y]的行和列不为0的值；时间复杂度为$O(2|V|)$ | 对于其出边，时间复杂度最好为$O(1)$，最差为$O(|V|)$；对于其入边则需要遍历所有边，时间复杂度为$O(|E|)$ |

3. InsertVertex(G, x)：在结点中插入顶点x

	|        |                     邻接矩阵                     |             邻接表              |
	| :----: | :----------------------------------------------: | :-----------------------------: |
	| 无向图 | 点数组扩充1，边数组上下扩充1；时间复杂度为$O(1)$ | 点数组扩充1；时间复杂度为$O(1)$ |
	| 有向图 | 点数组扩充1，边数组上下扩充1；时间复杂度为$O(1)$ | 点数组扩充1；时间复杂度为$O(1)$ |

4. DeleteVertex(G, x)

	|        |                           邻接矩阵                           |                            邻接表                            |
	| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: |
	| 无向图 | 点数组删去该点，边数组相关值都设置为0；时间复杂度为$O(|V|)$  |  结点数组删除，相关边链表也删除；时间复杂度为$O(1)-O(|E|)$   |
	| 有向图 | 点数组删去该点，边数组相关值都设置为0；时间复杂度为$O(1)-O(|E|)$ | 结点数组删除，对于出边时间复杂度为$O(1)-O(|E|)$，对于入边时间复杂度为$O(|E|)$ |

5. AddEdge(G, x, y)：加(x, y)或<x, y>

	|        |                邻接矩阵                 |                      邻接表                      |
	| :----: | :-------------------------------------: | :----------------------------------------------: |
	| 无向图 | G[x]\[y]=1&G[y]\[x]=1；时间复杂度为O(1) | 相关结点都加一个边界点(头插)；时间复杂度为$O(1)$ |
	| 有向图 |      G[x]\[y]=1；时间复杂度为O(1)       | 相关结点都加一个边界点(头插)；时间复杂度为$O(1)$ |

6. FirstNeighbor(G, x)：第一个邻居

	|        |                    邻接矩阵                    |               邻接表               |
	| :----: | :--------------------------------------------: | :--------------------------------: |
	| 无向图 | 行或列第一个为1的值；时间复杂度为$O(1)-O(|V|)$ | 边结点第一个值；时间复杂度为$O(1)$ |
	| 有向图 | 行或列第一个为1的值；时间复杂度为$O(1)-O(|V|)$ | 边结点第一个值；时间复杂度为$O(1)$ |

7. NextNeighbor(G, x, y)：y为x邻接点，找到其下一个邻接

	|        |                    邻接矩阵                    |                  邻接表                   |
	| :----: | :--------------------------------------------: | :---------------------------------------: |
	| 无向图 | 行或列下一个为1的值；时间复杂度为$O(1)-O(|V|)$ | 边结点下一个值；时间复杂度为$O(1)-O(|E|)$ |
	| 有向图 | 行或列下一个为1的值；时间复杂度为$O(1)-O(|V|)$ | 边结点下一个值；时间复杂度为$O(1)-O(|E|)$ |

8. Get_edge_value(G, x, y); Set_edge_value(G, x, y);

	与查找类似

9. 遍历

## 图的遍历

### 广度优先遍历BFS

与树的广度优先遍历(层序遍历)类似

```c
int visited[MAX_VERTEX_NUM];		// 访问标记数据

void BFSTraverse(Graph G){
    // 初始化标记数组
    for(int i=0; i<G.vexnum; ++i)
        visited[i] = 0;
    // 初始化辅助队列
    InitQueue(&Q);
    // 从0号顶点开始遍历
    for(int i=0; i<G.vexnum; i++)
        if(!visited[i])
            BFS(G, i)
}

void BFS(Graph G, int v){			// 从v出发广度遍历
    visit(v);
    visited(v) = 1;
    EnQueue(&Q, v);
    while(!IsEmpty(Q)){
        for(int w=FirstNeighbor(G, v); w>=0; w=NextNeighbor(G, v, w)){  //检查v的所有邻接点
            if(!visited[w]){
                visit(w);
                visited(w)=1;
                DeQueue(&Q, w);
            }
        }
    }
}
```

图的存储结构不同，遍历结果就有可能不同

空间复杂度：最坏$O(|V|)$，所有节点都入队

时间复杂度：邻接矩阵$O(|V|^2)$；邻接表$O(|V|+|E|)$

> 对于无向图，调用BFS函数次数等于连通分量数

#### 广度优先生成树/广度优先生成森林

根据遍历顺序得到一颗遍历树，故连通图生成树，非连通图生成森林

![image-20220831183231374](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220831183231374.png)

### 深度优先搜索DFS

与树的先序遍历类似

```c
int visited[MAX_VERTEX_NUM];		// 访问标记数据

void DFSTraverse(Graph G){
    for(int i=0; i<G.vexnum; i++)
        visited[i]=0;
    for(int i=0; i<G.vexnum; i++)
        if(!visited[i])
            DFS(G, i);
}

void DFS(Graph G, int i){
    visit(i);
    visited(i) = 1;
    for(int w=FirstNeighbor(G, i); w>=0; w=NextNeighbor(G, i, w)){
        if(!visited[w])
            DFS(G, w);
    }
}
```

空间复杂度：最坏$O(|V|)$，最好$O(1)$

#### 判断一个无向图是否是一个树

无向图是否是一个树等价于无向图是否是有n个节点，n-1个边的连通图

故使用深度遍历DFS统计顶点数与边个数，若一次遍历就有上述子图，则为一棵树

```c
int IsTree(Graph G){
	for(int i=0; i<G.vexnum; i++)
        visited[i]=0;
    int vexnum=0, edgenum=0;
    DFS(G, 0, &vexnum, &edgenum);
    if(vexnum == G.vexnum && edgenum == 2(G.vexnum-1))
        return 1;
    else
        return 0;
}
void DFS(Graph G, int i, int *vexnum, int *edgenum){
    visited[i]=1;
    (*vexnum)+=1;
    for(int j=FirstNeighbor(G, i); j>=0; j=NextNeighbor(G, i, j)){
        (*edgenum)+=1;
        DFS(G, j, vexnum, edgenum);
    }
}
```

#### 深度遍历的非递归算法

需要有栈参与；

```c
void DFSNotReverse(Graph, int i){
    // 初始化访问数组
    for(int i=0; i<G.vexnum; i++)
        visited[i]=0;
    InitStack(&S);
    visited(i) = 1;
    Push(&S, i);
    while(!IsEmpty(S)){
        int j;
        Pop(&S, &j);
        visit(j);
        for(int k=FirstNeighbor(G, j); k>=0; k=NextNeighbor(G, j, k)){
            if(!visited[k]){
                visited[k]=1;
                Push(&S, k);
            }
        }
    }
}
```

#### 基于BFS(广度)和DFS(深度)算法以邻接表方式存储的有向图中是否存在$<v_i, v_j>$的路径

1. BFS(广度)

	```c
	int BFSFindPath(Graph G, int i, int j){
	    // 初始化访问数组
	    for(int i=0; i<G.vexnum; i++)
	        visited[i]=0;
	    InitQueue(&Q);
	    visited[i] = 1;
	    Push(&Q, i);
	    while(!IsEmpty(Q)){
	        int k;
	        Pop(&Q, &k);
	        if(k == j) return 1;
	        for(int t = FirstNeighbor(G, i); t>=0; t = NextNeighbor(G, k, t)){
	            if(t == j)
	                return 1;
	            if(!visited[t]){
	                visited[t]=1;
	                Push(&Q, t);
	            }
	        }
	    }
	    return 0;
	}
	```

2. DFS(深度)

	```c
	int DFSFindPath(Graph G, int i, int j){
	    // 初始化访问数组
	    for(int i=0; i<G.vexnum; i++)
	        visited[i]=0;
	    return DFS(G, i, j, *can_reach)
	}
	int DFS(Graph G, int i, int j, int *can_reach){
	    if(i == j){
	        (*can_reach) = 1;
	        return 1;
	    }
	    visited[i]=1;
	    for(int k = FirstNeighbor(G, i); k>=0; k = NextNeighbor(G, i, k)){
	    	if(!visited[k] && !(*can_reach))
	            DFS(G, k, j, can_reach)
	    }
	}
	```

	
