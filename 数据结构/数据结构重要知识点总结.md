# 一些重点算法

## 串的模式匹配算法

1. 暴力求解法

  ```c
  // O(mn)
  int Index_Traverse(SString S, SString T){
      int i = 1, n = StrLength(S), m = StrLength(T);
      SString sub;
      while (i <= n-m+1)
      {
          SubString(&sub, S, i, m);
          if (StrCompare(sub, T) != 0)
          {
              i++;
          }
          else{
              return i;
          }
      }
      return 0;
  }
  ```

2. 跳跃求解法

  ```c
  // 最好O(m)，最差O(mn)
  // 跳跃着实现，因为子串比较实际上只需要主串i动即可
  int Index_Jump(SString S, SString T){
      int i=1, j=1;
      while (i<=S.length && j<=T.length)
      {
          if (S.ch[i] == T.ch[i])
          {
              ++i, ++j;
          }
          else
          {
              i = i-j+2;          //跳到下一个子串的第一个位置
              j=1;
          }
      }
      if (j > T.length)
      {
          return i-T.length;
      }
      else
      {
          return 0;
      }
  }
  ```

3. KMP算法

  <iframe height=498 width=510 src="//player.bilibili.com/player.html?aid=714697013&bvid=BV16X4y137qw&cid=311669862&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

  分两步，一步求解next数组(若匹配失败j要回溯到的位置)，第二步模式匹配

  > 求Next数组方法
  >
  > 设主串为$S_1S_2……S_n$，模式串为$P_1P_2……P_m$，设不匹配时应为第k个($k<j$)字符开始比较
  > $$
  > \begin{aligned}
  > & \because S_i \ne P_j \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} \dots S_{i-1} \qquad k \lt j \\
  > & 又\because P_1 \dots P_{j-1} = S_{i-j+1} \dots S_{i-1} \\
  > & \therefore P_{j-k+1} \dots P_{j-1} = S_{i-k+1} \dots S_{i-1} \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1} \\
  > & \therefore k就是P头一个k-1字符与P尾k-1个字符相等的最大值 \\
  > & \therefore next[j] = 
  > \begin{cases}
  > 0 & j=1 \\
  > max\{k | 1 \lt k \lt j 且 P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1}\} \\
  > 1 & 其他情况
  > \end{cases}
  > \end{aligned}
  > $$
  > 例如
  >
  > | 序列       |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
  > | ---------- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
  > | 模式串元素 |  a   |  b   |  a   |  a   |  b   |  c   |  a   |  c   |
  > | next数组   |  0   |  1   |  1   |  2   |  2   |  3   |  1   |  2   |
  >
  > next[1]，next[2]一定分别为0 1；next[j]=第j位字符组成的子串的前后缀重合字符数
  >
  > 故求解过程如下：
  >
  > 设i=1，j=0
  >
  > - 第一次循环：i=1, j=0, j==0，故next[++i]=++j，即next[2]=1, i=2, j=1;
  > - 第二次循环：i=2, j=1, ch[2]==ch[1]不成立，故j=next[j], j=0;
  > - 第三次循环：i=2, j=0, j==0, 故next[++i]=++j，即next[3]=1, i=3, j=1;
  > - 第四次循环：i=3, j=1, ch[3]==ch[1]成立，故next[++i]=++j，即next[4]=2, i=4, j=2;
  > - 第五次循环：i=4, j=2, ch[4]==ch[2]不成立，故j=next[j], j=1;
  > - 第六次循环：i=4, j=1, ch[4]==ch[1]成立，故next[++i]=++j，即next[5]=2, i=5, j=2;
  > - 第七次循环：i=5, j=2, ch[5]==ch[2]成立，故next[++i]=++j，即next[6]=3, i=6, j=3;
  > - 第八次循环：i=6, j=3, ch[6]==ch[3]不成立，故j=next[j], j=1;
  > - 第九次循环：i=6, j=1, ch[6]==ch[1]不成立，故j=next[j], j=0;
  > - 第十次循环：i=6, j=0, j==0, 故next[++i]=++j，即next[7]=1, i=7, j=1;
  > - 第十一次循环：i=7, j=1, ch[7]==ch[1]成立，故next[++i]=++j，即next[8]=2, i=8, j=2; 此时i与length相等跳出循环
  >
  > 在不匹配位置前面，划开一条分界线，模式串一步一步往后退，直到分界线前能对上，或模式串完全跨过分解线位置
  >
  > ![image-20220808191752236](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220808191752236.png)
  >
  > 对于模式串ababaa
  >
  > 设i=1，j=0
  >
  > - 第一次循环：i=1, j=0, j==0，故next[++i]=++j，即next[2]=1, i=2, j=1;
  > - 第二次循环：i=2, j=1, ch[2]==ch[1]不成立，故j=next[j], j=0;
  > - 第三次循环：i=2, j=0, j==0, 故next[++i]=++j，即next[3]=1, i=3, j=1;
  > - 第四次循环：i=3, j=1, ch[3]==ch[1]成立，故next[++i]=++j，即next[4]=2, i=4, j=2;
  > - 第五次循环：i=4, j=2, ch[4]==ch[2]成立，故next[++i]=++j，即next[5]=3, i=5, j=3;
  > - 第六次循环：i=5, j=3, ch[5]==ch[3]成立，故next[++i]=++j，即next[6]=4, i=6, j=4;
  > - 第七次循环：i=5, j=2, ch[5]==ch[2]成立，故next[++i]=++j，即next[6]=3, i=6, j=3; 此时i与length相等跳出循环
  >
  > 对于模式串aaaab
  >
  > 设i=1，j=0
  >
  > - 第一次循环：i=1, j=0, j==0，故next[++i]=++j，即next[2]=1, i=2, j=1;
  > - 第二次循环：i=2, j=1, ch[2]==ch[1]成立，故next[++i]=++j，即next[3]=2, i=3, j=2;
  > - 第三次循环：i=3, j=2, ch[3]==ch[2]成立，故next[++i]=++j，即next[4]=3, i=4, j=3;
  > - 第四次循环：i=4, j=3, ch[4]==ch[3]成立，故next[++i]=++j，即next[5]=4, i=5, j=4; 此时i与length相等跳出循环
  >
  > ![image-20220810182338505](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220810182338505.png)

```c
int Index_KMP(SString S, SString T, int next[]){
    int i=1, j=1;
    while (i <= S.length && j<=T.length){
        if (j == 0 || S.ch[i] == T.ch[j]){
            ++i;
            ++j;
        } else{
            j = next[j];
        }
    }
    if (j > T.length)
        return i-T.length;
    else
        return 0;
}

int GetNext(SString T, int next[]){
    next[1] = 0;
    int i=1,j=0;
    while (i < T.length){
        if (j==0 || T.ch[i]==T.ch[j]) next[++i] = ++j;
        else j=next[j];
    }
}
```

KMP算法继续改进版，由于KMP在一些情况下还可以继续优化，如模式串aaaab和主串aaabaaaab在匹配时当i=j=4时失配，且next数组还需要让b和前三个a进行匹配，这显然毫无意义，出现这种情况的原因如下：

- 当$p_i!=s_j$时，下次匹配必然是$p_{next[i]}$跟$s_j$比较，如果$p_i==p_{next[i]}$，则导致必然继续失配

解决方法如下：

- 若出现这种情况则需要再次递归，将$next[i]$修正为$next[next[i]]$，直至两者不相等为止，更新后的数组命名为nextval，计算nextval的算法如下：

	```c
	void GetNextVal(Str str, int nextval[]){
	    int i=1, j=0;
	    nextval[1]=0;
	    while(i<str.length)
	    {
	        if(j==0 || str.ch[i]==str.ch[j])
	        {
	            ++i;++j;
	            if(str.ch[i]!=str.ch[j])
	                nextval[i] = j;
	            else
	                nextval[i] = nextval[j];
	        }
	        else
	            j = nextval[j];
	    }
	}
	```

**手算方法：先算next数组，之后比较$p_i$和$p_{next[i]}$，若两者不等则$nextval[i]=next[i]$，若两者相等则$nextval[i]=nextval[next[i]]$**

需要注意，KMP计算的是模式串的next数组，变动的是模式串的j

## 数组、矩阵与广义表

![image-20220929162357423](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220929162357423.png)

1. ```c
	void move(int A[], int n)
	{
	    int flag = -1, i, temp;
	    for(i=0; i<n; i++)
	    {
	        if(A[i] != 0)
	            flag++;
	        if(flag != i)
	        {
	            temp = A[flag];
	            A[flag] = A[i];
	            A[i] = temp;
	        }
	    }
	}
	```

2. ```c
	float getMax(float A[], int k, int n)
	{
	    float Max;
	    if (k==n)
	        return A[k];
	    else
	    {
	        Max = getMax(A, k+1, n);
	        return A[k]>Max?A[k]:Max;
	    }
	}
	
	getMax(A, 0, n-1);
	```

	```c
	float getSum(float A[], int k, int n)
	{
	    if (k == n)
	        return A[k];
	    else
	        return A[k]+getSum(A, k+1, n);
	}
	
	getSum(A, 0, n-1);
	```

	```c
	float getAvg(float A[], int k, int n)
	{
	    if (k == n)
	        return A[k];
	    else
	        return (A[k] + (n-k)getAvg(A, k+1, n))/(n-k+1);
	}
	
	getAvg(A, 0, n-1);
	```

3. ```c
	void divide(int A[], int n)
	{
	    int low = 0, high = n-1;
	    while(low < high)
	    {
	        while(low<high && A[low]%2==1) low++;
	        while(low<high && A[low]%2==0) high--;
	        if(low < high)
	        {
	            int temp = A[low];
	            A[low] = A[high];
	            A[high] = temp;
	            low++;
	            high--;
	        }
	    }
	}
	```

4. ```c
	void divide(int A[], int n)
	{
	    int low=0, high=n-1, pivot=A[n-1];
	    while(low<high)
	    {
	        while(low<high && A[low]<=pivot) low++;
	        A[low] = A[high];
	        while(low<high && A[high] > pivot) high--;
	        A[high] = A[low];
	    }
	    A[low] = pivot;
	}
	```

5. ```c
	int printMin(int A[][MaxSize], int m, int n)
	{
	    int i, j, k, min, minj;
	    int flag;
	    for(i=0; i<m; i++)
	    {
			min = A[i][0];
	        minj = 0;
	        for(j=1; j<n; j++)
	        {
	            if(A[i][j] < min)
	            {
	                min = A[i][j];
	                minj = j;
	            }
	            flag = 1;
	        }
	    }
	    for(k=0; k<m ; k++)
	    {
			if(min > A[k][minj])
	        {
	            flag = 0;
	            break;
	        }
	    }
	    if(flag == 1)
	        printf("%d", min);
	}
	
	int printMax(int A[][MaxSize], int m, int n)
	{
	    int i, j, k, max, maxj;
	    int flag;
	    for(i=0; i<m; i++)
	    {
			max = A[i][0];
	        maxj = 0;
	        for(j=1; j<n; j++)
	        {
	            if(A[i][j] > max)
	            {
	                max = A[i][j];
	                maxj = j;
	            }
	            flag = 1;
	        }
	    }
	    for(k=0; k<m ; k++)
	    {
			if(max < A[k][maxj])
	        {
	            flag = 0;
	            break;
	        }
	    }
	    if(flag == 1)
	        printf("%d", max);
	}
	```

6. ```c
	void create(int A[][MaxSize], int m, int n, int B[][3])
	{
	    int i, j, k=1;
	    for(i=0; i<m; i++)
	    {
	        for(j=0; j<n ;j++)
	        {
				if(A[i][j] != 0)
	            {
	                B[k][0] = A[i][j];
	                B[k][1] = i;
	                B[k][2] = j;
	                k++;
	            }
	        }
	    }
	    B[0][0] = k-1;
	    B[0][1] = m;
	    B[0][2] = n;
	}
	
	int isIn(int B[][3], int x)
	{
	    int i;
	    for(i=1; i<=B[0][0]; i++)
	    {
	        if(B[i][0] == x)
	            return 1;
	    }
	    return 0;
	}
	```

7. ```c
	void Transpose(int A[][3], int B[][3])
	{
		B[0][0] = A[0][0];
	    B[0][1] = A[0][2];
	    B[0][2] = A[0][1];
	    int i, j, col;
	    if(B[0][0] > 0)
	    {
	        i = 1;
	        for(col = 0; col < B[0][1]; ++col)
	        {
	            for(j = 1; j<=B[0][0]; ++p)
	            {
	            	if(A[j][2] == col)
	                {
	                    B[i][0] = A[j][0];
	                    B[i][1] = A[j][2];
	                    B[i][2] = A[j][1];
	                    i++;
	                }
	            }
	        }
	    }
	}
	```

8. ```c
	void add(int A[][3], int B[][3], int C[][3])
	{
	    int i=1, j=1, k=1, temp;
	    while(i<=A[0][0] && j<=B[0][0])
	    {
	        if(A[i][1] == B[i][1])
	        {
	            if(A[i][2] < B[j][2])
	            {
	                C[k][0] = A[i][0];
	                C[k][1] = A[i][1];
	                C[k][2] = A[i][2];
	                k++;
	                i++;
	            }
	            else if(A[i][2] == B[j][2])
	            {
	                temp = A[i][0] + B[j][0];
	                if(temp != 0)
	                {
	                    C[k][0] = temp;
	                	C[k][1] = A[i][1];
	                	C[k][2] = A[i][2];
	                	k++;
	                }
	                i++;
	                j++;
	            }
	            else
	            {
	                C[k][0] = B[j][0];
	                C[k][1] = B[j][1];
	                C[k][2] = B[j][2];
	                k++;
	                j++;
	            }
	        }
	        else if (A[i][1] < B[i][1])
	        {
	            C[k][0] = A[i][0];
	            C[k][1] = A[i][1];
	            C[k][2] = A[i][2];
	            k++;
	            i++;
	        }
	        else
	        {
	            C[k][0] = B[j][0];
	            C[k][1] = B[j][1];
	            C[k][2] = B[j][2];
	            k++;
	            j++;
	        }
	    }
	}
	```

9. ```c
	int getValue(int A[][3], int i, int j)
	{
	    int k=1;
	    while(k<=A[0][0] && A[k][1] == i && A[k][2] == j)
	        k++;
	    if(k<=A[0][0])
	        return A[k][0];
	    else
	        return 0;
	}
	
	int mul(int A[][3], int B[][3], int C[][3], int m, int n, int k)
	{
		int i, j, l, p=1, s;
	    for(i=0; i<m; i++)
	    {
	        for(j=0; j<k; j++)
	        {
	            s=0;
	            for(l=0; l<n; l++)
	                s += getValue(A, i, l)*getValue(A, l, j);
	            if(s!=0)
	            {
	                C[p][0] = s;
	                C[p][1] = i;
	                C[p][2] = j;
	                p++;
	            }
	        }
	    }
	    C[0][0] = p-1;
		C[0][1] = m;
		C[0][2] = k;
	}
	```

## 并查集

可以将并查集看作树的双亲结点表示法，即通过树中的一个结点，可以快速找到其双亲结点，进而找到根节点。

这种特性有两个好处

- 可以快速地将两个含有很多元素的集合并为一个

	将两个集合看作集合中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何结点的孩子结点即可

- 可以方便地判断两个元素是否属于同一个集合

	通过两个元素所在的结点找到它们的根结点，如果有相同的根，则说明它们属于同一个集合，否则属于不同集合

并查集可以用一维数组来表示，如图即为并查集在数组中的表示和合并过程

![image-20220929183636089](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220929183636089.png)

## 二叉树的非递归遍历算法

### 先序遍历

使用栈即可实现，主要思想是先将根结点压入栈，然后结点出栈并访问结点，然后依次将结点的右孩子、左孩子压入栈，直到栈为空为止

```c
void PreOrderIter(BiTree T)
{    
    if (T==NULL) return;
    Stack S;
    InitStack(&S);
    BiNode *t;
    Push(&S, T);
    while(!IsEmpty(S))
    {
        Pop(&S, t);
        visit(t);
        if(t->rchild != NULL)
            Push(&S, t->rchild);
        if(t->lchild != NULL)
            Push(&S, t->lchild);
    }
}
```

另一种使用栈的方法，当左子树遍历完后，需要回溯并访问右子树，每次Pop出结点时都是回溯到父节点的过程，即左子树已空，可以访问右子树了

```c
void PreOrderIter(BiTree T)
{
    if (T == NULL) return;
    Stack S;
    InitStack(&S);
    BiNode *t = T;
    while(t != NULL || !IsEmpty(S))
    {
        if(t != NULL)
        {
            visit(t);
            Push(&S, t);
            t = t-> lchild;
        }
        else
        {
            Pop(&S, t);
            t = t->rchild;
        }
    }
}
```

### 中序遍历

也使用栈实现，与先序遍历算法2类似，但算法访问结点时机不同

```c
void InOrderIter(BiTree T){
    if (T == NULL) return;
    Stack S;
    InitStack(&S);
    BiNode *t == T;
    while(t != NULL || !IsEmpty(S))
    {
        if(t != NULL)
        {
            Push(&S, t);
            t = t->lchild;
        }
        else
        {
            Pop(&S, t);
            visit(t);
            t = t->rchild;
        }
    }
}
```

### 后序遍历

可以使用两个栈实现后序遍历非递归算法，可以将后序算法看作是先访问根节点，再访问右孩子之后访问左孩子的逆过程，算法步骤如下：

1. Push结点到第一个栈s中
2. 从第一个栈s中Pop出一个结点，并将其Push到第二个栈Output中
3. 然后依次Push结点的左、右孩子到第一个栈s中
4. 重复2、3步直到栈s为空
5. 完成后，所有结点都在output栈里，而且按后序遍历的顺序存放，直接全部Pop出来就是二叉树后序遍历结果

```c
void PostOrderIter(BiTree T){
    Stack S, Output;
    InitStack(&S);
    InitStack(&Output);
    
    BiNode *t;
    Push(&S, T);
    while(!IsEmpty(S))
    {
        Pop(&S, t);
        Push(&Output, t);
        if(t->lchild != NULL)
            Push(&S, t->lchild);
        if(t->rchild != NULL)
            Push(&S, t->rchild);
    }
    
    while(!IsEmpty(Output))
    {
        Pop(&Output, t);
        visit(t);
    }
}
```

> 不是说先访问右节点再访问左结点吗，为什么在栈S中先压左再压右？
>
> - 因为先访问右节点再访问左结点说的是Output，所以相应的在栈S中先压左再压右

## 判断一个查找序列是否是二叉排序树的查找序列

例如，给定一个值60，在二叉排序树上寻找关键字值为60的结点时，访问的关键字值序列S={20，30，90，80，40，50，70，60}。若将S分为两个子序列，S1所包含的都是小于或等于60的数据，S1={20，30，40，50，60}；S2所包含的都是大于60的数据，S2={90，80，70}。如此可得判断是否是查找序列的原则:如果从S所生成的S1单调递增，S2单调递减，且除待查元素外，S1中的每个数据都小于给定值，S2中的每个数据都大于给定值，则S是一个查找序列，否则不是查找序列。算法描述如下:

```c
typedef struct 
{
    int elem[MaxSize];
    int len
}Sequence;

void reduce(Sequence *S, Sequence *S1, Sequence *S2)
{
    int i=0, j=0, k=0;
    while(i < S.len-1)
    {
        while(i < S.len-1 && S.elem[i] < S.elem[i+1])
            S1.elem[j++] = S.elem[i++];
        while(i < S.len-1 && S.elem[i] > S.elem[i+1])
            S2.elem[k++] = S.elem[i++];
    }
    S1.len = j;
    S2.len = k;
}

int judge(Sequence *S1, Sequence *S2, int x)
{
    int i=0, flag=1;
    while(i < S1.len-1 && flag)
    {
        if(S1[i] > S1[i+1] || S1[i] > x)
            flag = 0;
        else
            i++;
    }
    i = 0;
    while(i < S1.len-1 && flag)
    {
        if(S1[i] < S1[i+1] || S1[i] < x)
            flag = 0;
        else
            i++;
    }
    return flag;
}

int issearch(Sequence *S, Sequence *S1, Sequence *S2, int x)
{
    reduce(S, S1, S2);
    return judge(S1, S2, x);
}
```

## 对于有父节点指针的链式树构建中序二叉线索树

二叉树存储结构如下

```c
typedef struct node
{
    int data;
    struct node *lchild, rchild;
    struct node *parent;
}BinTNode, *BinTree;
```

设二叉树根结点为root，当前结点为px

查找中序序列后继的情况

- 若当前结点有右孩子，则后继为右子树最左侧结点
- 若当前结点无右孩子
	- px为其父节点的左孩子，则后继为其父节点
	- px为其父节点的右孩子，则后继为其父节点第一个非左子树的结点

```c
BinTNode *lastleft(BinTree root)
{
    while(root->lchlid != NULL)
        root = root->lchild;
    return root;
}
BinTNode *InOrderPost(BinTree root, BinTree px)
{
    if(px->rchild != NULL)
        return lastleft(px->rchild);
    else
    {
		if(px = px->parent->lchild)
            return px->parent;
        else
        {
            BinTNode *parent = px->parent;
            while(parent != NULL && px !=parent->lchild)
            {
                px = parent;
                parent = px->parent;
            }
            return parent;
        }
    }
}
```

查找中序序列前驱的情况

- 若px有左子树，则前驱为其左子树最右侧节点
- 若px无左子树
	- 若px为其父节点的右孩子，则前驱为其父节点
	- 若px为其父节点的左孩子，则前驱为其父节点第一个非右孩子的父节点

```c
BinTNode *lastright(BinTree root)
{
	while(root->rchild !=NULL)
        root = root->rchild;
    return root;
}
BinTNode *InOrderPre(BinTree root, BinTree px)
{
	if(px->lchild != NULL)
        return lastright(px->lchild);
    else
    {
		if(px = px->parent->rchild)
            return px->parent;
        else
        {
            BinTNode *parent = px->parent;
            while(parent != NULL && px !=parent->rchild)
            {
                px = parent;
                parent = px->parent;
            }
            return parent;
        }
    }
}
```



# ==栈和队列==

见栈和队列.xmind

## 表达式求值

### 基本概念

- 中缀表达式：操作符以中缀形式位于运算数中间（如：3+2），是我们日常通用的算术和逻辑公式表示方法
- 后缀表达式：又称逆波兰式（Reverse Polish Notation - RPN），操作符以后缀形式位于两个运算数后（如：3+2的后缀表达形式就是3 2 +）
- 前缀表达式：又称波兰式（Polish Notation），操作符以前缀形式位于两个运算数前（如：3+2的前缀表达形式就是+ 3 2）

中缀表达式往往需要使用括号将操作符和对应的操作数括起来，用于指示运算的次序

e.g：5*(2+1) 虽然 * 的优先级高于 +  ，但括号的存在表示应优先执行括号内的 + 运算。

中缀表达式适合于人类的思维结构和运算习惯，但并不适用于计算机

尤其是包含括号的中缀表达式，对计算机而言是非常复杂的结构。

适用于计算机的后缀表达式

与中缀表达式不同，后缀表达式不需要使用括号来标识操作符的优先级。

后缀表达式的计算按 操作符 从左到右出现的顺序依次执行(不考虑运算符之间的优先级)，对于计算机而言是比较简单的结构。

### 中缀表达式转后缀表达式

从左至右依次遍历中缀表达式各个字符（需要准备一个字符栈存储操作符和括号）

- 字符为 运算数：直接送入后缀表达式（注：需要先分析出完整的运算数）

- 字符为 左括号 ：直接入栈（注：左括号入栈后优先级降至最低）

- 字符为 右括号 ：直接出栈，并将出栈字符依次送入后缀表达式，直到栈顶字符为左括号（左括号也要出栈，但不送入后缀表达式）。

	总结：只要满足 栈顶为左括号 即可进行最后一次出栈

- 字符为 操作符 ：若栈空，直接入栈。**若栈非空，判断栈顶操作符，若栈顶操作符优先级低于该操作符，该操作符入栈；否则一直出栈，并将出栈字符依次送入后缀表达式，直到栈空或栈顶操作符优先级低于该操作符，该操作符再入栈**

	总结：只要满足 栈空 或者 优先级高于栈顶操作符 即可停止出栈，并将该操作符入栈

- 重复以上步骤直至遍历完成中缀表达式，接着判断字符栈是否为空，非空则直接出栈，并将出栈字符依次送入后缀表达式。

注：中缀表达式遍历完成，栈中可能还有字符未输出，故需要判断栈空。

### 后缀表达式的计算

从左至右依次遍历后缀表达式各个字符（需要准备一个运算数栈存储运算数和操作结果）

- 字符为 运算数 ：直接入栈（注：需要先分析出完整的运算数并将其转换为对应的数据类型）

- 字符为 操作符 ：连续出栈两次，使用出栈的两个数据进行相应计算，并将计算结果入栈

	e.g：第一个出栈的运算数为 a ，第二个出栈的运算数为 b ，此时的操作符为 - ，则计算 b-a  （注：a和b顺序不能反），并将结果入栈。

- 重复以上步骤直至遍历完成后缀表达式，最后栈中的数据就是中缀表达式的计算结果。


### 算法实现

```c
#include<stdio.h>
#include<stdlib.h>
#include<malloc.h>
#include<string.h>
#include<ctype.h>
 
#define ERROR 0
#define OK 1
#define STACK_INT_SIZE 10  /*存储空间初始分配量*/
#define STACKINCREMENT 5  /*存储空间分配增量*/
#define M 50
 
typedef char ElemType; /*定义字符数据类型*/
typedef double ElemType2;  /*定义运算数数据类型*/
 
/*字符栈*/
typedef struct{
    ElemType *base;
    ElemType *top;
    int stacksize; 
}SqStack;
 
/*运算数栈*/
typedef struct{
    ElemType2 *base;
    ElemType2 *top;
    int stacksize;
}NStack;
 
int InitStack(SqStack *S);   /*构造空栈*/
int push(SqStack *S,ElemType e); /*入栈*/
int Pop(SqStack *S,ElemType *e);  /*出栈*/
int StackEmpty(SqStack *s);  /*栈空判断*/
void in2post(ElemType *str,ElemType *p);  /*中缀表达式转后缀表达式*/
double cal_post(char *str);  /*计算后缀表达式*/
 
/*字符栈初始化*/
int InitStack(SqStack *S){
    S->base=(ElemType *)malloc(STACK_INT_SIZE * sizeof(ElemType));
    if(!S->base)
        return ERROR;  //分配失败
    S->top = S->base;
    S->stacksize = STACK_INT_SIZE;
    return OK;
}/*InitStack*/
 
/*运算数栈初始化*/
int InitStack_N(NStack *S){
    S->base=(ElemType2 *)malloc(STACK_INT_SIZE * sizeof(ElemType2));
    if(!S->base)
        return ERROR;
    S->top = S->base;
    S->stacksize = STACK_INT_SIZE;
    return OK;
}
 
/*字符栈入栈*/
int Push(SqStack *S,ElemType e){
    //判断栈满
    if(S->top - S->base >= S->stacksize){
        S->base = (ElemType *)realloc(S->base,(S->stacksize + STACKINCREMENT)*sizeof(ElemType));
        if(NULL == S->base)  //分配失败
            return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize = S->stacksize+STACKINCREMENT;
    }
    *S->top = e;
    S->top++;
    return OK;
}
 
/*运算数栈入栈*/
int Push_N(NStack *S,ElemType2 e){
    if(S->top - S->base >= S->stacksize){
        S->base = (ElemType2 *)realloc(S->base,(S->stacksize + STACKINCREMENT)*sizeof(ElemType2));
        if(NULL == S->base)
            return ERROR;
        S->top = S->base + S->stacksize;
        S->stacksize = S->stacksize+STACKINCREMENT;
    }
    *S->top = e;
    S->top++;
    return OK;
}
 
/*字符栈出栈*/
int Pop(SqStack *S,ElemType *e){
    //判断栈空
    if(S->top == S->base)
        return ERROR;
    S->top--;
    *e=*S->top;
    return OK;
}/*Pop*/
 
/*运算数栈出栈*/
int Pop_N(NStack *S,ElemType2 *e){
    if(S->top == S->base)
        return ERROR;
    S->top--;
    *e=*S->top;
    return OK;
}
 
/*判断栈空*/
int StackEmpty(SqStack *s){
    if(s->top == s->base)
        return OK;
    return ERROR;
}/*StackEmpty*/
 
//str为待转换的中缀表达式字符串,p为转换后的后缀表达式字符串
void in2post(ElemType *str,ElemType *p){   /*infix to postfix*/
    SqStack s;   
    InitStack(&s);   //初始化一个空字符栈
    ElemType e;
    int i;
    int j=0;
    for(i=0 ; i<strlen(str) ; i++)  //遍历中缀表达式
    {
        //遇到数字和小数点直接输出
        //使用循环完整接收一个运算数
        while(isdigit(str[i]) || '.'==str[i])
        {
            p[j++]=str[i++];
            if(!isdigit(str[i]) && '.'!=str[i])
                p[j++]=' ';   //一个数字完整输出后使用空格与其它运算符或数字分隔开
        }
 
        //遇到左括号直接入栈
        if('('==str[i])
            Push(&s,str[i]);
 
        //遇到右括号直接出栈，直到栈顶为左括号
        if(')'==str[i])
        {
            while('(' != *(s.top-1))
            {
                Pop(&s,&e);
                p[j++]=e;
                p[j++]=' ';
            }
            Pop(&s,&e);  //左括号出栈但不输出
        }
 
        //遇到+或—
        //1.栈空/栈顶为左括号:直接入栈
        //2.否则一直出栈,直到栈空/栈顶为左括号,再入栈
        if('+'==str[i] || '-'==str[i])
        {
            while(!StackEmpty(&s) && '('!=*(s.top-1))
            {
                Pop(&s,&e);
                p[j++]=e;
                p[j++]=' ';
            }
            Push(&s,str[i]);
        }
 
        //遇到*或/
        //1.栈空/栈顶为左括号/栈顶操作符为+ or -:直接入栈
        //2.否则一直出栈,直到满足1,再入栈
        if('*'==str[i] || '/'==str[i] || '%'==str[i])
        {
            while(!StackEmpty(&s) && '('!=*(s.top-1) && '+'!=*(s.top-1) && '-'!=*(s.top-1))
            {
                Pop(&s,&e);
                p[j++]=e;
                p[j++]=' ';
            }
            Push(&s,str[i]);
        }
    }
    //中缀表达式遍历完成,还需检查栈中是否有未输出字符
    //判断栈空,非空则直接出栈并输出(左括号不用输出)
    while(!StackEmpty(&s)){
        Pop(&s,&e);
        if('('!=e)
            p[j++]=e;
            p[j++]=' ';
    }
    p[--j]='\0';
}/*infix2postfix*/
 
//str为待计算的后缀表达式,返回值为计算结果
double cal_post(char *str){   /*计算后缀表达式*/
    int i;
    ElemType2 e,a,b;
    char d[M];
    NStack n;
    InitStack_N(&n);   //初始化一个运算数栈保存运算数
    for(i=0;i<strlen(str);i++)
    {
        int j=0;
        while(isdigit(str[i]) || '.'==str[i])
        {
            d[j++]=str[i++];
            d[j]='\0';
            if(!isdigit(str[i]) && '.'!=str[i])
            {
                e=atof(d);   //使用atof()将字符串形式的运算数转换为double型数据
                Push_N(&n,e);   //运算数入栈
            }
        }
        switch(str[i])
        {
            case '+':
                Pop_N(&n,&b);
                Pop_N(&n,&a);
                Push_N(&n,a+b);
                break;
            case '-':
                Pop_N(&n,&b);
                Pop_N(&n,&a);
                Push_N(&n,a-b);
                break;
            case '*':
                Pop_N(&n,&b);
                Pop_N(&n,&a);
                Push_N(&n,a*b);
                break;
            case '/':
                Pop_N(&n,&b);
                Pop_N(&n,&a);
                Push_N(&n,a/b);
                break;
        }
    }
    Pop_N(&n,&e);
    return e;
}/*calculate_postfix*/
 
int main()
{
    char str[M];
    char post[M];
    int i;
    printf("\n输入一串中缀表达式：\n");
    gets(str);
    printf("\n对应的后缀表达式：\n");
    in2post(str,post);
    printf("%s",post);
    printf("\n\n计算后缀表达式：\n");
    printf("%f",cal_post(post));
    return 0;
}
```

# ==树与二叉树==

## 树的基本概念

### 基本术语

#### 概念

树是n ($n \ge 0$) 个结点的有限集合，$n=0$时称为空树，这是一种特殊情况。在任意一棵非空树中应满足：

1. 有且仅有一个特定的称为根的结点
2. 当$n \gt 1$时，其余结点可分为m ($m \gt 0$) 个互不相交的有限集合$T_1,T_2, \dots ,T_m$，其中每个集合本身又是一个树，并且称为根结点的子树

$\emptyset$：空树，结点数为0的树

非空树特性：

1. 树有且只有一个根结点
2. 只有根结点没有前驱，只有叶子结点没有后继
3. 除了根结点之外，其他结点有且仅有一个前驱

树是一种递归定义的树形结构，即树可以看成是根节点与若干不相交的子树的集合

![image-20220810190101560](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220810190101560.png)

#### 关系描述

祖先结点：从前驱$\to$根结点上的所有结点

子孙结点：自己下面的所有结点

双亲结点：前驱

孩子：后继

兄弟：同层，同双亲结点

堂兄弟：同层，不同双亲结点

路径：从上到下

路径长度：经过几条边

#### 结点，树的属性描述

深度(层次)：从上往下数第几层

结点高度：从下往上数第几层

树的高度：总共多少层

度：有几个分支

树的度：各结点的度的最大值

#### 有序树、无序树

有序：逻辑上看，树中各子树从左到右有次序，不能互换

无序：逻辑上看，树中各子树从左到右无次序，可以互换

#### 树、森林

树：一棵

森林：m ($m \ge 0$) 棵互不相交的树的集合

### ==性质==

1. 结点数=度数+1

2. 度为m的树和m叉树的区别

	|      |             度为m的树             |               m叉树               |
	| :--: | :-------------------------------: | :-------------------------------: |
	| 概念 |        各结点度的最大值为m        |      各结点度的最大值不超过m      |
	| 性质 | 任意结点的度$\le$m（最多m个孩子） | 任意结点的度$\le$m（最多m个孩子） |
	|      | 至少有一个结点度$=$m（有m个孩子） |     允许所有结点的度都$\lt$m      |
	|      | **一定是非空树，至少有m+1个结点** |            可以是空树             |

3. 度为m的树第i层最多有$m^{i-1}$个结点，m叉树第i层最多有$m^{i-1}$个结点

4. 高度为h的m叉树(度为m的树)至多有$m^0+m^1+ \dots +m^{h-1}=\frac{1*(1-m^h)}{1-m}=\frac{m^h-1}{m-1}$个结点

5. **高度为h的m叉树至少有h个结点，高度为h的度为m的树至少有m+h-1个结点**

6. 有n个结点的m叉树的最小高度为$h= \lceil \log_m(n(m-1)+1) \rceil$
	$$
	\begin{aligned}
	& \because \frac{m^{h-1}-1}{m-1} \lt n \le \frac{m^h-1}{m-1} \\
	& \therefore m^{h-1} \lt n(m-1)+1 \le m^h \\
	& \therefore h-1 \lt \log_m(n(m-1)+1) \le h \\
	& \therefore h= \lceil \log_m(n(m-1)+1) \rceil
	\end{aligned}
	\tag{1}
	$$

## 二叉树

### 定义及其主要特性

#### 定义

二叉树是n（$n \ge 0$）个结点的有序集合

1. 或者为空二叉树，即$n=0$
2. 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一颗二叉树

特点

1. 每个结点有且仅有两棵子树
2. 左右子树不能颠倒(**二叉树是有序树**)

五种状态

1. 空二叉树
2. 只有根结点
3. 只有左子树
4. 只有右子树
5. 左右子树都有

#### 几个特殊的二叉树

- 满二叉树

	高度为h且含有$2^h-1$个结点的二叉树；$n=1+2+ \dots +2^{h-1}=\frac{2^h-1}{2-1}=2^h-1$

	特点

	1. 只有最后一层才有叶子结点
	2. 不存在度为1的结点
	3. 按层序开始编号，i结点左孩子为2i，右孩子为2i+1，其父节点为$\lfloor i/2 \rfloor$（若存在）

- 完全二叉树

	当且仅当每个结点都与高度为h的满二叉树中编号为1-n的结点一一对应时称其为完全二叉树

	特点

	1. 只有最后两层有叶子结点
	2. **只存在一个度为1的结点**
	3. 按层序开始编号，i结点左孩子为2i，右孩子为2i+1，其父节点为$\lceil i/2 \rfloor$（若存在）
	4. $i \le \lfloor n/2 \rfloor$为分支结点，反之为叶子结点

	![image-20220812184623452](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220812184623452.png)

- 二叉排序树—搜索、排序

	左子树上的所有结点的关键字都小于根结点上的关键字

	根结点上的关键字都小于右子树上的所有结点上的关键字

	左右子树又是二叉排序树

	![image-20220812184732800](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220812184732800.png)

- 平衡二叉树—搜索效率更高

	二叉排序树的改进版，其任意结点左右子树高度差$\le$1

#### 性质

##### 普通二叉树性质

1. 设二叉树中度为0、1、2的结点个数分别为$n_0$、$n_1$、$n_2$，则
	$$
	\begin{aligned}
	& \because n_0+n_1+n_2=n_1+2*n_2+1 \\
	& \therefore n_0=n_2+1
	\end{aligned}
	\tag{1}
	$$

2. 二叉树第i层至多有$2^{i-1}$个结点，m叉树第i层至多有$m^{i-1}$个结点（$i \ge 1$）

3. 高度为h的二叉树至多有$2^h-1$个结点，此时其为满二叉树；高度为h的m叉树至多有$m^h-1$个结点

##### 完全二叉树性质

1. 有n个（$n \gt 0$）结点的完全二叉树的高度h为$\lceil \log_2(n+1) \rceil$或$\lfloor \log_2(n) \rfloor+1$
	$$
	\begin{aligned}
	& \because 2^{h-1}-1 \lt n \le 2^{h}-1 \\
	& \therefore 2^{h-1} \lt n+1 \le 2^{h} \\
	& \therefore {h-1} \lt \log_2(n+1) \le h \\
	& \therefore h=\lceil \log_2(n+1) \rceil \\
	& or \\
	& \because 2^{h-1} \le n \lt 2^{h} \\
	& \therefore {h-1} \le \log_2(n) \lt h \\
	& \therefore h=\lfloor \log_2(n) \rfloor +1 \\
	\end{aligned}
	\tag{2}
	$$

2. 对于完全二叉树，可以由结点数n推出度为0、1、2结点的个数$n_0$、$n_1$、$n_2$
	$$
	\begin{aligned}
	& \because n_0=n_2+1  且 n_1=0orn_1=1 \\
	& \therefore n_0+n_2一定为奇数 \\
	& \therefore 完全二叉树有2k个结点，则n_0=k,n_1=1,n_2=k-1 \\
	& 完全二叉树有2k+1个结点，则n_0=k+1,n_1=0,n_2=k
	\end{aligned}
	\tag{3}
	$$

### 二叉树的存储结构

#### 顺序存储

顺序存储只使用于完全二叉树和满二叉树

可以让第一个位置空缺，保持数组下标与结点编号一致

> 对于完全二叉树or满二叉树而言，第i个结点：
>
> - 左孩子: 2i
> - 右孩子: 2i+1
> - 父节点: $\lfloor i/2 \rfloor$
> - 所在层次: $\lfloor \log_2(n) \rfloor+1$or$\lceil \log_2(n+1) \rceil$
>
> 完全二叉树有n个结点，则
>
> - 是否有左孩子: $2i \le n$
> - 是否有右孩子: $2i+1 \le n$
> - 是否是叶子结点: $i \gt \lfloor n/2 \rfloor$

若存储的不是完全二叉树或满二叉树，则结点编号无法反应逻辑关系；解决方法：强行将树与完全二叉树的结点编号联系起来，但其无法使用i与n的关系求是否存在左右孩子

```c
// 顺序存储
#define MAXSIZE 100
typedef struct TreeNode
{
    int value;
    int isEmpty;
}TreeNode;

// TreeNode t[MAXSIZE];  定义长度为MaxSize的数组，从上到下从左往右依次存储完全二叉树中的各个结点

void InitTree(TreeNode t[]){
    for (int i = 0; i < MAXSIZE; i++)
    {
        t->isEmpty = 1;
    }
}
```

#### 链式存储

对于链式存储，树假如有n个结点，则总共会有2n个指针域，而被链接的结点只有n-1个，故还有n+1个指针域被空闲，这些空闲的指针域可以用来构建线索二叉树

```c
// 链式存储，找孩子方便，找父亲困难
typedef struct BiTNode
{
    int data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
// 链式存储，找父亲方便
typedef struct BiTNode
{
    int data;
    struct BiTNode *lchild, *rchild;
    struct BiTNode *parent;
}BiTNode, *BiTree;
```

## 二叉树的遍历与线索二叉树

### 二叉树的遍历

共有三种深度遍历方法与一种广度遍历方法

- 深度遍历

	- 先序遍历：根，左，右
	- 中序遍历：左，根，右
	- 后序遍历：左，右，根

- 广度遍历

	使用队列辅助实现，先放入根节点，然后从队头取出时依次放入当前结点的左右子树结点，以此循环往复直到队空

#### 前期准备工作

分别编写初始化二叉树与生成二叉树的方法；

```c
int InitBiTree(BiTree *tree){
    (*tree) = (BiTree)malloc(sizeof(BiTNode));
    if ((*tree)==NULL)
    {
        return 0;
    }
    (*tree)->data=-1;
    (*tree)->lchild=NULL;
    (*tree)->rchild=NULL;
    return 1;
}

BiTree AssignBiTree(BiTree *tree){
    int i;
    printf("请输入树结点数据\n");
    scanf("%d", &i);
    if (i == -1)
        *tree = NULL;
    else{
        InitBiTree(tree);
        (*tree)->data = i;
        AssignBiTree(&((*tree)->lchild));
        AssignBiTree(&((*tree)->rchild));
    }
}
```

#### 深度遍历

##### 先序遍历

二叉树结点为空则什么都不做，不为空则访问根节点，前序访问左子树，前序访问右子树

```c
void PreOrder(BiTree tree){
    if (tree != NULL)
    {
        printf("%d ", tree->data);
        PreOrder(tree->lchild);
        PreOrder(tree->rchild);
    }
}
```

##### 中序遍历

二叉树结点为空则什么都不做，不为空则中序访问左子树，访问根节点，中序访问右子树

```c
void InOrder(BiTree tree){
    if (tree != NULL)
    {
        InOrder(tree->lchild);
        printf("%d ", tree->data);
        InOrder(tree->rchild);
    }
}
```

##### 后序遍历

二叉树结点为空则什么都不做，不为空则后序访问左子树，后序访问右子树，访问根节点

```c
void PostOrder(BiTree tree){
    if (tree != NULL)
    {
        PostOrder(tree->lchild);
        PostOrder(tree->rchild);
        printf("%d ", tree->data);
    }
}
```

> **每个结点都要路过三次**，先序遍历在第一次路过访问，中序遍历在第二次路过访问，后序遍历在第三次路过访问

#### 求树深度

```c
// 递归方法
int BiTreeDepth(BiTree tree){
    if (tree == NULL)
    {
        return 0;
    }
    else
    {
        int l = BiTreeDepth(tree->lchild);
        int r = BiTreeDepth(tree->rchild);
        // 树深度等于左右子树深度最大值+1
        return l>r ? l+1 : r+1; 
    }
}

// 非递归方法---采用层序遍历的思想
int BiTreeDepth(BiTree tree){
    if(tree == NULL)
        return 0;
	int child=0, height=0;			// child记录该层孩子个数
    BiNode *t;						// 存储临时结点
    Queue Q;
    InitQueue(&Q);
    Push(&Q, tree);
    while(!IsEmpty(Q))
    {
		Pop(&Q, t);
        if(t->lchild != NULL)
        {
			child++;
            Push(&Q, t->lchild);
        }
        if(t->rchild != NULL)
        {
			child++;
            Push(&Q, t->rchild);
        }
        if(child == len(Q))
        {
            // 该层孩子数等于队列内元素个数表示上一层已经出完了，故child归零让height+1
            child = 0;
            height++;
        }
    }
    return height;
}
```

#### 层序遍历

1. 初始化一个辅助队列
2. 根结点入队
3. 若队列非空则队头结点出队，访问该结点，并将其左右孩子放入队列

```c
void LevelOrder(BiTree tree)
{
    LinkQueue Q;
    InitLQueue(&Q);
    BiTree p;
    EnLQueue(&Q, T);
    while (!LQueueEmpty(Q))
    {
        DeLQueue(&Q, p);
        printf("%d ", p->data);
        if (p->lchild!=NULL)
        {
            EnLQueue(&Q, p->lchild);
        }
        if (p->rchild!=NULL)
        {
            EnLQueue(&Q, p->rchild);
        }
    }
}
```

#### 由遍历序列构造二叉树

若只有二叉树的前/中/后/层序遍历结果则无法唯一确认二叉树，若有前+中/后+中/层+中则可以唯一确认一个二叉树

##### 前+中

```c
BiTree PreIn2Tree(int preorder[], int p_start, int p_end, int inorder[], int i_start, int i_end)
{
	if(p_start == p_end)
        return NULL;
    int root = preorder[p_start];			// 根的值
    int i_index;
    for(int i = i_start; i<i_end; i++)
        if(inorder[i] == root)
        {
            i_index = i;
            break;
        }
    int p_num = i_index - i_start;			// 左子树的个数
    BiTree t = (BiTree) malloc(sizeof(BiTree));
    t->data = root;
    t->lchlid = PreIn2Tree(preorder, p_start, p_start+p_num+1, inorder, i_start, i_index);
    t->rchlid = PreIn2Tree(preorder, p_start+p_num+1, p_end, inorder, i_index+1, i_end);
}
```

> 中序：EAFDHCBGI
>
> 前序：DAEFBCHGI
>
> ```mermaid
> graph TD
> D --> A
> D --> B
> A --> E
> A --> F
> B --> C
> B --> G
> C --> H[H左]
> G --> I[I右]
> ```

##### 后+中

> 后序：EFAHCIGBD
>
> 中序：EAFDHCBGI
>
> ```mermaid
> graph TD
> D --> A
> D --> B
> A --> E
> A --> F
> B --> C
> B --> G
> C --> H[H左]
> G --> I[I右]
> ```

##### 层+中

> 层序：ABCDE
>
> 中序：ACBED
>
> ```mermaid
> graph TD
> A --> B[B右]
> B --> C
> B --> D
> D --> E[E左]
> ```

#### 二叉树的非递归遍历算法

##### 先序遍历

使用栈即可实现，主要思想是先将根结点压入栈，然后结点出栈并访问结点，然后依次将结点的右孩子、左孩子压入栈，直到栈为空为止

```c
void PreOrderIter(BiTree T){
    if(T == NULL) return;
    Stack s;
    InitStack(&s);
    push(&s, T);
    while(!IsEmpty(s)){
        BiNode *t;
        Pop(&s, t);
        visit(t);
        if(t->rchild != NULL)
            Push(&s, t->rchild);
        if(t->lchild != NULL)
            Push(&s, t->lchild);
    }
}
```

另一种使用栈的方法，当左子树遍历完后，需要回溯并访问右子树，每次Pop出结点时都是回溯到父节点的过程，即左子树已空，可以访问右子树了

```c
void PreOrderIter(BiTree T){
    Stack s;
    InitStack(&s);
    BiNode *t = T;
    while(t != NULL || !IsEmpty(s)){
        if(t != NULL){
            visit(t);
            Push(&s, t);
            t = t->lchild;
        }
        else{
            Pop(&s, t);
            t = t->rchild;
        }
    }
}
```

##### 中序遍历

也使用栈实现，与先序遍历算法2类似，但算法访问结点时机不同

```c
void InOrderIter(BiTree T){
    Stack s;
    InitStack(&s);
    BiNode *t = T;
    while(t != NULL || !IsEmpty(s)){
        if(t != NULL){
            Push(&s, t);
            t = t->lchild;
        }
        else{
            Pop(&s, t);
            visit(t);
            t = t->rchild;
        }
    }
}
```

##### 后序遍历

可以使用两个栈实现后序遍历非递归算法，可以将后序算法看作是先访问根节点，再访问右孩子之后访问左孩子的逆过程，算法步骤如下：

1. Push结点到第一个栈s中
2. 从第一个栈s中Pop出一个结点，并将其Push到第二个栈Output中
3. 然后依次Push结点的左、右孩子到第一个栈s中
4. 重复2、3步直到栈s为空
5. 完成后，所有结点都在output栈里，而且按后序遍历的顺序存放，直接全部Pop出来就是二叉树后序遍历结果

```c
void PostOrderIter(BiTree t){
    Stack s, output;
    InitStack(&s);
    InitStack(&output);
    
    BiNode *temp;
    Push(&s, t);
    while(!IsEmpty(s)){
        Pop(&s, temp);
        Push(&output, temp);
        if(temp->lchild!=NULL)
            Push(&s, temp->lchild);
        if(temp->rchild!=NULL)
            Push(&s, temp->rchild);
    }
    
    while(!IsEmpty(output)){
        Pop(&output, temp);
        visit(temp);
    }
}
```

### 线索二叉树

#### 基本概念

对于普通二叉树，每次遍历必须从根结点开始，且对于二叉树内结点p求其遍历序列中的前驱和后继必须进行遍历才能找到

> 从根节点出发，重新进行遍历，指针q记录当前访问节点，节点pre记录前驱
>
> - 求前驱
>
> 	q==p，pre\==p前驱
>
> - 求后继
>
> 	pre==p，q\==p后继

故对于普通二叉树，求前驱和后继都很不方便

线索二叉树：因为n个节点的指针有2n个指针域且有n-1个节点被占，故有n+1个空域可以用来存储前驱和后继关系(左孩子存前驱，右孩子存后继)

> 中序线索二叉树例子
>
> ![image-20220815190048535](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220815190048535.png)

#### 存储结构

```c
typedef struct ThreadNode{
    int data;
    struct ThreadNode *lchild, *rchild;     // 左右子树
    int ltag, rtag;                         // 左右线索标志
}ThreadNode, *ThreadTree;
```

#### 线索化二叉树

1. 中序线索化

	```c
	// 全局遍历pre，记录节点前驱
	ThreadNode *pre=NULL;
	void visit(ThreadNode *q){
	    if (q->lchild == NULL){
	        // 左孩子为空则指向前驱
	        q->lchild = pre;
	        q->ltag = 1;
	    }
	    if (pre != NULL && pre->rchild == NULL){
	        // 创建前驱的后继节点
	        pre->rchild = q;
	        pre->rtag = 1;
	    }
	    pre = q;
	}
	void InThread(ThreadTree *T){
	    if (*T != NULL){
	        InThread(&((*T)->lchild));
	        visit(*T);
	        InThread(&((*T)->rchild));
	    }
	}
	void CreateInThread(ThreadTree *T){
	    pre = NULL;
	    if (*T != NULL){
	        InThread(T);
	        if (pre->rchild == NULL)
	            pre->rtag = 1;
	    }
	}
	```

2. 先序线索化

	```c
	void PreThread(ThreadTree *T){
	    if (*T != NULL){
	        visit(*T);
	        if ((*T)->ltag == 0)
	            PreThread(&((*T)->lchild));
	        PreThread(&((*T)->rchild));
	    }
	}
	void CreatePreThread(ThreadTree *T){
	    pre = NULL;
	    if (*T != NULL){
	        PreThread(T);
	        if (pre->rchild == NULL)
	            pre->rtag = 1;
	    }
	}
	```

	只改PreThread，因为先序遍历可能出现前序节点为自己的上级，且自己无左孩子，若不修改PreThread，则由于visit时已将左孩子修改为上级，则此时访问左节点便又会回到上级节点，如

	![image-20220816184403008](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220816184403008.png)

	D前驱为B，在visit前D左孩子为空，visit后D左孩子为B，ltag=1，若不检查ltag则会继续访问D左孩子即B出现死循环

3. 后序

	都不变

	```c
	void PostThread(ThreadTree *T){
	    if (*T != NULL){
	        PreThread(&((*T)->lchild));
	        PreThread(&((*T)->rchild));
	        visit(*T);
	    }
	}
	void CreatePostThread(ThreadTree *T){
	    pre = NULL;
	    if (*T != NULL){
	        PostThread(T);
	        if (pre->rchild == NULL)
	            pre->rtag = 1;
	    }
	}
	```

	访问P时左右孩子已经访问结束，不可能访问左子树指向的子树

#### 在线索二叉树中找前驱和后继节点

1. 中序线索二叉树

  - 后继

	第一个节点必为最左下角的节点

	找下一个节点：p->rtag==1 next=p->rchild; p->rtag\==0 next=p节点右孩子最左下角节点

  - 前驱

	最后一个节点必为最右下角的节点

	找前一个结点：p->ltag==1 next=p->lchild; p->ltag\==0 next=p节点左孩子最右下角节点

  ```c
  // 中序遍历第一个节点
  ThreadNode *InFirstNode(ThreadNode *p){
  	while(p->ltag==0)
          p = p->lchild;
  	return p;
  }
  // 中序遍历后继
  ThreadNode *InNextNode(ThreadNode *p){
  	if(p->rtag == 1)
          return p->rchild;
   	else
          return InFirstNode(p->rchild);
  }
  // 中序遍历，非递归
  void InOrder(ThreadTree T){
  	for(ThreadNode *p=InFirstNode(T);p!=NULL;p=InNextNode(p))
          printf("%d ", p->data);
      printf("\n");
  }
  
  // 倒序输出中序遍历
  // 中序遍历最后一个节点
  ThreadNode *InLastNode(ThreadNode *p){
      while(p->rtag==0)
          p=p->rchild;
      return p;
  }
  // 中序遍历前驱
  ThreadNode *InPreNode(ThreadNode *p){
  	if(p->ltag==1)
          return p->lchild;
      else
          return InLastNode(p->lchild);
  }
  // 逆中序遍历，非递归
  void RevInOrder(ThreadTree p){
      for (ThreadNode *i = InLastNode(p); i != NULL; i=InPreNode(i)) {
          printf("%d ", i->data);
      }
      printf("\n");
  }
  ```

2. 前序线索二叉树

  - 后继

	p->rtag==1 next=p->rchild

	p->rtag==0 p->ltag\==0(即本结点左右子树都有故后继为左子树) next=p->lchild

	p->rtag==0 p->ltag\==1(即本届点右子树不空而左子树空故后继为右子树)next=p->rchild

  - 前驱

	p->ltag==1 prior=p->lchild

	p->ltag==0则只能重新遍历找前驱

	```c
	if(p为根结点)
		// 无前驱
		return NULL;
	else
		从头遍历找到其父节点
		if(p为左孩子)
			return 父节点;
		if(p为右孩子，且左孩子为空)
			return 父节点;
		if(p为右孩子，且左孩子不为空)
			return 左孩子最后一个被访问的结点;
	```

3. 后序线索二叉树

- 前驱

	p->ltag=1 prior=p->lchild

	p->ltag=0 p->rtag=0 prior=p->rchild

	p->ltag=0 p->rtag=1 prior=p->lchild

- 后继

	p->rtag=1 next=p->rchild

	p->rtag==0则只能重新遍历找到其父节点

	``` c
	if(p为根结点)
		// 无后继
		return NULL;
	else
		从头遍历找到其父节点
		if(p为右孩子)
			return 父节点;
		if(p为左孩子，且右孩子为空)
			return 父节点;
		if(p为左孩子，且右孩子不为空)
			return 右孩子第一个被访问的结点;
	```

## 树、森林

### 树的存储结构

#### 双亲表示法

优点：找父节点方便；缺点：找孩子节点困难

每个节点中保存指向双亲的指针，顺序存储

```c
// 树的双亲表示法，顺序存储
typedef struct PTNode
{
    int data;
    int parent;
}PTNode;
typedef struct PTree
{
    PTNode nodes[MAXSIZE];
    int n;   //结点数
};
```

![image-20220822182747388](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220822182747388.png)

|      | data | parent |
| :--: | :--: | :----: |
|  0   |  A   |   -1   |
|  1   |  B   |   0    |
|  2   |  C   |   0    |
|  3   |  D   |   0    |
|  4   |  E   |   1    |
|  5   |  F   |   1    |
|  6   |  G   |   2    |
|  7   |  H   |   3    |
|  8   |  I   |   3    |
|  9   |  J   |   3    |
|  10  |  K   |   4    |

增加节点直接在树中添加信息即可；删则会让双亲度减1且需要移动后面的元素，若删除的是叶子节点则直接删除，若不是则需要遍历删除

#### 孩子表示法(顺序+链式存储)

优点：找孩子方便；缺点：找父亲困难

```c
// 树的孩子表示法，顺序+链式存储
struct CTNode
{
    int child;                  // 孩子结点在数组中的位置
    struct CTNode *next;            // 下一个孩子结点
};
typedef struct CTBox
{
    int data;
    struct CTNode *firstChild;      //第一个孩子
}CTBox;
typedef struct CTree
{
    CTBox nodes[MAXSIZE];
    int n, r;       // 结点数与根所在的位置
}CTree;
```

上图中的树用孩子表示法即

![image-20220822184541937](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220822184541937.png)

#### 左孩子右兄弟表示法(链式存储)

如此就可以使用二叉树的操作来操作树

![image-20220822184549773](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220822184549773.png)

```c
// 树的左孩子右兄弟表示法，链式存储
typedef struct CSNode
{
    int data;
    struct CSNode *firstChild, *nextSibling;        // 左孩子右兄弟
}CSNode, *CSTree;
```

#### 森林与二叉树的转化

森林是n ($n \gt 0$) 棵互不相交的树的集合，采用左孩子右兄弟方法，将各树根结点看做兄弟结点

![image-20220822185115871](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220822185115871.png)

### 树、森林的遍历

#### 树的遍历

![image-20220822185619825](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220822185619825.png)

##### 深度遍历—DFS

###### 先根遍历

若树非空，先访问根结点，之后再依次对其子树进行先根遍历

```c
// 树的先根遍历
void PreOrder(CSTree T){
    if(T != NULL){
        visit(T);			// 访问根节点
        while(结点还有下一个子树R)
            PreOrder(R);	// 先根遍历其子树
    }
}
```

故上图中的树先根遍历序列为：ABEKFCGDHIJ

**可见树的先根遍历序列与其二叉树表示方式的先序遍历序列一致**

###### 后根遍历

若树非空，则先对每个子树进行后根遍历，之后再访问根节点

```c
void InOrder(CSTree T){
    if(T != NULL){
        while(T有其他子树R)
            InOrder(R);
        visit(T);
    }
}
```

故上图中的树后根遍历序列为：KEFBGCHIJDA

**可见树的后根遍历序列与其二叉树表示方式的中序遍历序列一致**

##### 广度遍历—BFS

1. 若树非空，则根结点入队
2. 若队列非空，则队头元素出队并访问，同时将该元素的所有孩子都依次入队
3. 重复2直到队空

#### 森林遍历

![image-20220823182058962](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220823182058962.png)

##### 先序遍历

对各个树先根遍历，对应二叉树的先序

若森林非空，则

1. 访问第一棵树的根结点
2. 先序遍历第一颗树中根节点的子树森林
3. 先序遍历除去第一颗树之后剩余的树构成的森林

BEKLFCGDHMIJ

##### 中序遍历

**对每个树后根遍历**，对应树二叉的中序

若森林非空，则

1. 中序遍历第一颗树中根节点的子树森林
2. 访问第一颗树的根结点
3. 中序遍历除去第一颗树之后剩余的树构成的森林

KLEFBGCMHIJD

## ==树与二叉树的应用==

### 二叉排序树(BST)

#### 定义—有序组织搜索元素

二叉排序树(BST)，也可以叫二叉查找树，有如下性质的二叉树或空二叉树：

- 左子树上的所有结点上的关键字都小于根节点上的关键字
- 右子树上的所有结点上的关键字都大于根结点上的关键字
- 左右子树也是二叉排序树

此时只要进行中序遍历，其结果就是递增的序列

#### 查找

若树非空，则将结点的关键字与当前值相比

1. 若相等则成功
2. 若不相等则失败，小于则去左子树，大于则去右子树

成功就返回结点指针，失败就返回null

```c
// 非递归查找
BSTNode *NoRBST_Search(BSTree T, int key){
    // 如果节点不为空且节点值不相等则继续循环
    while (T != NULL && key != T->key)
    {
        if (key < T->key)
            T = T->lchild;
        else
            T = T->rchild;
    }
    return T;
}
// 递归查找
BSTNode *BST_Search(BSTree T, int key){
    if (T == NULL)
        return NULL;
    else if (key == T->key)
        return T;
    else if (key < T->key)
        return BST_Search(T->lchild, key);
    else
        return BST_Search(T->rchild, key);
}
```

#### 插入

若原来为空树，则直接插入；若key小于结点，则去其左子树；反之就去右子树

易得到不同关键字顺序可以有同一种二叉树，也可能不同

```c
// 递归插入，最差空间复杂度为O(n)
int BST_Insert(BSTree *Tree, int key){
    if ((*Tree) == NULL){
        // 直接插入
        (*Tree) = (BSTree)malloc(sizeof(BSTree));
        (*Tree)->key = key;
        (*Tree)->lchild = (*Tree)->rchild = NULL;
        return 1;
    }
    if (key == (*Tree)->key)
        return 0;
    else if (key < (*Tree)->key)
        return BST_Insert(&((*Tree)->lchild), key);
    else
        return BST_Insert(&((*Tree)->rchild), key);
}
// 非递归插入，最差空间复杂度为O(1)
int NoRBST_Insert(BSTree *Tree, int key){
    // 若树为空，则直接插入
    if ((*Tree) == NULL){
        // 直接插入
        (*Tree) = (BSTree)malloc(sizeof(BSTree));
        (*Tree)->key = key;
        (*Tree)->lchild = (*Tree)->rchild = NULL;
        return 1;
    }

    // 树不为空，则记录上一个节点与自己
    BSTree pre = NULL;
    BSTree pnow = (*Tree);
    while (pnow != NULL){
        // 找到最后一个节点
        if (key == pnow->key)
            return 0;
        else if (key < pnow->key){
            // 往左走
            pre = pnow;
            pnow = pnow->lchild;
        } else{
            // 往右走
            pre = pnow;
            pnow = pnow->rchild;
        }
    }

    // 之后判断key值与pre的关系
    if (key < pre->key){
        BSTNode *now = (BSTNode *)malloc(sizeof(BSTNode));
        (*now).key = key;
        (*now).lchild = (*now).rchild = NULL;
        pre->lchild = now;
    } else{
        BSTNode *now = (BSTNode *)malloc(sizeof(BSTNode));
        (*now).key = key;
        (*now).lchild = (*now).rchild = NULL;
        pre->rchild = now;
    }
    return 1;
}
```

#### 删除

首先找到目标结点

1. 若被删除结点为叶子结点，则直接删除

2. 若被删除结点只有一棵左子树或右子树，则让左子树或右子树连接在原来结点与其双亲结点相邻的指针上即可，代替他的位置

3. 若被删除结点有左右子树，则令目标结点的直接后继(直接前驱)代替目标结点，然后在二叉树中删除该直接后继(直接后继)，这样就转化为了第1或第2两种情况

	这里的直接前驱/后继表示中序遍历的前驱/后继

```c
BSTree* Delete(BSTree *T, int key)
{
    BSTree *tmp;
    if(!T) printf("not found\n");
    else if(key < T->key)
        T->lchild = Delete(T->lchild, key);
    else if(key > T->key)
        T->rchile = Delete(T->rchild, key);
    else
    {
        if(T->lchild && T->rchild)
        {
            tmp = Find_Min(T->rchild);
            T->key = tmp->key;
            T->rchild = Delete(T->rchild, T->key);
            // tmp = Find_Max(T->lchild);
            // T->key = tmp->key;
            // T->lchild = Delete(T->lchild, T->key);
        }
        else
        {
            if(!T->lchild)
                T = T->rchild;
            else if(!T->rchild)
                T = T->lchild;
        }
    }
    return T;
}
```

#### 查找效率分析

若树高为n，则最多比较n次，故时间复杂度为$O(\log_2(n))$，最差为$O(n)$

查找长度：在查找运算中，需要对比关键字次数，反应了查找操作时间复杂度

> ![image-20220824184304210](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220824184304210.png)
>
> - 查找成功平均查找长度ASL
>
> 	1：$\frac{1+2*2+3*4+4}{8}=2.625$
>
> 	2：$\frac{1+2*2+3+4+5+6+7}{8}3.75$
>
> 	故1优于2
>
> - 查找失败平均查找长度ASL
>
> 	1：$\frac{7*3+4*2}{9}=3.22$
>
> 	2：$\frac{3*2+3+4+5+6+7*2}{9}=4.22$

#### 判断一个查找序列是不是二叉排序树的查找序列

例如，给定一个值60，在二叉排序树上寻找关键字值为60的结点时，访问的关键字值序列S={20，30，90，80，40，50，70，60}。若将S分为两个子序列，S1所包含的都是小于或等于60的数据，S1={20，30，40，50，60}；S2所包含的都是大于60的数据，S2={90，80，70}。如此可得判断是否是查找序列的原则:如果从S所生成的S1单调递增，S2单调递减，且除待查元素外，S1中的每个数据都小于给定值，S2中的每个数据都大于给定值，则S是一个查找序列，否则不是查找序列。算法描述如下:

```c
typedef struct 
{
    int elem[MaxSize];
    int len
}Sequence;

void reduce(Sequence *S, Sequence *S1, Sequence *S2)
{
    int i=0, j=0, k=0;
    while(i < S.len-1)
    {
        while(i < S.len-1 && S.elem[i] < S.elem[i+1])
            S1.elem[j++] = S.elem[i++];
        while(i < S.len-1 && S.elem[i] > S.elem[i+1])
            S2.elem[k++] = S.elem[i++];
    }
    S1.len = j;
    S2.len = k;
}

int judge(Sequence *S1, Sequence *S2, int x)
{
    int i=0, flag=1;
    while(i < S1.len-1 && flag)
    {
        if(S1[i] > S1[i+1] || S1[i] > x)
            flag = 0;
        else
            i++;
    }
    i = 0;
    while(i < S1.len-1 && flag)
    {
        if(S1[i] < S1[i+1] || S1[i] < x)
            flag = 0;
        else
            i++;
    }
    return flag;
}

int issearch(Sequence *S, Sequence *S1, Sequence *S2, int x)
{
    reduce(S, S1, S2);
    return judge(S1, S2, x);
}
```

### 平衡二叉树(AVL)

#### 定义

平衡二叉树，简称平衡树(AVL)，即**树上任一结点左右子树高度差的绝对值不超过1**

结点平衡因子=左子树高-右子树高

#### 插入

从插入点往回找到第一个不平衡结点，调整该结点为根的子树，每次调整对象都是最小不平衡子树，调整后其他结点都会平衡

1. LL平衡旋转(右单旋转)

	由于在结点A的左子树(L)的左孩子(L)上插入新结点，A的平衡因子由1增至2，故可以以A为根的子树做一次向右的旋转操作，如下：

	![image-20220825182840856](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825182840856.png)

2. RR平衡旋转(左单旋转)

	由于在结点A的右子树(R)的右孩子(R)上插入新结点，A的平衡因子由-1减至-2，故可以以A为根的子树做一次向左的旋转操作，如下：

	![image-20220825183018123](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825183018123.png)

3. LR平衡旋转(先左后右双旋转)

	由于在结点A的左子树(L)的右孩子(R)上插入新结点，A的平衡因子由1增至2，故可以以A为根的子树做一次先左后右的旋转操作，如下：

	![image-20220825183348530](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825183348530.png)

4. RL平衡旋转(先右后左旋转)

	由于在结点A的右子树(R)的左孩子(L)上插入新结点，A的平衡因子由-1减至2，故可以以A为根的子树做一次先右后左的旋转操作，如下：

	![image-20220825183413776](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825183413776.png)

> {40， 72，38，35，67，51，90，8，55，21}构建平衡二叉树
>
> ![image-20220825184023973](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825184023973.png)
>
> {34，23，15，98，115，28，107}构建平衡二叉树
>
> ![image-20220825184534833](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220825184534833.png)

##### 代码实现思路

1. LL & RR

	对LL来说，即实现f向右下旋转，p向右上旋转，其中f为父节点A，p为其左孩子B，gf为f的父节点

	```c
	f->lchild=p->rchild;
	p->rchild=f;
	gf->lchild/rchild=p;
	```

	对RR来说，即实现f向左下旋转，p向左上旋转，其中f为父节点A，p为其右孩子B，gf为f的父结点

	```c
	f->rchild=p->lchild;
	p->lchild=f;
	gf->lchild/rchild=p;
	```

2. LR & RL

	对LR来说，即实现f向右下旋转，p向右上旋转，而g相对不变，其中f为父节点A，p为其左孩子B，g为p的右孩子C，gf为f的父节点

	```c
	// f、p实现左旋
	p->rchild=g->lchild;
	g->lchild=p;
	// f->lchild=g; 下一句就重新定义了故省去
	// f、g实现右旋
	f->lchild=g->rchild;
	g->rhild=f;
	gf->lchild/rchild=g;
	```

	对RL来说，即实现f向左下旋转，p向左上旋转，而g相对不变，其中f为父节点A，p为其右孩子B，g为p的左孩子C，gf为f的父节点

	```c
	// 实现p、g之间的右旋
	p->lchild=g->rchild;
	g->rchild=p;
	// f->rchild=g; 下一句就重新定义了故省去
	// 实现g、f之间的左旋
	f->rchild=g->lchild;
	g->lchild=f;
	gf->lchild/rchild=g;
	```

> 为什么调整最小不平衡树会让其他祖先重新平衡
>
> - 因为是插入导致的最小不平衡树高度+1，经调整后该树高度恢复

故查找效率$\le O(h)$，h为树高，最大为$O(\log_2n)$，平均查找长度也是$O(\log_2n)$

### 哈夫曼树和哈夫曼编码

#### 定义

给结点赋值，表示结点重要性

带权路径长度：**从树的根到该结点的路径长度(经过的边数)与该结点上的权值的乘数**

树的带权路径长度：树的所有叶子结点的带权路径长度之和，即$WPL=\sum_{i=1}^nW_il_i$

哈夫曼树：含有n个带权叶结点的二叉树，其中**带权路径长度(WPL)最小的二叉树成为哈夫曼树**，也称最优二叉树

#### 构造

给定n个权值分别为$W_1$、$W_2$、……、$W_n$的结点，构造哈夫曼树的算法描述如下

- 将这n个结点分别作为n棵仅剩一个结点的二叉树，构成森林F
- 构造一个新节点，从F中选取两颗节结点权值最小的树作为新节点的左右子树，并且将新节点的权值置为左右子树上根结点的权值之和
- 从F中删除刚才选中的两棵树，同时将新得到的树加入F中
- 重复2、3直到F中只剩一棵树为止

![image-20220826183527123](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220826183527123.png)

> Note
>
> 1. **每个初始节点最终都是叶子结点，且权值越小的结点到根结点的路径长度越大**
>
> 2. 哈夫曼树的结点个数为2n-1，即无度为1的结点
>
> 	n个叶子，度为2(n-1)，故共2n-1个结点
>
> 3. **哈夫曼树无度为1结点**
>
> 4. 哈夫曼树不唯一，但WPL一定最小

#### 哈夫曼编码—前缀编码

使用哈夫曼树(构树时左0右1)让编码长度(可变长度编码，允许对不同值用不同长度编码)也就是树带权长度最小

**不使用哈夫曼编树构造的可变长度编码可能存在歧义问题**

**没有一个编码是另一个编码的前缀，则这种编码就是前缀编码，故非前缀编码可能存在歧义**

哈夫曼编码不唯一，可用于数据压缩

#### 多叉哈夫曼树

如果初始归并段的数量无法构成严格的k叉归并树，则需要补充几个长度为0的虚段，在进行k叉哈夫曼树的构造

那到底要补充几个呢？

- 因为严格的k叉归并树树的度为0或k，故设度为k的结点有$n_k$个，度为0的结点有$n_0$个，总共有n个

	故$n=n_0+n_k$，且$kn_k+1=n$，故$kn_k+1=n_0+n_k$，故$n_0=(k-1)n_k+1$，**故$n_k=\frac{n_0-1}{k-1}$为整数**

- 若$(初始归并段数量-1) \%(k-1)=0$，说明刚好构成严格k叉树，不需要添加虚段

- 若$(初始归并段数量-1) \%(k-1)=u!=0$，则需要补充$(k-1)-u$个虚段

# ==图==

## 图的基本概念

### 图的定义

图由**顶点集V和边集E**组成，记为$G=\{V,E\}$，其中$V(G)$表示图G中顶点的有限非空集；$E(G)$表示图中顶点之间的关系(边)集合。若$V=\{v_1,v_2, \dots,v_n\}$，则用**$|V|$表示图G中顶点的个数，也称图G的阶**；$E=\{(u,v)|u \in V,v \in V\}$，用**$|E|$表示图G中边的条数**

> 线性表可以空，树可以空，图不能空(指**结点集V一定非空，而边集E可空**)

1. 无向图![image-20220826185555037](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220826185555037.png)

2. 有向图![image-20220826185636262](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220826185636262.png)

3. 简单图、多重图

	简单图：无重复边，无结点到自身的边

	多重图：某两点之间的边多于1条，或允许结点通过一条边与自己链接![image-20220826190015007](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220826190015007.png)

4. 完全图(简单完全图)

	无向完全图：任意两个结点之间都有边的无向图，故n个结点就有$C_{n}^2$条边

	有向完全图：任意两个结点之间都有边的有向图，故n个结点就有$2C_{n}^2$条边

	边很少的图为稀疏图($|E| \lt |V|log|V|$)，反之为稠密图

5. 顶点的度、入度、出度

	对无向图来说，顶点的度指依附于顶点v的边数目，记为$TD(v)$；$\sum_{i=1}^nTD(v_i)=2e$

	对有向图来说，顶点的入度是以顶点v为终点的边数目，记为$ID(v)$；顶点的出度是以顶点v为起点的边数目，记为$OD(v)$；$\sum_{i=1}^nID(v_i)=\sum_{i=1}^nID(v_i)=e$；顶点的度=入度

6. 顶点之间关系描述

	![image-20220829182345878](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220829182345878.png)

7. 连通图、强连通图

	连通图(无向)：任意两个结点都连通

	强连通图(有向)：任意两个结点都强连通，强连通不一定有弧

	对**无向图：连通至少要n-1条边，最多$C_n^2$条边**

	对**有向图：连通最少n条边**(一个回路)

8. 子图

	![image-20220829182857030](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220829182857030.png)

	**点都有的子图就是生成子图**

9. 连通分量(无向图)

	无向图中的**==极大连通子图(子图连通，尽可能多的顶点和边)称为连通分量==**

10. 强连通分量

	有向图中的**==极大强连通子图(子图强连通，尽可能多的顶点和边)称为强连通分量==**

11. 生成树、生成森林

	==**连通图(无向)的生成树是包含图中全部顶点的一个极小连通子图(不唯一)，n个顶点n-1条边**==

	在非连通图中，**连通分量的生成树构成生成森林**

12. 边的权、带权图/网

	边的权：一个图中，每条边都可以标上具有某种含义的数值，即边的权

	带权图/网：边上有权值的图

	带权路径长度：当图为带权图时，一条路径上所有边的权值之和

13. 特殊的图—树、森林

	有向树：只有一个顶点入度为0，其出度均为1的图

	![image-20220829183704773](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220829183704773.png)

14. ==常见考点==

	对于n个顶点的无向图G

	- 所有顶点度的和=2$|E|$
	- 若G为连通图，则最少有n-1条边
	- 若$|E| \gt n-1$，则一定存在回路
	- 若G为连通图，则最多可能有$C_n^2$条边
	- 无向完全图有$C_n^2$条边

	对于n个顶点的有向图G

	- 顶点的入度和=顶点的出度和=$|E|$
	- 所有顶点度的和=2$|E|$
	- 若G为连通图，则最少有n条边
	- 有向完全图有2$C_n^2$条边

## 图的存储及基本操作

### 邻接矩阵法

在确定顶点序号后，表示方法唯一

```c
# define MaxVertexNum 100
typedef char VertexType;            // 顶点的数据类型
typedef int EdgeType;               // 带权图中边上权值的数据类型
typedef struct {
    VertexType Vex[MaxVertexNum];   // 顶点表
    EdgeType Edge[MaxVertexNum][MaxVertexNum];  // 邻接矩阵，边表
    int vexnum, arcnum;                         // 图当前的顶点数和弧数
}MGraph;                            // 无向图
```

$$
A[i][j]=
\begin{cases}
1 & 若(v_i,v_j)或<v_i,v_j>是边 \\
0 & 若(v_i,v_j)或<v_i,v_j>不是边
\end{cases}
\tag{1}
$$

若为带权图，则在临接矩阵中放权值，若无边则放无穷

空间复杂度—$O(n^2)$，**适合稠密图，对无向图(对称矩阵)可以进行压缩存储**

**==性质：设图G的邻接矩阵为A(元素为0、1)，则$A^n$的元素$A^n[i][j]$等于由顶点i到j长度为n的路径的数目==**，此处的$A^n$是真的用矩阵乘法求出来的解

### 邻接表法

```c
// 邻接表法
// 边
typedef struct ArcNode{
    int adjvex;                     // 边指向哪个结点
    typedef struct ArcNode *next    // 指向下一条边的指针
    InfoType info;                  // 权值
}ArcNode;
// 顶点
typedef struct VNode{
    VertexType data;                // 顶点信息
    ArcNode *first;                 // 第一条边
}VNode, AdjList[MaxVertexNum];
// 图
typedef struct {
    AdjList vertices;               // 顶点与边
    int vexnum, arcnum;             // 图当前的顶点数和弧树
}ALGraph;
```

空间复杂度

- 无向图：$O(|V|+2|E|)$
- 有向图：$O(|V|+|E|)$

度

- 无向图：边链表个数
- 有向图：入度+出度
	- 入度：遍历所有结点记录
	- 出度：边链表个数

> 图的邻接表法表示方法不一致，**适合稀疏图**

### 十字链表 & 邻接多重表

邻接矩阵空间复杂度高，邻接表有向图查入度困难

#### 十字链表法

有向图的一种存储方式，顶点之间顺序存储

![image-20220830181751060](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220830181751060.png)

空间复杂度：$O(|V|+|E|)$

```c
// 十字链表法
// 边
typedef struct ArcNode{
    int tailvex;                    // 弧尾结点
    int headvex;                    // 弧头结点
    InfoType info;                  // 弧权值
    ArcNode *hlink;                 // 弧头相同的下一条弧
    ArcNode *tlink;                 // 弧尾相同的下一条弧
}ArcNode;
// 顶点
typedef struct VNode{
    VertexType data;                // 顶点信息
    ArcNode *firstin;               // 该顶点作为弧头的第一条边
    ArcNode *firstout;              // 该顶点作为弧尾的第一条边
}VNode, AdjList[MaxVertexNum];
// 图
typedef struct {
    AdjList vertices;               // 顶点与边
    int vexnum, arcnum;             // 图当前的顶点数和弧树
}ALGraph;
```

#### 邻接多重表法

每条边都有两份冗余信息，删除结点、边等操作时时间复杂度高；无向图的一种存取方式

![image-20220830182802969](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220830182802969.png)

空间复杂度为$O(|V|+|E|)$

```c
// 邻接多重表法
// 边
typedef struct ArcNode{
    int i;                    		// 弧尾结点
    int j;                    		// 弧头结点
    InfoType info;                  // 弧权值
    ArcNode *ilink;                 // 依附于结点i的下一条弧
    ArcNode *jlink;                 // 依附于结点j的下一条弧
}ArcNode;
// 顶点
typedef struct VNode{
    VertexType data;                // 顶点信息
    ArcNode *first;               	// 与该顶点相邻的第一条边
}VNode, AdjList[MaxVertexNum];
// 图
typedef struct {
    AdjList vertices;               // 顶点与边
    int vexnum, arcnum;             // 图当前的顶点数和弧树
}ALGraph;
```

### 存储结构之间对比

|              |                邻接矩阵                |                 邻接表                  |   十字链表   |  邻接多重表  |
| :----------: | :------------------------------------: | :-------------------------------------: | :----------: | :----------: |
|  空间复杂度  |               $O(|V|^2)$               | 无向图$O(|V|+2|E|)$；有向图$O(|V|+|E|)$ | $O(|V|+|E|)$ | $O(|V|+|E|)$ |
|   找相邻边   |     遍历对应行或列找到第一个正常数     |  一般较简单，但要找有向图的入边很困难   |     方便     |     方便     |
| 删除边或顶点 | 删除边很方便，删除顶点需要移动大量数据 |       无向图删除边或结点都很困难        |     方便     |     方便     |
|    适用于    |                 稠密图                 |                 稀疏图                  |    有向图    |    无向图    |
|   表示方式   |                  唯一                  |                 不唯一                  |    不唯一    |    不唯一    |

### 图的基本操作

![image-20220830183803696](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220830183803696.png)

1. Adjacent(G, x, y)：判断图G是否有边<x, y>或(x, y)

	|        |           邻接矩阵            |                        邻接表                        |
	| :----: | :---------------------------: | :--------------------------------------------------: |
	| 无向图 | G\[x][y]!=0；时间复杂度为O(1) | G[x]的链表遍历；时间复杂度最好为O(1)，最差为O(\|V\|) |
	| 有向图 | G\[x][y]!=0；时间复杂度为O(1) | G[x]的链表遍历；时间复杂度最好为O(1)，最差为O(\|V\|) |

2. Neighbors(G, x)：列出与x邻接的边

	|        |                     邻接矩阵                     |                            邻接表                            |
	| :----: | :----------------------------------------------: | :----------------------------------------------------------: |
	| 无向图 | G\[x][y]的行或列不为0的值；时间复杂度为$O(|V|)$  |      G[x]的链表；时间复杂度最好为$O(1)$，最差为$O(|V|)$      |
	| 有向图 | G\[x][y]的行和列不为0的值；时间复杂度为$O(2|V|)$ | 对于其出边，时间复杂度最好为$O(1)$，最差为$O(|V|)$；对于其入边则需要遍历所有边，时间复杂度为$O(|E|)$ |

3. InsertVertex(G, x)：在结点中插入顶点x

	|        |                     邻接矩阵                     |             邻接表              |
	| :----: | :----------------------------------------------: | :-----------------------------: |
	| 无向图 | 点数组扩充1，边数组上下扩充1；时间复杂度为$O(1)$ | 点数组扩充1；时间复杂度为$O(1)$ |
	| 有向图 | 点数组扩充1，边数组上下扩充1；时间复杂度为$O(1)$ | 点数组扩充1；时间复杂度为$O(1)$ |

4. DeleteVertex(G, x)：在结点中删除顶点x

	|        |                           邻接矩阵                           |                            邻接表                            |
	| :----: | :----------------------------------------------------------: | :----------------------------------------------------------: |
	| 无向图 | 点数组删去该点，边数组相关值都设置为0；时间复杂度为$O(|V|)$  |  结点数组删除，相关边链表也删除；时间复杂度为$O(1)-O(|E|)$   |
	| 有向图 | 点数组删去该点，边数组相关值都设置为0；时间复杂度为$O(1)-O(|E|)$ | 结点数组删除，对于出边时间复杂度为$O(1)-O(|E|)$，对于入边时间复杂度为$O(|E|)$ |

5. AddEdge(G, x, y)：加(x, y)或<x, y>

	|        |                邻接矩阵                 |                      邻接表                      |
	| :----: | :-------------------------------------: | :----------------------------------------------: |
	| 无向图 | G[x]\[y]=1&G[y]\[x]=1；时间复杂度为O(1) | 相关结点都加一个边界点(头插)；时间复杂度为$O(1)$ |
	| 有向图 |      G[x]\[y]=1；时间复杂度为O(1)       | 相关结点都加一个边界点(头插)；时间复杂度为$O(1)$ |

6. FirstNeighbor(G, x)：第一个邻居

	|        |                    邻接矩阵                    |               邻接表               |
	| :----: | :--------------------------------------------: | :--------------------------------: |
	| 无向图 | 行或列第一个为1的值；时间复杂度为$O(1)-O(|V|)$ | 边结点第一个值；时间复杂度为$O(1)$ |
	| 有向图 | 行或列第一个为1的值；时间复杂度为$O(1)-O(|V|)$ | 边结点第一个值；时间复杂度为$O(1)$ |

7. NextNeighbor(G, x, y)：y为x邻接点，找到其下一个邻接

	|        |                    邻接矩阵                    |                  邻接表                   |
	| :----: | :--------------------------------------------: | :---------------------------------------: |
	| 无向图 | 行或列下一个为1的值；时间复杂度为$O(1)-O(|V|)$ | 边结点下一个值；时间复杂度为$O(1)-O(|E|)$ |
	| 有向图 | 行或列下一个为1的值；时间复杂度为$O(1)-O(|V|)$ | 边结点下一个值；时间复杂度为$O(1)-O(|E|)$ |

8. Get_edge_value(G, x, y); Set_edge_value(G, x, y);

	与查找类似

9. 遍历

## 图的遍历

### 广度优先遍历BFS

与树的广度优先遍历(层序遍历)类似

```c
int visited[MAX_VERTEX_NUM];		// 访问标记数据

void BFSTraverse(Graph G){
    // 初始化标记数组
    for(int i=0; i<G.vexnum; ++i)
        visited[i] = 0;
    // 初始化辅助队列
    InitQueue(&Q);
    // 从0号顶点开始遍历
    for(int i=0; i<G.vexnum; i++)
        if(!visited[i])
            BFS(G, i)
}

void BFS(Graph G, int v){			// 从v出发广度遍历
    visit(v);
    visited[v] = 1;
    EnQueue(&Q, v);
    while(!IsEmpty(Q)){
        DeQueue(&Q, v);
        for(int w=FirstNeighbor(G, v); w>=0; w=NextNeighbor(G, v, w)){  //检查v的所有邻接点
            if(!visited[w]){
                visit(w);
                visited[w]=1;
                EnQueue(&Q, w);
            }
        }
    }
}
```

图的存储结构不同，遍历结果就有可能不同

空间复杂度：最坏$O(|V|)$，所有节点都入队

时间复杂度：邻接矩阵$O(|V|^2)$；邻接表$O(|V|+|E|)$

> **对于无向图，调用BFS函数次数等于连通分量数**

#### 广度优先生成树/广度优先生成森林

**根据遍历顺序得到一颗遍历树，故连通图生成树，非连通图生成森林**

![image-20220831183231374](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220831183231374.png)

### 深度优先搜索DFS

与树的先序遍历类似

```c
int visited[MAX_VERTEX_NUM];		// 访问标记数据

void DFSTraverse(Graph G){
    for(int i=0; i<G.vexnum; i++)
        visited[i]=0;
    for(int i=0; i<G.vexnum; i++)
        if(!visited[i])
            DFS(G, i);
}

void DFS(Graph G, int i){
    visit(i);
    visited(i) = 1;
    for(int w=FirstNeighbor(G, i); w>=0; w=NextNeighbor(G, i, w)){
        if(!visited[w])
            DFS(G, w);
    }
}
```

空间复杂度：最坏$O(|V|)$，最好$O(1)$

### 经典题型

#### 判断一个无向图是否是一个树

**无向图是否是一个树等价于无向图是否是有n个节点，n-1个边的连通图**

故使用深度遍历DFS统计顶点数与边个数，若一次遍历就有上述子图，则为一棵树

```c
int IsTree(Graph G){
    int vexnum=0, edgenum=0;
    DFS(G, 0, &vexnum, &edgenum);
    if(vexnum == G.vexnum && edgenum == 2(G.vexnum-1))
        return 1;
    else
        return 0;
}
void DFS(Graph G, int i, int *vexnum, int *edgenum){
    (*vexnum)+=1;
    for(int j=FirstNeighbor(G, i); j>=0; j=NextNeighbor(G, i, j)){
        (*edgenum)+=1;
        DFS(G, j, vexnum, edgenum);
    }
}
```

#### 深度遍历的非递归算法

需要有栈参与；

```c
void DFSNotReverse(Graph, int i){
    // 初始化访问数组
    for(int i=0; i<G.vexnum; i++)
        visited[i]=0;
    InitStack(&S);
    visited(i) = 1;
    Push(&S, i);
    while(!IsEmpty(S)){
        int j;
        Pop(&S, &j);
        visit(j);
        for(int k=FirstNeighbor(G, j); k>=0; k=NextNeighbor(G, j, k)){
            if(!visited[k]){
                visited[k]=1;
                Push(&S, k);
            }
        }
    }
}
```

#### 基于BFS(广度)和DFS(深度)算法以邻接表方式存储的有向图中是否存在$<v_i, v_j>$的路径

1. BFS(广度)

	```c
	int BFSFindPath(Graph G, int i, int j){
	    // 初始化访问数组
	    for(int i=0; i<G.vexnum; i++)
	        visited[i]=0;
	    InitQueue(&Q);
	    visited[i] = 1;
	    Push(&Q, i);
	    while(!IsEmpty(Q)){
	        int k;
	        Pop(&Q, &k);
	        if(k == j) return 1;
	        for(int t = FirstNeighbor(G, i); t>=0; t = NextNeighbor(G, k, t)){
	            if(t == j)
	                return 1;
	            if(!visited[t]){
	                visited[t]=1;
	                Push(&Q, t);
	            }
	        }
	    }
	    return 0;
	}
	```

2. DFS(深度)

	```c
	int DFSFindPath(Graph G, int i, int j){
	    // 初始化访问数组
	    for(int i=0; i<G.vexnum; i++)
	        visited[i]=0;
	    return DFS(G, i, j, *can_reach)
	}
	int DFS(Graph G, int i, int j, int *can_reach){
	    if(i == j){
	        (*can_reach) = 1;
	        return 1;
	    }
	    visited[i]=1;
	    for(int k = FirstNeighbor(G, i); k>=0; k = NextNeighbor(G, i, k)){
	    	if(!visited[k] && !(*can_reach))
	            DFS(G, k, j, can_reach)
	    }
	}
	```


#### 输出所有顶点$v_i$到$v_j$的简单路径(图为邻接表)

采用**基于递归的深度优先算法**，从节点$u$出发，递归深度优先遍历图中节点，若访问到节点v，则输出该扫描路径上的节点。为此设置path数组来存放路径上的节点(初始为空)，d表示路径长度(初始为-1)。查找u到v的简单路径过程说明如下：

1. FindPath(G, u, v, path, d); d++; path[d]=u; 若找到u的未访问过的相邻节点$u_1$，则继续，否则恢复环境并返回
2. FindPath(G, u1, v, path, d); d++; path[d]=u1; 若找到u的未访问过的相邻节点$u_2$，则继续，否则恢复环境并返回
3. 如此循环反复，直到$u_i=v$，输出path

```c
void FindPath(ALGraph *G, int u, int v, int *path, int d){
    int w, i;
    ArcNode * p;
    d++;									// 路径长度加1
    path[d]=u;								// 将当前路径加入path
    visited[u]=1;
    if(u==v)
        print("%s", path);					// 若成功则输出
    p = G->adjlist[u]->firstarc;			// p指向u的第一个邻接点
    while(p!=NULL){
        w = p->adjvex;						// 若w未访问则递归访问它
        if(!visited[w])
            FindPath(G, w, v, path, d);
        p = p->next;
    }
    visited[u] = 0;
}
```

## 图的应用

### 最小生成树(最小代价树)

生成树：包含图中所有顶点的一个**极小连通子图**

最小生成树：**带权连通无向图的生成树中权值最小的树**

1. 可能有多个，即**最小生成树只看权值**
2. 它是树，即边数+1=顶点数(边数-1就不连通，边数+1就有回路)
3. **若图本身就是树，则该图的最小生成树就是它本身**

最小生成树的**性质**：假设$G=(V,E)$是一个带权连通无向图， $U$是顶点集$V$的一个非空子集。**若$(u.v)$是一条具有最小权值的边，其中$u \in U, v \in V-U$，则必存在一颗包含$(u, v)$的最小生成树**

Prim和Kruskal算法都利用了上述性质求最小生成树

#### Prim算法

**时间复杂度为$O(|V|^2)$**，执行过程类似寻找最短路径的Dijkstra算法，**适用于边稠密图**

从某个结点开始构树，每次将相邻最小的权值纳入生成树，直到全部顶点都加入为止

![image-20220901185702980](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220901185702980.png)

```c
void Prim(MGraph *G, int u, int *sum)
{
    int i,j,k,min;
    int vset[MaxSize], lowcost[MaxSize], v;
    // vset表示顶点是否加入最小生成树，lowcost为目前到达其他结点的最小值
    v = u;
    for(i=0; i<G->vexnum; i++)				// 初始化
    {
        lowcost[i] = G->edges[v][i];
        vset[i] = 0;
    }
    (*sum) = 0;
    vset[v] = 1;
    for(i=0; i<G->vexnum-1; i++)
    {
        min = 1000000000000;
        for(j=0; j<G.vexnum; j++)			// 找当前权值最小值
        {
            if(vset[j]==0 && lowcost[j] < min)
            {
                min = lowcost[j];
                k = j;
            }
        }
        vset[k] = 1;						// 访问，并以此为新节点更新lowcost数组
        v = k;
        (*sum) += min;
        for(j=0; j<G->vexnum; j++)			// 更新候选边
            if(vset[j]==0 && G->edges[v][j]<lowcost[j])
                lowcost[j] = G->edges[v][j];
    }
}
```

#### Kruskal算法

时间复杂度为$O(|E|\log_2(|E|))$，是一种按权值的递增次数选择合适的边来构造最小生成树，适用于边稀疏图

每次选一个权值最小的边，使边的两头连通，直到所有结点都连通

![image-20220901190411327](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220901190411327.png)

```c
typedef struct
{
    int a, b;					// 一条边的两个顶点
    int cost;					// 权值
}Road;

Road road[MaxSize];				// 边数组，存储所有的边信息
int set[MaxSize];				// 并查集数组

int getRoot(int a)
{
    while(a != set[a])
        a = set[a];
    return a;
}

void Kruskal(MGraph *G, int *sum, Road road[])
{
    int i;
    int N, E, a, b;
    N = G->vexnum;
    E = G->arcnum;
    for(i=0; i<N; i++)
        set[i] = i;
    sort(road, E);			// 边数组按权值排序
    for(i=0; i<E; i++)
    {
        a = getRoot(road[i].a);
        b = getRoot(road[i].b);
        if(a != b)
        {
            set[a] = b;
            (*sum) += road[i].cost;
        }
    }
}
```

#### 一些例题

1. **什么样的图使其最小生成树是唯一的？**

	在构造最小生成树的过程中，要从剩余边中选取权值最小的加入当前树中，如果有多条权值相同且为最小值的边，则可以从中任选一条边并入，这样就会产生多种最小生成树。

	故==所有权值不相等，或者有相等的边，但在构造最小生成树时权值相等的边都被加入生成树的图，其最小生成树唯一==

	> Note：不是只有所有权值不相等的树才有唯一生成树

### ==最短路径==

对于单源最短问题即一个点到其他点的问题，无权图可以采用BFS，有权图可以使用Dijkstra算法；

对于每对顶点之间最短的问题，可以使用Floyd算法

#### BFS—无权图最短路径

实际上就是找一个以当前结点为根，高度最小的广度优先生成树

```c
// 求顶点u到其他顶点的最短路径
void BFS_MIN_Distance(Graph G, int u){
    // d[i]表示从u到i结点的最短路径
    for(int i=0; i<G.vexnum; i++){
        d[i]=1000000;			// 初始化路径长度
        path[i]=-1;				// 最短路径从哪个顶点过来
    }
    d[u]=0;
    visited[u]=1;
    EnQueue(&Q, u);
    while(!IsEmpty(Q)){
        int i;
        DeQueue(&Q, &i);		// 队头元素出队
        for(int j=FirstNeighbor(G, u); j>=0; j=NextNeighbor(G, u, j)){
            if(!visited[j]){	// j为i的未访问邻接点
                d[j]=d[i]+1;	// 路径长度+1
                path[j]=i;		// 最短路径从i到j
                visited[j]=1;
                EnQueue(&Q, j);
            }
        }
    }
}
```

#### Dijkstra算法

两个辅助数组

- **dist[]：记录从源点$v_0$到其他各顶点当前的最短路径长度**，它的初态为：若从$v_0$到$v_i$有弧，则dist[i]为弧上的权值，否则为无穷
- **path[]：path[i]记录从源点到顶点i之间的最短路径的前驱节点**，在算法结束前，可根据其值追溯得到源点$v_0$到顶点$v_i$的最短路径

**算法运行过程如下**：

假设从顶点0出发，即$v_0=0$，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs\[i][j\]表示有向边$$的权值，若不存在该边，则设置arcs\[i][j]为无穷

1. 初始：若从$v_0$开始，令final\[0\]=1; dist\[0\]=0; path\[0\]=-1

	其余顶点final[k]=0; dist[k]=arcs\[0][k]; path[k]=(arcs\[0][k]==10000000)?-1:0;

2. n-1轮处理：循环处理所有顶点，找到还没确认最短路径，且dist最小的顶点$v_i$，令final[i]=1。并检查所有邻接$v_i$的顶点，对于邻接自$v_i$的顶点$v_j$，若final[j]==0且$dist[i]+arcs[i][j] \lt dist[j]$，则令$dist[j]=dist[i]+arcs[i][j]; \quad path[j]=i;$

3. **如此循环反复直到final数组都为1**

可见时间复杂度为$O(|V|^2)$，但Dijkstra算法不适用于负数图，因为会失效

![image-20220902185816975](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220902185816975.png)

```c
// path实际上是树的双亲表示法，输出其从根结点到叶子结点的序列
void printfPath(int path[], int a)
{
    int stack[MaxSize], top = -1;
    while(path[a] != -1)
    {
        stack[++top] = a;
        a = path[a];
    }
    stack[++top] = a;
    while(top != -1)
        printf("%d", stack[top--]);
}

void Dijkstra(MGraph *G, int u, int dist[], int path[])
{
    int set[MaxSize];
    int min, i, j, v;
    // 初始化各数组
    for(i=0; i<G->vexnum; i++)
    {
        dist[i] = G->edges[u][i];
        set[i] = 0;
        if(G->edges[u][i] < INF)
            path[i] = u;
        else
            path[i] = -1;
    }
    set[u] = 1, path[u] = -1;
    
    for(i=0; i<G->vexnum-1; i++)
    {
        min = INF;
        // 找出当前未访问的最小值
        for(j=0; j<G->vexnum; j++)
        {
            if(min > dist[j] && set[j] == 0)
            {
                min = dist[j];
                v = j;
            }
        }
        
        set[v] = 1;
        
        // 更新dist和path数组
        for(j=0; j<G->vexnum; j++)
        {
            if(dist[j] > dist[v] + G->edges[v][j])
            {
                dist[j] = dist[v] + G->edges[v][j];
                path[j] = v;
            }
        }
    }
}
```

#### Floyd算法—各顶点之间最短路径

基本思想是：递推产生一个n阶方阵序列$A^{(-1)},A^{(0)},A^{(1)}, \cdots, A^{(n-1)}$，其中**$A^{(k)}[i][j]$表示从顶点$v_i$到$v_j$的路径长度，$k$为绕行第$k$个顶点的运算步骤**。初始时，对于任意两个顶点$v_i$和$v_j$，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则把$\infty$作为它们之间的最短路径长度。**以后逐步尝试在原路径中加入顶点$k(k=0,1,\cdots,n-1)$作为中间顶点。若增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替源路径**，算法描述如下：

定义一个n阶方阵序列$A^{(-1)},A^{(0)},A^{(1)}, \cdots, A^{(n-1)}$，其中
$$
A^{(-1)}[i][j]=dist[i][j] \\
A^{(k)}[i][j]=Min\{A^{(k-1)}[i][j], A^{(k-1)}[i][k]+A^{(k-1)}[k][j]\}, \quad k(k=0,1,\cdots,n-1)\\
若A^{(k-1)}[i][k]+A^{(k-1)}[k][j] \lt A^{(k-1)}[i][j]则更新A^{(k)}[i][j]=A^{(k-1)}[i][k]+A^{(k-1)}[k][j]且path[i][j]=k
\tag{1}
$$
故此**经过n次迭代后$A^{(n-1)}[i][j]$就是顶点$v_i$到$v_j$的最短路径，$A^{(n-1)}$保存了任意顶点之间的最短路径长度**，Path数组记录了中转结点，故输出最短路径实际上是一个递归过程

![image-20221009160722944](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20221009160722944.png)

伪代码如下：

```c
void printPath(int u, int v, int path[][MaxSize], int A[][MaxSize])
{
    if(A[u][v] == INF)
        return;
    else
    {
        if(path[u][v] == -1)
            // 输出边<u,v>
            print("%d", v);
        else
        {
            int mid = path[u][v];
            printPath(u, mid, path, A);
            printPath(mid, v, path, A);
        }
    }
}

void Floyd(MGraph *G, int path[][MaxSize], int A[][MaxSize])
{
    int i, j, k;
    // 对A和path初始化
    for(i=0; i<G->vexnum; i++)
    {
        for(j=0; j<G->vexnum; j++)
        {
            A[i][j] = G->edges[i][j];
            path[i][j] = -1;
        }
    }
    
    // 以k为中间点对所有顶点进行检查和修改
    for(k=0; k<G->vexnum; k++)
    {
        for(i=0; i<G->vexnum; i++)
        {
			for(j=0; j<G->vexnum; j++)
            {
                if(A[i][j] > A[i][k]+A[k][j])
                {
                    A[i][j] = A[i][k]+A[k][j];
                    path[i][j] = k;
                }
            }
        }
    }
}
```

![image-20220904181506538](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220904181506538.png)

- **时间复杂度$O(|V|^3)$**
- 空间复杂度$O(|V|^2)$

Floyd算法可以解决带负权值的图，但不能解决待负权值的回路图

### 有向无环图描述表达式

有向无环图(DAG)：一个有向图中不存在环

有向无环图时表述含有公共子式的表达式的有效工具，例如表达式$((a+b)*(b*(c+d))+(c+d)*e)*((c+d)*e)$可以用二叉树表示为

![image-20220904182955790](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220904182955790.png)

可见该树有重复部分，可以对其进行简化，生成一个无重复部分的有向无环图

![image-20220904183204584](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220904183204584.png)

> 1. 用有向无环图描述表达式$(x+y)((x+y)/x)$，需要的顶点个数至少是5个
>
>   ![image-20220904183809284](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220904183809284.png)
>
> 2. $((a+b)*(b*(c+d))+(c+d)*e)*((c+d)*e)$
>
> 	![image-20220905172459879](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220905172459879-1662369901718-1.png)

最简化有向无环图表示求解方法

1. 各操作数不重复地排成一排
2. 标出各运算符生效顺序
3. 按顺序加入运算符，注意分层
4. 自底向上逐层合并操作符

![image-20220905173113238](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220905173113238.png)

### 拓扑排序

**AOV网**：用顶点表示活动的图；用DAG(有向无环图)表示一个工程，顶点表示活动，有向边$<v_i,v_j>$表示活动$v_i$必须先于活动$v_j$进行

**拓扑排序**：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，称为该图的一个拓扑排序：

1. 每个顶点出现且仅出现一次
2. 若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到A的路径

或定义为：拓扑排序是对有向无环图的顶点的一种排序，它使得若存在一条从顶点A到顶点B的路径，则在排序中顶点B出现在顶点A的后面。**每个AOV网都有一个或多个拓扑排序序列**

**若一个有向图中的顶点不能排成一个拓扑序列，则断定该有向图含有顶点数目大于1的强连通分量**，为什么断定该有向图不能只是强连通图呢？因为只有一个顶点的图也是强连通图，所以不对

#### **拓扑排序实现(若图中所有的顶点入度都大于0，则图一定有回路)**

1. 从AOV网中选择一个没有前驱(入度为0)的顶点并输出
2. 从网中删除该节点和所有以它为起点的有向边
3. 重复1、2直到当前的AOV网为空或当前网中不存在无前驱的顶点为止

```c
int TopologicalSort(ALGraph G){
    InitStack(&S);						// 存储入度为0的顶点
    for(int i=0; i<G.vexnum; i++){
        if (indegree[i]==0)
        {
            Push(&S, i);				// 入度为0则压入
        }
    }
    int count = 0;
    while (!IsEmpty(S))
    {
        Pop(&S, &i);
        print[count++]=i;       		// 输出顶点i
        for (ArcNode *p = G.vertices[i].first; p; p = p->next)
            // 将所有i指向的顶点的入度减一，并且将入度减为0的顶点压入栈
        {
            int v=p->adjvex;
            if (!(--indegree[v]))
            {
                Push(&S, v);
            }
        }
    }
    return count<G.vexnum ? 0 : 1;		// 若排序失败(有回路)，则返回0；反之返回1
}
```

时间复杂度：使用邻接表$O(|V|+|E|)$，使用邻接矩阵$O(|V|^2)$

#### **逆拓扑排序**

每次删除出度为0的节点

##### 栈实现

```c
int ReverseTopologicalSort(ALGraph G){
    InitStack(&S);						// 初始化栈
    for(int i=0; i<G.vexnum; i++){
        if(outdegree[i]==0)
            Push(&S, i);
    }
    int count = 0;
    while(!IsEmpty(S)){
        Pop(&S, &i);
        print[count++]=i;
        for(p=G.vertices[i].first; p; p=p->next){
            int v = p.adjvex;
            if(!(--outdegree[v]))
                Push(&S, v);
        }
    }
    return count<G.vexnum ? 0 : 1;
}
```

这种方法使用邻接表(记录自己指向的节点)实现的时间复杂度为$O(|V|^2+|V||E|)$，使用邻接矩阵的时间复杂度$O(|V|^2)$，使用逆邻接表(记录指向自己的节点)的时间复杂度为$O(|V|+|E|)$

#### **使用DFS实现拓扑排序和逆拓扑排序**

对于有向无环图G中的任意节点$u$、$v$，它们之间的关系必然是下面三种之一

- 若节点$u$是节点$v$的祖先，则在调用DFS来访问$u$的过程中，必然会在访问$u$的函数结束前递归地对$v$调用DFS访问，即$v$的DFS函数结束时间必然先于$u$的DFS结束时间。

	从而可以考虑在DFS调用过程中设定时间标记，在DFS调用结束时，对各节点记时。因而，祖先的结束时间必然先于子节点的结束时间

- 若$u$是$v$的子孙，则$v$的结束时间必然大于$u$的结束时间

- 若$u$和$v$没有关系，则$u$和$v$的拓扑关系任意

从而按照结束时间大小，可以得到拓扑排序(从小到大)、逆拓扑排序(从大到小)

```c
// 找出各节点的结束时间
int visited[MAX_VERTEX_NUM];			// 访问标记数组
int time;								// 记录时间
int finishTime[MAX_VERTEX_NUM];			// 记录各节点结束访问时间

void DFSTraverse(Graph G){
    // 初始化各节点的访问状态
    for(int i=0; i<G.vexnum; i++)
        visited[i]=0;
    // 开始访问
    time = 0;
    for(int i=0; i<G.vexnum; i++){
        if(!visited[i]){
            DFS(G, i);
        }
    }
}
void DFS(Graph G, int v){
    visit(v);
    visited[v] = 1;
    for(int w=FirstNeighbor(G, v); w>=0; w=NextNeighbor(G, v, w)){
        if(!visited[w]){
            DFS(G, w);
        }
    }
    time++;
    finishTime[v]=time;
}

// 拓扑排序
void TopologicalSort(Graph G){
    // 获取各节点的结束访问时间
    DFSTraverse(G);
    // 对finishTime数组进行从小到大的排序;
    InsertSort(finishTime, G.vexnum);
    for(int i=0; i<G.vexnum; i++)
        printf("%d", finishTime[i]);
}

// 逆拓扑排序
void ReverseTopologicalSort(Graph G){
    // 获取各节点的结束访问时间
    DFSTraverse(G);
    // 对finishTime数组进行从大到小的排序;
    InsertSort(finishTime, G.vexnum);
    for(int i=0; i<G.vexnum; i++)
        printf("%d", finishTime[i]);
}
```

### 关键路径

#### AOE网

AOE网即带权有向图，以顶点表示事件，以有向边为活动，以边上权值表示活动开销

- 只有入度为0的顶点：开始顶点(源点)
- 出度为0的顶点：结束顶点(汇点)

![image-20220906182537235](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220906182537235.png)

性质

- 只有某顶点事件发生后，才能进行边上活动
- 只有在进入某顶点的所有活动都已结束时，事件才能开始

指一些活动可以并行进行

#### 关键路径

由源点到汇点可能有许多路径，**其中有最大路径长度的路径为关键路径，关键路径上的活动称为关键活动**

即工程完工最短时间为关键路径长度，关键活动延期则完成时间延迟

**概念**

- 事件$v_k$的最早发生事件$ve(k)$：所有从$v_k$开始的活动能开工的最早时间

- 活动$a_i$的最早开始时间$e(i)$：该活动弧起点所表示事件最早发生时间

- 事件$v_k$的最迟发生事件$vl(k)$：不影响完工前提下，事件$v_k$最迟开始时间

- 活动$a_i$的最迟开始时间$l(i)$：该活动终点所表示事件最迟发生事件与该活动所需时间之差

- 活动$a_i$的时间余量$d(i)=l(i)-el(i)$：不影响完工前提下的，活动$a_i$可以拖延的时间

	若$d(i)=0$即为关键路径

**步骤**

1. 按拓扑序列，依次求各顶点的$ve(k)$

	$ve(源点)=0$

	$ve(k)=Max\{ve(j)+Weight(v_j, v_k)\}, v_j为v_k任意前驱$

2. 按逆拓扑序列，依次求各顶点的$vl(k)$

	$vl(汇点)=vl(汇点)$

	$vl(k)=Min\{vl(j)-Weight(v_k,v_j)\},v_j为v_k任意后继$

3. 若边$<i,j>$表示活动$a_i$，则有 $e(i)=ve(k),l(i)=vl(j)-Weight(v_k,v_j)$

4. $d(i)=l(i)-e(i)$，若$d(i)=0$，则为关键活动

> ![image-20220906190559493](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220906190559493.png)

#### 特性

1. 关键活动耗时增加，整个工期增加
2. 关键活动耗时减少，整个工期减少
3. 关键活动缩短到一定程度后，关键活动可能变为非关键
4. 可能有多条关键路径，只加快一条并不能缩短工期，只有所有的都缩短才能缩短工期

# ==查找==

## 查找的基本概念

- 查找：在数据集合中寻找某种条件的数据元素的过程叫做查找
- 查找表(查找结构)：用于查找的数据集合称为查找表，他由同一类型的数据元素(或记录)组成
- 关键字：数据元素中**唯一**标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的

操作主要有两种，一是只查二是插入删除

1. 只有1，可以使用静态查找表，只关注查找速度
2. 1、2都有，使用动态查找表，除了查找速度还要关注插入、删除

**评价标准**

- 查找长度：在查找运算中，需要对比关键字的次数称为查找长度

- **平均查找长度(ASL)：所有查找过程中进行关键字比较次数的平均值—反应了查找算法复杂度**
	$$
	ASL= \sum_{i=1}^np_i*c_i
	\tag{1}
	$$
	$n$为查找表中记录的个数；$p_i$是查找第i个记录的概率，一般取$\frac{1}{n}$；$c_i$为找到第i个记录所需要进行比较的次数，即查找长度

评价查找算法效率时，通常考虑查找成功/查找失败两种情况的ASL

## 顺序查找、折半查找、分块查找

### 顺序查找

从头到尾查找，通常用于线性表

#### 实现

```c
// 顺序查找
int Search_Seq(SSTable ST, int key){
    int i;
    for (i = 0; i < ST.TableLen && ST.elem[i]!=key; i++);
    // 查找成功则返回，否则返回-1
    return i==ST.TableLen?-1:i;
}

// 顺序查找有哨兵版
int Search_Seq_Guard(SSTable ST, int key){
    ST.elem[0]=key;                 // 哨兵
    int i;
    for (i = ST.TableLen; ST.elem[i]!=key; i--);
    return i;                       // 查找成功为i，失败为0
}
```

成功ASL=$\frac{n+1}{2}$，失败ASL=$n+1$

#### 有序表的顺序查找

- 成功ASL=$\frac{n+1}{2}$
- 失败ASL=$\frac{1+2+\cdots+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}$

#### 查找判定树分析ASL

![image-20220907212224522](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220907212224522.png)

#### 被查找概率不同时优化方法(在有序表的基础上)

- 查找成功概率大：被查概率大的放前面
- 查找失败概率大：有序表

### 折半查找

仅适用于有序的顺序表，因为其支持随机访问

#### 思想

使用三个指针，初始化low=1，high=TableLen；mid=(low+high)/2;（默认0位置不放数据）

看key和Table[mid]的大小

- $key \lt Table[mid]$：key在mid左边，故$high=mid-1; mid=(low+mid)/2$
- $key > Table[mid]$：key在mid右边，故$low=mid+1; mid=(low+mid)/2$
- 重复上述循环，若存在$key=Table[mid]$则成功，若$key!=Table[mid]\&\&low>high$则失败

#### 实现

```c
// 折半查找，基于有序表
int Binary_Search(SSTable ST, int key){
    int low=1, high=ST.TableLen, mid;
    while (low <= high)
    {
        mid = (low+high)/2;
        if(ST.elem[mid] == key) return mid;
        else if (ST.elem[mid] < key) low = mid + 1;
        else high = mid -1;
    }
    return -1;
}
```

#### 查找效率分析

对于数组$\{7,10,13,16,19,29,32,33,37,41,43\}$

![image-20220907214850647](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220907214850647.png)

#### 查找判定树的构造

- 如果当前low和high之间有奇数个元素，则mid分隔后，左右两部分元素个数相等

	若当前low和high之间有偶数个元素，则mid分隔后，左半部分比右半部分少一个元素

- 故折半查找的判定树中，若$mid=\lfloor (low+mid)/2 \rfloor$，则对于任意一个节点，必有$右子树结点数-左子树结点数=0或1$

判定树一定是平衡树，只有最下面一层不满，故n个元素的查找判定树平均查找长度为$ASL=\log_2(n+1)$

#### 查找效率

时间复杂度为$O(\log_2(n))$，但**折半查找不一定比顺序查找好**

### 分块查找

#### 思想

将查找表分为若干子块。**块内的元素可以无需，但块间是有序的**，即第一个块中的最大关键字小于第二个块中的所有记录的关键字，以此类推。再建立一个索引表，索**引表中的每个元素含有各块的最大关键字和各块中的第一个元素的位置，索引表按关键字有序排列**

#### 算法过程

- 在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表
- 在块内顺序查找

![image-20220908172447642](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220908172447642.png)

```c
// 索引表
typedef struct {
    int maxValue;
    int low, high;
}Index;
```

Note：**若使用折半查找查找索引表时，索引表在不包含目标关键字的情况下，则折半查找会停留在low>high，则此时在low指针所指位置开始查找，若low超出索引表长度则一定查找失败**

#### 查找效率分析

**分块查找的平均查找长度为索引查找和块内查找的平均长度之和**。设索引查找和块内查找的平均查找长度为$L_I,L_S$，则分块查找的平均查找长度为$ASL=L_I+L_S$

- 将长度为n的查找表均匀地分为b块，每块有s个记录，在等概率情况下，若在块内和索引表都使用顺序查找，则平均查找长度为
	$$
	ASL=L_I+L_S=\frac{b+1}{2}+\frac{s+1}{2}=\frac{\frac{n}{s}+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}
	\tag{1}
	$$
	若此时$s=\sqrt{n}$，则此时平均长度取最小值$\sqrt{n}+1$；

- 若对索引表采用折半查找时，则平均查找长度为
	$$
	ASL=L_I+L_S=\lceil \log_2(b+1) \rceil+\frac{s+1}{2}
	\tag{2}
	$$

## 树型查找

### 二叉排序树(BST)/平衡二叉树(AVL)

见树一章节

#### 判断一个查找序列是不是二叉排序树的查找序列

例如，给定一个值60，在二叉排序树上寻找关键字值为60的结点时，访问的关键字值序列S={20，30，90，80，40，50，70，60}。若将S分为两个子序列，S1所包含的都是小于或等于60的数据，S1={20，30，40，50，60}；S2所包含的都是大于60的数据，S2={90，80，70}。如此可得判断是否是查找序列的原则:如果从S所生成的S1单调递增，S2单调递减，且除待查元素外，S1中的每个数据都小于给定值，S2中的每个数据都大于给定值，则S是一个查找序列，否则不是查找序列。算法描述如下:

```c
typedef struct 
{
    int elem[MaxSize];
    int len
}Sequence;

void reduce(Sequence *S, Sequence *S1, Sequence *S2)
{
    int i=0, j=0, k=0;
    while(i < S.len-1)
    {
        while(i < S.len-1 && S.elem[i] < S.elem[i+1])
            S1.elem[j++] = S.elem[i++];
        while(i < S.len-1 && S.elem[i] > S.elem[i+1])
            S2.elem[k++] = S.elem[i++];
    }
    S1.len = j;
    S2.len = k;
}

int judge(Sequence *S1, Sequence *S2, int x)
{
    int i=0, flag=1;
    while(i < S1.len-1 && flag)
    {
        if(S1[i] > S1[i+1] || S1[i] > x)
            flag = 0;
        else
            i++;
    }
    i = 0;
    while(i < S1.len-1 && flag)
    {
        if(S1[i] < S1[i+1] || S1[i] < x)
            flag = 0;
        else
            i++;
    }
    return flag;
}

int issearch(Sequence *S, Sequence *S1, Sequence *S2, int x)
{
    reduce(S, S1, S2);
    return judge(S1, S2, x);
}
```

### B树

#### ==概述==

B-树，是一种多路自平衡搜索树

类似于普通的平衡二叉树，不同的是**B-树允许每个节点有多个子节点**，**B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示**。一棵m阶B树**或为空树，或为满足如下特性的m叉树**：

1. **树中每个结点至多有m棵子树**，即至多含有m-1个关键字

2. **若根节点不是终端结点，则至少有两颗子树**

3. **除根结点外的所有非叶结点至少有$\lceil m/2 \rceil$棵子树，即至少有$\lceil m/2 \rceil-1$个关键字**

4. **所有的叶节点都出现在同一层次上，并且不带信息**(可以视为外部结点或者类似于折半查找判定树的查找失败结点，**实际上这些结点不存在，指向这些结点的指针为空**)

5. 所有非叶结点的结构如下

	|  n   | $P_0$ | $K_1$ | $P_1$ | $K_2$ | $P_2$ | $\cdots$ | $K_n$ | $P_n$ |
	| :--: | :---: | :---: | :---: | :---: | :---: | :------: | :---: | :---: |

	其中，$K_i(i=1,2,\cdots,n)$为结点的关键字，且满足$K_1 \lt K_2 \lt \cdots \lt K_n$；$K_i(i=0,1,2,\cdots,n)$为指向子树根节点的指针，且**指针$P_{i-1}$所指子树中所有结点的关键字均小于$K_i$，$P_{i}$所指子树中所有结点的关键字均大于$K_i$，$n(\lceil m/2 \rceil-1 \le n \le m-1)$为结点中关键字的个数**

> B-树**专门为外部存储器设计，如磁盘，对读取/写入大块文件有良好性能，多用于文件系统/数据库**
>
> 一般的树在文件大时，大部分数据只能存在磁盘上，且逻辑上相近的节点可能相距很远(局部性不好)

![image-20220908180631795](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220908180631795.png)

**特点**

1. 所有键值分布在整棵树中
2. 任何一个关键字出现且只能出现在一个节点中
3. **搜索可能在非叶子节点结束，最好是$O(1)$**
4. 在关键字全集内进行一次查找，**性能逼近二分查找**

**m阶B树的核心特性**

1. 根节点的子树数$\in [2, m]$，关键字数$\in [1, m-1]$

	其他结点的子树数$\in [\lceil m/2 \rceil,m]$；关键字数$\in [\lceil m/2 \rceil-1,m-1]$

2. 对任一结点，其**所有子树高度都相等**

3. 关键字的值：$子树0\lt关键字1\lt子树1\lt \cdots$

#### 设计

**索引的效率依赖于磁盘I/O的次数，快速索引需要有效的减少磁盘I/O次数**

平衡二叉树是每次将范围分割成两个区间。为了更快，**B-树每次将范围分割为多个区间，区间越多，定位数据越快越准确。那么如果节点为区间范围，每个节点就较大了**

故**新建节点时，直接申请页大小的空间，计算机内存分配按页对齐，这样就实现了一个节点只需要一次I/O**

**pros**：

- 高度低，查找速度高
- 一般层数为3，层数越少，每个节点区间越精确，范围缩小越快
- 每个节点都是有序序列

#### 查找

假设每个节点都有n个key值，被分隔为n+1个区间，注意，每个key值紧跟着data域，即B-树的key和data是聚合在一起的。

**一般而言，根节点都在内存中，B-树以每个节点为一次磁盘I/O**

比如下图中，若搜索key为25节点的data，首先在根节点进行**二分查找**(因为keys有序，二分最快)，判断key25小于key50，所以**定位到最左侧的节点，此时进行一次磁盘I/O，将该节点从磁盘读入内存**，接着继续进行上述过程，直到找到key为止

![image-20220909172854922](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220909172854922.png)

```c
Data *BTreeSearch(Root *node, Key key){
    Data *data;
    
    if(root == NULL)
        return NULL;
    data = BinarySearch(node,key);
    if(data->key == key)
        return data;
    else{
        node = ReadDisk(data->next);
        BTreeSearch(node, key)
    }
}
```

> 1. m叉搜索树中，规定根节点的子树数$\in [2, m]$，关键字数$\in [1, m-1]$
>
> 	其他结点的子树数$\in [\lceil m/2 \rceil,m]$；关键字数$\in [\lceil m/2 \rceil-1,m-1]$
>
> 2. 所有子树高度相同
>
> 1.2都有则为B-树，无一个就是m叉查找树

#### ==最小高度、最大高度==

> 一般B-树的叶节点不算高度

n个节点的m阶B-树

最小高度：所有节点尽可能满，故每个节点m-1个关键字，m个分支
$$
\because (m-1)*(1+m+ \cdots +m^{h-1}) \ge n \\
\therefore (m-1)*\frac{1*(1-m^h)}{1-m} \ge n \\
\therefore m^h-1 \ge n \quad \therefore h \ge \log_m(n+1)
\tag{1}
$$
最大高度：让每个节点尽可能少，故根节点1个，其他$\lceil m/2 \rceil - 1$个

故第一层1个节点，第二层2个，第三层$2* \lceil m/2 \rceil$个，以此类推，第h层有$2* {\lceil m/2 \rceil}^{h-2}$个节点

此处设$k =  \lceil m/2 \rceil$
$$
1+2(k-1)+2k*(k-1)+ \cdots 2k^{h-2}*(k-1) \le n \\
1+2*(k-1)*\frac{1*(1-k^{h-1})}{k-1} \le n \\
1+2(k^{h-1}-1) \le n \\
h \le \log_k(\frac{n+1}{2})+1
\tag{2}
$$

$$
\because h+1层有2k^{h-1}个节点 \\ 
又\because n个关键字必有n+1个失败节点 \\
\therefore n+1 \ge 2k^{h-1} \quad \therefore h \le \log_k(\frac{n+1}{2})+1
\tag{3}
$$

总之，**最小高度为$h \ge \log_m(n+1)$，最大高度为$h \le \log_{\lceil m/2 \rceil}(\frac{n+1}{2})+1$**

#### 插入

> 例如5阶B树，关键字个数为$\lceil m/2 \rceil-1 \le n \le m-1$
>
> 25、38、49、60、80、90、99、88、83、87、70、92、93、94
>
> ![image-20220909180533986](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220909180533986.png)

每次插到终端节点，通过查找来找到插入位置

一旦超过关键字上限，则从中间位置$\lceil m/2 \rceil$将**其中关键字分为两部分，左半部分放在源节点中，右部分放在新节点中，中间位置$\lceil m/2 \rceil$的关键字放在原节点的父节点**

若此时父节点中关键字也超过了上限，则继续分裂，**直到过程传到根节点为止，进而导致高度+1**

#### 删除

![image-20221111195909864](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20221111195909864.png)

若被删除关键字在终端节点，则直接删除关键字(关键字多于$\lceil m/2 \rceil-1$)

![image-20221111195922597](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20221111195922597.png)

若被删除关键字在非终端节点，则找出该值直接前驱(左侧指针最右下)或直接后继(右侧指针最左下)来代替该关键字

若被删除节点关键字少于$\lceil m/2 \rceil-1$

- 兄弟够借：若被删除关键字所在节点删除前的关键字个数低于下限，且与此节点右(或左)兄弟节点关键字个数还很宽裕，则需要调整该节点、右(或左)兄弟节点及其双亲结点

  ![image-20221111195934796](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20221111195934796.png)

- 兄弟不够借：若被删除关键字所在结点删除前的关键字个数低于下限，且此时与该节点相邻的左右兄弟节点关键字个数均$=\lceil m/2 \rceil-1$，则将关键字删除后与左(或右)兄弟节点及双亲节点中的关键字进行合并

	![image-20221111195949846](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20221111195949846.png)

	在合并过程中，双亲结点中关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0，则直接将根节点删除，合并后的新结点成为根；若双亲结点不是根结点，且关键字个数减少到$\lceil m/2 \rceil-2$，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直到符合B-树的要求为止

### B+树

多用于MySQL索引，与分块查找类似

#### 概念

1. 每个分支结点最多m棵子树
2. **非叶根结点点至少有两颗子树**，其他每个分支结点至少有$\lceil m/2 \rceil$棵子树
3. **结点子树个数与关键字个数相等**
4. 所有**叶结点包含全部关键字**及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且**相邻叶节点按大小顺序相互连接起来**
5. **所有分支结点仅包含子节点中关键字最大值及指针**

![image-20220911174441652](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220911174441652.png)

#### 查找

- 树型查找

	B+树中，无论查找成功与否，最终都一定查到最下面一层；而B树可能停在中间一层

- 顺序查找

	顺序查找叶子结点

#### B+树与B树区别

| B+树                                                         | B树                                                          |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 结点中n个关键字对应n棵子树                                   | 结点中n个关键字对应n+1棵子树                                 |
| 根结点关键字个数$n \in [1, m]$，其他结点关键字个数$n \in [\lceil m/2 \rceil, m]$ | 根结点关键字个数$n \in [1, m-1]$，其他结点关键字个数$n \in [\lceil m/2 \rceil-1, m-1]$ |
| 叶子结点包含所有关键字，非叶子节点中所有值都会出现在叶子中   | 各节点关键字不重复                                           |
| 叶子节点包含信息，所有非叶子节点仅有索引作用                 | B树结点中都包含关键字对应记录的存储为止                      |

- B+树优点：**在B+树中，非叶节点不含有该关键字对应记录的存储地址；可以使一个磁盘可以包含更多个关键字，使B+树的阶更大，树高更矮，读磁盘次数更少，查找更快**

### 红黑树

#### 定义

一颗红黑树是满足如下红黑性质的二叉排序树：

1. 每个节点或是红色，或是黑色
2. 根节点为黑色
3. 叶节点(虚拟的外部节点，NULL节点)都是黑色的
4. 不存在两个相邻的红节点(即红节点的父节点和子节点都是黑色的)
5. 对每个结点，从该节点到任一叶节点的简单路径上，所含黑结点数量相同

**从某节点出发(不含该结点)到达一个叶节点的任一简单路径上的黑节点总数成为该结点的黑高**，根结点的黑高就是红黑树的黑高

**结论一：从根到叶节点的最长路径不大于最短路径的2倍**

- 由性质5，当从根到任一结点的简单路径最短时，该路径全由黑结点组成；由性质4，当从根到任一结点的简单路径最长时，该路径由红黑结点交替组成，此时红节点个数等于黑节点个数

**结论二：有n个内部结点的红黑树的高度$h \le 2\log_2(n+1)$**

- 由结论1可知，从根到叶节点(不含叶节点)的任意一条简单路径上都至少有一半是黑节点，因此根结点的黑高至少为$\frac{h}{2}$，于是有$n \ge 2^{\frac{h}{2}}-1$，故$h \le 2\log_2(n+1)$

若插入删除操作较少，查找频率高，则使用AVL树，否则使用红黑树

应用：C++中的map和set、Java中的TreeMap和TreeSet

#### 插入

**结论3：新插入红黑树中的结点初始着为红色**(方便调整)

设结点z为新插入的结点，插入过程描述如下：

1. 用二叉查找树插入法插入，并将结点z着为红色。==若结点z的父节点是黑色的，无须做任何调整==

2. ==若结点z是根结点，则z着为黑色==

3. 若**z不是根节点，并且z的父节点z.p是红色**的，则**分为下面三种情况，区别在于z的叔结点y的颜色不同**，因为z.p为红色的，插入前的树是合法的。根据性质2和4，**爷结点z.p.p必然存在且为黑色。**性质只在z和z.p之间被破坏了

	==**情况1：z的叔结点y是黑色的，且z是一个右孩子**==

	情况1(**LR，先左旋再右旋**)，即z是爷结点的左孩子的右孩子。**先做一次左旋将此情况转变为情况2(变为情况2后再做一次右旋)，左旋后z和父结点z.p交换位置**。因为z和z.p都是红色的，所以左旋操作对结点的黑高和性质5都没有影响

	==**情况2：z的叔结点y时黑色的，且z是一个左孩子**==

	情况2(**LL，右单旋**)，即z是爷结点的左孩子的左孩子。**做一次右旋，并交换z的原父节点和原爷结点的颜色**，就可以保持性质5，也不会改变树的黑高，这样调整就结束

	![image-20220911215540922](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220911215540922.png)

	若父节点z.p是爷结点z.p.p的右孩子，则还有两种对称的情况：RL(先右旋再左旋)和RR(右单旋)

	**==情况3：如果x的叔结点y是红色==**

	z的父结点z.p和叔结点y都是红色的，因为爷结点z.p.p是黑色的，**将z.p和y都着为黑色，将z.p.p着为红色，以在局部保持性质4和5**。**然后把z.p.p作为新结点z来重复循环**，指针z在树上上移两层

	![image-20220911220043454](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220911220043454.png)

	若父节点z.p是爷结点z.p.p的右孩子，也还有两种对称的情况

	只要满足情况3的条件，就会不断循环，每次指针z都上移两层，直到满足2(即z上移到根结点)或情况1或情况2的条件

	> 每颗子树$T_1、T_2、T_3、T_4$都有一个黑色根节点，且有相同的黑高

#### 删除

红黑树的插入容易导致连续的两个红结点，破坏性质4。而删除操作容易导致子树黑高的变化，破坏性质5

删除过程也是先执行二叉树的删除方法。若**待删结点有两个孩子**，不能直接删除，而**要找到该结点的中序后继(或前驱)填补，即右子树中最小结点，然后转换为删除该后续结点**。由于后续结点至多只有一个孩子，这样就**转换为待删结点是叶节点或仅有一个孩子的情况**

最终，删除一个结点有以下两种情况

- 待删结点没有孩子
- 待删结点只有右子树或左子树

1. 如果**==待删结点只有右子树或左子树==**，则只有两种情况

	![image-20220912173306249](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220912173306249.png)

	子树只有一个结点，且必须是红色，否则会破坏性质5

2. 如果**==待删结点没有孩子，若该结点是红色的==**，则直接删除

3. 如果**==待删结点没有孩子，且该结点是黑色的==**

	假设待删节点为y，x是用来替换y的结点(注意，当y是终端节点时，x为黑色的NULL结点)。**删除y后将导致先前包含y的任何路径上的黑节点数量减1，因此y的任何祖先都不满足性质5，简单的修正方法就是将替换y的结点x视为还有额外一重黑色，定义为双黑结点。**于是，删除操作的任务就转化为将双黑结点恢复为普通结点

	分为以下**四种情况**，**区别在于x的兄弟结点w及w的孩子结点的颜色不同**

	**==情况1：x的兄弟结点w是红色的==**

	情况1，w必须有**黑色左右孩子和父结点**。**交换w和父节点x.p的颜色，然后对x.p做一次左旋，而不会破坏红黑树的任何规则。现在x的新兄弟结点时旋转之前w的某个孩子结点，其颜色为黑色**，这样，就将情况1转化为情况2、3或4处理

	![image-20220912174459328](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220912174459328.png)

	**==情况2：x的兄弟结点w是黑色的，w的左孩子是红色的，w的右孩子是黑色的==**

	情况2**(RL，先右旋再左旋)**，**即红节点是其爷节点的右孩子的左孩子**。**交换w和其左孩子的颜色，然后对w进行一次右旋**。现在x的新兄弟节点w的右孩子是红色的，这样就把情况2转换为了情况3

	![image-20220912175037406](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220912175037406.png)

	**==情况3：x的兄弟结点w是黑色的，w的右孩子是红色的==**

	情况3(RR，右单旋)，即红节点是其爷节点的右孩子的右孩子。**交换w和父节点x.p的颜色，把w的右孩子着为黑色，并对x的父节点x.p进行一次左旋，将x变为单重黑色即可**

	![image-20220912175407342](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220912175407342.png)

	**==情况4：x的兄弟节点w是黑色的，且w的两个孩子节点都是黑色的==**

	情况4中，**因为w也是黑色的，故可以从x和w上去除一重黑色，使x只有一重黑色而w变为红色。为了补偿从x和w中去除的一重黑色，把x的父节点x.p额外着一层黑色，以保持局部的黑高不变。通过将x.p作为新节点x来循环，x上升一层**。如果是通过情况1进入情况4的，因为原来的x.p是红色的，将新节点变成黑色，终止循环

若x是父节点x.p的右孩子则还有对称的4种情况，只有情况4会向上走，至多$O(\log_2(n))$次

## 散列表

### 概念

散列表(哈希表)：数据元素的关键字与其存储地址直接相关；通过哈希函数联系起来

同义词：若不同的关键字通过散列函数映射到同一个值

冲突：通过散列函数确定的位置已经存放了其他元素

**装配因子：$\alpha=\frac{表中记录数}{散列表长度}$，会影响散列表的查找效率**

**提高查找效率方法**

1. 设计冲突少的散列函数(由于处理冲突时不可能避免出现聚集现象，故不选)

### 解决冲突

#### 拉链法

把所有同义词存储在一个链表中

查找过程

1. 计算查找位置
2. 顺序查找

理论上存在$O(1)$

![image-20220912212731416](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220912212731416.png)

#### 开放定址法

可存放新表项的空闲地址既向其同义词开放，也向非同义词开放

冲突处理函数如下
$$
H_i=(H(key)+d_i)\%m
\tag{1}
$$
$m$为表长，$d_i$为增量序列，$i$为第$i$次发生冲突

一般来说增量序列有三种求法，**线性探测法，平方探测法和伪随机序列法**

##### 线性探测法

$d_i=0,1,2,3,\cdots,m-1$，每次看下一个是否为空

查找时同义词，非同义词都需要检查，查空也要数一次比较(查到空一定无)；删除时若直接删除，可能会让一些数查找失败，可以做一个逻辑删除

**易造成同义词非同义词的聚集现象，影响查找效率**，原因是冲突后再探测一定在一个聚集的地方

![image-20220912214626396](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220912214626396.png)

##### 平方探测法

$d_i=0^2,1^2,-1^2,2^2,-2^2,3^2,-3^2,\cdots,k^2,-k^2$，也称二次探索法，$k \le \frac{m}{2}$

同义词不容易聚集，**散列长度必须为$4j+3$的素数才能探测到所有位置**

##### 伪随机序列法

$d_i$为一个随机序列

#### 再散列法

多准备几个散列函数，冲突时用下一个散列函数，直到不冲突

### 散列函数

1. 除留余数法：$H(key)=key\%p$

	列表长度为$m$，取一个不大于$m$的质数$p$，一般取$p$的效果最好

2. 直接定址法：$H(key)=key$或$H(key)=a*key+b$

	适合关键字的分布基本连续，否则存储空间会浪费

3. 数字分析法：选取数码分布较均匀的若干位作为散列地址

	![image-20220912215534489](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220912215534489.png)

4. 平方取中法：取关键字的平方值的中间几位作为散列地址

	![image-20220912215645056](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220912215645056.png)

以空间换时间，只要散列函数合理，则散列表越长，冲突概率越低

# ==排序==

## 排序的基本概念

排序(Sort)：重新排列表中的元素，使表中的元素满足**按关键字有序**的过程

稳定性：两个相同的key，排序后可**保证两者相对位置不变**，则该排序算法稳定，反之不稳定

**分类**

- 内部排序：数据都在内存，关注如何让算法复杂度更低
- 外部排序：数据过多无法都放进内存，不仅关注算法复杂度还要关注如何让读写盘数少

Note：**n个元素排序至少要进行$\lceil \log_2(n!) \rceil$次两两排序**

> 在基于比较的排序方法中，每次比较两个关键字后，仅出现两种可能的转移。
>
> 假设整个排序过程至少需要做t次比较，则显然会有$2^t$种情况
>
> 由于n个记录共有$n!$种不同的排列，因此有$n!$种不同的比较路径，于是有$2^t \ge n!$，即$t \ge \log_2(n!)$，又因为t为整数，故为$\lceil \log_2(n!) \rceil$

## 插入排序

### 直接插入排序

每次将一个待排序的记录按其关键字大小插到前面已排好的子序列中，直到全部记录插入完成

```c
void InsertSort(int A[], int n){
    int i, j, temp;
    for(i = 1; i < n; i++){
        if(A[i] < A[i-1]){
            temp = A[i];
            for(j = i-1; j >= 0 && A[j] > temp; j--)
                A[j+1] = A[j];
            A[j+1]=temp;
        }
    }
}
```

时间复杂度：n个元素需要n-1次处理

- 最好情况下原数组已经有序，$O(n)$
- 最坏情况下元素组倒序，$O(n^2)$
- 平均情况：$O(n^2)$

空间复杂度：$O(1)$

稳定性：稳定

### 折半插入排序

先用折半查找方法找到应插入的位置，在插入元素

$low \gt high$时折半查找结束，将$[low,i-1]$元素全部右移，并将temp复制到$high+1$所指位置

$A[mid]=temp$时，为了稳定性，应继续在mid所指后边找插入位置

```c
// 折半查找插入排序(无哨兵)
void HalfFindInsertSort(int A[], int n){
    int i, j, low, mid, high, temp;
    for (i = 1; i < n; i++)
    {
        temp = A[i];
        low = 0, high = i - 1;
        while (low <= high)
        {
            mid = (low + high) / 2;
            if(A[mid] > temp) high = mid - 1;
            else low = mid + 1;
        }
        for(j = i-1; j >= low; j--)
            A[j+1] = A[j];
        A[low] = temp;
    }
}

// 折半查找插入排序(哨兵)
void HalfFindInsertSort_Guard(int A[], int n){
    int i, j, low, mid, high;
    for (i = 2; i <= n; i++)
    {
        A[0] = A[i];
        low = 1; high = i-1;
        while (low <= high)
        {
            mid = (low + high) / 2;
            if (A[mid] > A[0]) high = mid - 1;
            else low = mid + 1;
        }
        for (j = i-1; j >= low; j--)
            A[j+1] = A[j];
        A[low] = A[0];
    }
}
```

比较次数减少，但移动次数还是不变，故还是**$O(n^2)$**

> 对链表可以使用插入排序，移动元素次数减少，但关键字比较次数不变，还是$O(n^2)$

### 希尔排序

**先追求表中部分有序，在逼近全局有序**

基本思想：先将待排序分别分割成若干形如$L[i,i+d,i+2d, \cdots, i+kd]$的特殊子表，即把相隔某个增量的记录组成一个子表，对各个子表分别直接插入排序，当整个表中的元素已呈基本有序时，再对全体记录进行一次直接插入排序

![image-20220914182636674](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220914182636674.png)

```c
// 希尔排序
void ShellSort(int A[], int n){
    int d, i, j;
    for(d = n/2; d >= 1; d = d/2){
        for (i = d; i < n; i++)
        {
            if(A[i] < A[i-d])
            {
                int temp = A[i];
                for (j = i-d; j>=0 && A[j]>temp; j-=d)
                    A[j+d] = A[j];
                A[j+d] = temp;
            }
        }
    }
}
```

一般每次减少一半

时间复杂度：

- **一般来说$O(n^{1.3})$**
- 最坏情况下$O(n^2)$

空间复杂度：$O(1)$

稳定性：不稳定

**只适用于顺序表**

## 交换排序

### 冒泡排序

从后往前(或从前往后)两两比较相邻元素的值，若为逆序即$A[i-1]>A[i]$，则交换它们，直到序列比较完，这样的序列为一趟冒泡排序，总共n-1趟

最小的元素交换到待交换序列第一个位置，元素位置就一定不变了

之前已确认位置元素可以不用对比，若某一次没有发生交换，则此时已整体有序

```c
// 冒泡排序
void BubbleSort(int A[], int n){
    for (int i = 0; i < n-1; ++i) {
        int flag = 0;
        for (int j = n-1; j > i ; j--) {
            if (A[j-1] > A[j]){
                swap(&(A[j-1]), &(A[j]));
                flag = 1;
            }
        }
        if (!flag) {
            return;
        }
    }
}
```

时间复杂度

- 最好情况是数组基本有序，$O(n)$
- 最坏情况是数组逆序，$O(n^2)$
- 比较次数=交换次数=$\frac{n(n-1)}{2}$
- 平均情况$O(n^2)$

空间复杂度$O(1)$

稳定性：稳定

可用于链表

### 快速排序

快速排序是**所有内部排序的最优解**

基本思想：在待排序表$L[1 \dots n]$中任取一个元素pivot作为枢轴(或基准，通常取首元素)，通过一趟排序将待排序表划分为独立的两部分$L[1 \dots k-1]$和$L[k-1 \dots n]$，使得$L[1 \dots k-1]$中的所有元素小于pivot，$L[k-1 \dots n]$中所有元素大于pivot，则pivot放在了最终位置$L[k]$上，这个过程称为一次划分。然后分别递归地对两个子表重复上述过程，直至每部分内只有一个元素或空为止，即所有元素放在了其最终位置上

```c
int Partition(int A[], int low, int high){
    int pivot = A[low];
    while(low < high){
        if(low<high && A[high]>pivot) --high;
        A[low] = A[high];
        if(low<high && A[low]<pivot) ++low;
        A[high] = A[low];
    }
    A[low] = pivot;
    return low;
}

void QuickSort(int A[], int low, int high){
    if(low < high){
        int pivotpos = Partition(A, low, high);
        QuickSort(A, low, pivotpos - 1);
        QuickSort(A, pivotpos + 1, high);
    }
}
```

**Partition的时间复杂度为$O(n)$，QuickSort的时间复杂度为$O(\log n)$**

时间复杂度

- 最好情况：每次枢轴都能把表分成两大小相等的部分，$O(n \log n)$
- 最坏情况：原本就有序，$O(n^2)$

空间复杂度

- 最好情况：$O(\log n)$
- 最坏情况：$O(n)$

稳定性：不稳定

> 快速排序比较次数
>
> - 最优比较次数
>
> 	对于长度为n的快排，最好情况下会让数组分成两部分故，比较次数$A_n=A_{前一半}+A_{后一半}+n-1$，例如长度为9的快排，则其最优比较次数为
> 	$$
> 	A_{9} = A_4+A_4+8 = 4+4+8=16 \\
> 	A_4 = A_1+A_2+3 = 0+1+3 = 4 \\
> 	A_1 = 0 \\
> 	A_2 = 1 \\
> 	\tag{1}
> 	$$
>
> - 最差比较次数
>
> 	易得最差时原序列就有序，比较次数为$1+2+3+ \cdots + n-1 = \frac{n(n-1)}{2}$

> 408中，对所有尚未确定最终位置的所有元素进行一遍处理称为一趟排序，因此一次划分不是一趟排序；一次划分可以确定一个元素最终位置，而一趟排序可能能确定多个元素最终位置
>
> 对快排来说，每一趟排序是一层调用

## 选择排序

### 简单选择排序

**每趟在待排序元素中选取最小的元素加入有序子序列**

```c
void SelectSort(int A[], int n){
    for(int i=0; i<n; i++){
        int min = i;
        for(int j=i+1; j<n; j++)
            if(A[i]>A[j])
                min = j;
        if(min != i) swap(&(A[i]), &(A[j]));
    }
}
```

时间复杂度

- 无论有序无需都有n-1趟处理，故$O(n^2)$

空间复杂度：$O(1)$

稳定性：不稳定

可用于顺序表，链表

### 堆排序

#### 堆概念

若n个关键字序列$L[1 \dots n]$满足下面某一条性质，则称为**堆(Heap)**：

- 若满足：$L[i] \ge L[2i]且L[i] \ge L[2i+1], \quad (1\le i \le n/2)$，则为大顶堆（大根堆）
- 若满足：$L[i] \le L[2i]且L[i] \le L[2i+1], \quad (1\le i \le n/2)$，则为小顶堆（小根堆）

故大顶堆父节点一定大于子节点、小顶堆父节点一定小于子节点

#### 堆排序思路

首先将存放在$L[1 \dots n]$中的n个元素建成初始堆，由于堆本身的特点(以大顶堆为例)，堆顶就是最大的元素。输出堆顶元素后，通常将堆底元素放在堆顶，此时需要重建堆，如此循环直到堆输出最后一个元素为止

#### 建立堆

1. 大顶堆

	检查所有非终端($i \le \lfloor n/2 \rfloor$)节点，是否满足大顶堆，不满足就调整，将当前节点与一个更大的孩子互换

	从$\lfloor n/2 \rfloor$开始筛选，使该子树成为堆。之后向前依次堆各节点($\lfloor n/2 \rfloor-1 到 1$)为根的子树进行筛选，看该节点值是否大于其左右子节点的值，若不大于，则用较大值交换，交换后可能破坏下一级的堆，于是采用上述方法构造下一级的堆，直到以该节点为根的子树构成堆为止。反复如此，直到根节点

	![image-20220915174534632](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220915174534632.png)

	```c
	// 建立大顶堆
	void BuildMaxHeap(int A[], int n){
	    // 从后往前建树
	    for(int i = n/2; i>0; i--)
	        HeadAdjust(A, i, n);
	}
	
	// 将以k为根的子树调整为大顶堆
	void HeadAdjust(int A[], int k, int len){
	    A[0] = A[k];				// 暂存
	    for(int i=2*k; i <= len; i*=2){
	        if(i<len && A[i]<A[i+1])
	            i+=1;
	        if(A[0] > A[i]) break;
	        else{
	            A[k] = A[i];		// 将A[i]放在双亲结点上
	            k = i;				// 修改k值，以便继续向下筛选
	        }
	    }
	    A[k] = A[0];				// 被筛选结点的值放入最终位置
	}
	```

	只有1~n-1层结点会下坠，故比较关键字次数$\le$4n
	
	建堆$O(\log_ n)$

**Note**：==在对n个元素进行建堆时，最少比较次数为$\log_2n$次，最多比较次数为$4n$次==

#### 堆排序算法

```c
void HeapSort(int A[], int n){
    BuildMaxHeap(A, n);
    for(int i=n; i>1; i--){
        Swap(A[i], A[1]);		// 和堆底元素交换
        HeadAdjust(A, 1, i-1);
    }
}
```

适合关键字较多的情况

时间复杂度为$O(n \log n)$

空间复杂度为$O(1)$

稳定性：不稳定

## 归并排序和基数排序

### 归并排序

归并：把两个或多个已有序序列合并成一个

2路归并：指合并两个有序序列，每选一个元素比较一次

n路归并：每选一个元素比较n-1次

![image-20220915211753742](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220915211753742.png)

```c
int *B=(int *)malloc(n*sizeof(int));			// 辅助数组
// A[low...mid]和A[mid+1...high]各自有序，将两个部分归并
void Merge(int A[], int low, int mid, int high){
    int i,j,k;
    for(k=low;k<=high;k++)
        B[k] = A[k];
    for(i=low, j=mid+1, k=i; i<=mid&&j<=high; k++){
        if(B[i]<=B[j])
            A[k] = B[i++];						// 将较小值复制到A中
        else
            A[k] = B[j++];
    }
    while(i<=mid) A[k++]=B[i++];
    while(j<=high) A[k++]=B[j++];
}

// 归并排序
void MergeSort(int A[], int low, int high){
    if(low < high){
        int mid = (low + high) / 2;
        MergeSort(A, low, mid);
        MergeSort(A, mid+1, high);
        Merge(A, low, mid, high);
    }
}
```

时间复杂度

- 归并次数$O(\log n)$，每次归并$O(n)$，归并次数$\lceil \log_2n \rceil$
- 故时间复杂度为$O(n \log n)$

空间复杂度

- O(n)

**稳定性：稳定**

### 基数排序

按照个位、十位、百位……来使用辅助队列排序

![image-20220915212824304](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220915212824304.png)d为位数，n为个数，r为取值范围数，d为分组数

![image-20220915213706001](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220915213706001.png)

- 时间复杂度$O(d(n+r))$
- 空间复杂度$O(r)$
- 稳定性：稳定

应用

1. 按出生年月日排序，日月年
2. 数据元素关键字可拆分成d组，d较小
3. 每组关键字取值范围不大，r较小
4. n较大

## 各种内部排序算法的比较和应用

|   算法种类   | 时间复杂度(最好) | 时间复杂度(平均) | 时间复杂度(最坏) | 空间复杂度  | 稳定性 |
| :----------: | :--------------: | :--------------: | :--------------: | :---------: | :----: |
| 简单插入排序 |      $O(n)$      |     $O(n^2)$     |     $O(n^2)$     |   $O(1)$    |  稳定  |
| 折半插入排序 |      $O(n)$      |     $O(n^2)$     |     $O(n^2)$     |   $O(1)$    |  稳定  |
|   希尔排序   |   $O(n^{1.3})$   |                  |     $O(n^2)$     |   $O(1)$    | 不稳定 |
|   冒泡排序   |      $O(n)$      |     $O(n^2)$     |     $O(n^2)$     |   $O(1)$    |  稳定  |
|   快速排序   |  $O(n \log n)$   |  $O(n \log n)$   |     $O(n^2)$     | $O(\log n)$ | 不稳定 |
| 简单选择排序 |     $O(n^2)$     |     $O(n^2)$     |     $O(n^2)$     |   $O(1)$    |  稳定  |
|    堆排序    |  $O(n \log n)$   |  $O(n \log n)$   |  $O(n \log n)$   |   $O(1)$    | 不稳定 |
| 2路归并排序  |  $O(n \log n)$   |  $O(n \log n)$   |  $O(n \log n)$   |   $O(n)$    |  稳定  |
|   基数排序   |   $O(d(n+r))$    |   $O(d(n+r))$    |   $O(d(n+r))$    |   $O(r)$    |  稳定  |

## 外部排序   

### 基本概念

数据过多，分布在内外存中，排序时需要多次进行内外存数据交换，即为外部排序

### 方法

#### 归并排序

**最少在内存中分配三个块大小的缓冲区，即可对任意大小的文件进行排序**

要求各子序列有序，每次读入两个块的内容，进行内部排序后写入磁盘

> 若原有16个块，则内存中归并排序分成8个有序子序列(归并段)，设每个段两个块，16次读、16次写(每次归并)
>
> ![image-20220915215450240](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220915215450240.png)

**归并排序时间=内部排序时间(将数据排序成几个有序块)+外存读写时间+内部归并时间(将有序块合并)**

故主要时间消耗在外存读写，其次是内部排序时间，最后是内部归并时间

一般的减少外存读写次数就能减少总的磁盘I/O次数

一般的，对r个初始归并段，做k路平衡归并，归并树可用严格k叉树(即只有度为k与度为0的结点的k叉树)来表示。第一趟可将r个初始归并段归并为$\lceil r/k \rceil$个归并段，以后每趟归并将m个归并段归并为$\lceil m/k \rceil$个归并段，直到最后形成一个大的归并段为止。树的高度-1=**$\lceil \log_kr \rceil$=归并趟数S**

可见**只要增大归并路数k，或减少初始归并段个数r，都能减少归并趟数S**，进而减少读写磁盘的次数，达到提高外部排序速度的目的

$r=N/L$，n个数，L内存能记录个数

- 增加k，使用败者树(减少内部排序比较次数)
- 减少r，使用置换—选择排序

#### 多路平衡归并

k路平衡归并

1. 最多只能有k个段归并为1个
2. 每趟归并中，若有m个归并段参与归并，则经过这一趟处理得到$\lceil m/k \rceil$个新的归并段

故如图4路归并不是4路平衡归并

![image-20220916163522863](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220916163522863.png)

#### ==败者树==

增加归并路数k时，内部归并的时间将增加。做内部归并时，在k个元素中选取关键字最小的记录需要比较k-1次。每趟归并n个元素需要做(n-1)(k-1)次比较，S趟归并需要的比较次数为
$$
S(n-1)(k-1)=\lceil \log_kr \rceil(n-1)(k-1)=\frac{\lceil \log_2r \rceil}{\lceil \log_2k \rceil}(n-1)(k-1)
\tag{1}
$$
故$(k-1)*\frac{1}{\lceil \log_2k \rceil}$随k增大而增大，**故内部排序时间随k增大而增大**。这将抵消由于增大k而减少外存访问次数所得到的效益。故不能使用普通的归并排序算法

故引入败者树

**败者树：可视为一颗完全二叉树(多了一个头头)。k个叶节点分别是当前参与比较的元素(每个叶子对应一个归并段)，非叶子结点用来记忆左右子树中的失败者，而让胜者往上继续比较，一直到根节点**。若比较两个数，大的为失败者，小的为胜利者，则根节点指向的数为最小值

1. **根节点记录冠军在哪个段**
2. 分支结点记录败者来自哪个段
3. 第一次构造败者树需要比较k-1次，有了败者树，选最小元素只需要对比$\lceil \log_2k \rceil$次
4. k路归并败者树只需定义一个长为k的数组即可，叶子结点可虚拟

![image-20220916165950745](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220916165950745.png)

 因为k路归并的败者树深度为$\lceil \log_2k \rceil$，因此k个记录中选择最小关键字，最多需要$\lceil \log_2k \rceil$次比较，所以总的比较次数为
$$
S(n-1)\lceil \log_2k \rceil=\lceil \log_kr \rceil(n-1)\lceil \log_2k \rceil=\lceil \log_2r \rceil(n-1)
\tag{2}
$$
故**使用败者树后，内部排序的比较次数与k无关，因此只要内存允许，增大归并路数k将减少归并树高度，从而减少I/O次数**。但如果k值过大，虽然归并次数减少，但缓冲区容量相对减少(可使用的内存大小不变)，因此读写内存次数仍会增加

#### ==置换–选择排序==

用来生成初始归并段，使每个初始归并段长度可以超越内存工作区大小

- 每个元素先放在输出缓冲区，等缓冲区满了再一次性读写一块，读入时也一次性读一块

设初始待排文件为FI，初始归并段输出文件为FO，内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。置换–选择排序的步骤如下：

1. 从FI中输入w个记录到工作区WA
2. 从WA中选出其中关键字最小值的记录，记为MINIMAX记录
3. 将MINIMAX记录输出到FO中
4. 若FO不空，则从FO输入下一条记录到WA中
5. **从WA中所有关键字比MINIMAX记录的关键字大的记录中选出最小关键字记录**，作为新的MINIMAX记录
6. 重复3~5步，直至在WA中选不出新的MINIMAX为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中
7. 重复2~6步，直到WA为空，由此得到全部的初始归并段

Note：**在WA中选择MINIMAX记录的过程需利用败者树来实现**

> ![image-20220916174951317](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220916174951317.png)

#### ==最佳归并树==

对于二叉归并树

- ![image-20220916175720661](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220916175720661.png)
- 即求出I/O次数对应的哈夫曼树就能有最少的I/O次数

若为多路归并树

如果初始归并段的数量无法构成严格的k叉归并树，则需要补充几个长度为0的虚段，在进行k叉哈夫曼树的构造

那到底要补充几个呢？

- 因为严格的k叉归并树树的度为0或k，故设度为k的结点有$n_k$个，度为0的结点有$n_0$个，总共有n个

	故$n=n_0+n_k$，且$kn_k+1=n$，故$kn_k+1=n_0+n_k$，故$n_0=(k-1)n_k+1$，**故$n_k=\frac{n_0-1}{k-1}$为整数**

- 若$(初始归并段数量-1) \%(k-1)=0$，说明刚好构成严格k叉树，不需要添加虚段

- 若$(初始归并段数量-1) \%(k-1)=u!=0$，则需要补充$(k-1)-u$个虚段

> 8路归并，有19个初始归并段，因为$(19-1) \% (8-1)=18 \% 7=4$，故补充$7-4=3$个虚段

### ==时间与空间复杂度相关问题==

#### 时间复杂度

外部排序的时间复杂度涉及很多方面，且分析较为复杂，一般不需要分析与时间复杂度相关的每一个细节，因此只需要注意以下几点即可：

1. m个初始归并段进行k路归并，归并的趟数为$\lceil \log_km \rceil$

2. 每一次归并，所有记录都要进行两次I/O操作，读出数据+写入结果

3. 置换–选择排序这一步中，所有记录都要进行两次I/O操作，从FO中读出，写入FI

4. 置换–选择排序中，选最值那一步的时间复杂度要根据考试要求的选择算法而定

5. k路归并的败者树高度为$\lceil \log_2k \rceil+1$，因此利用败者树从k个记录中选出最值需要进行$\lceil \log_2k \rceil$次比较，即时间复杂度为$O(\log_2k)$

6. k路归并败者树的建树时间复杂度为$O(k \log_2k)$

	Note：k路归并败者树，不是k叉败者树，是一颗二叉树，且高度不包含最上层选出的结点

#### 空间复杂度

上述所有算法的空间复杂度都是常量，故为$O(1)$

## 排序知识点小结

### 复杂度总结

#### 时间复杂度

最好情况下，简单插入排序、折半插入排序、冒泡排序的时间复杂度为$O(n^2)$，其他都和平均情况下相同

平均情况下，快速排序、归并排序、堆排序的时间复杂度为$O(n \log_2n)$，希尔排序的时间复杂度大致为$O(n^{1.3})$，其他排序的时间复杂度都为$O(n^2)$，除了基数排序，其时间复杂度为$O(d(n+r_d))$

最坏情况下，快速排序的时间复杂度为$O(n^2)$，其他都和平均情况下相同

#### 空间复杂度

快速排序为$O(\log_2n)$，归并排序为$O(n)$，基数排序为$O(r_d)$，其他都是$O(1)$

### 算法稳定性总结

**希尔排序、快速排序、简单选择排序、堆排序为不稳定的**，其他都是稳定的

### 其他细节

1. 经过一趟排序，能够保证一个关键字到达最终位置，这样的排序是交换排序的两种(冒泡排序和快速排序)以及选择排序的两种(简单选择排序和堆排序)

2. 排序算法的**关键字比较次数和原始序列无关的算法是—简单选择排序和折半插入排序**

3. 排序算法的**时间性能和待排序记录的初始状态无关的是—选择排序和归并排序**

4. 排序算法的**关键字比较次数和原始序列有关的算法是—交换类算法(冒泡排序和快速排序)**

5. 排序算法的**关键字移动次数和原始序列无关的算法是—基数排序**

6. 排序算法的**排序趟数与序列的原始状态无关的算法是—插入排序、简单选择排序和基数排序**

7. **再次比较直接插入排序和折半插入排序**

	二者最大的区别在于查找插入位置的方式不同。直接插入按顺序查找的方式，而折半插入按折半查找的方式

6. 若只想知道n个关键字组成的序列中第i个关键字之前的部分排序的序列，冒泡排序、简单选择排序、堆排序都可以满足，但堆排序最快

# 一些重要易错点

## 栈和队列

1. 入栈序列有n个值，则可能的出栈序列有$\frac{1}{n+1}C_{2n}^{n}$

2. 递归过程或函数调用时，处理参数及返回地址要用一种称为栈的数据结构

3. ==循环队列的一些条件==

	- 队满：$(rear+1) \% MaxSize = front$
	- 队空：$rear=front$
	- 队中元素个数：$(rear-front+MaxSize)\%MaxSize$
	- 入队：$front=(front+1)\%MaxSize$
	- 出队：$rear=(rear+1)\%MaxSize$

4. 用单链表(含有头节点)表示的队列的队头在链表的链尾和链头位置

	队列中的元素多于1时，队头在链表中的链中位置

	队列中的元素只有1个时，队头在链表中的链尾位置

5. 用单链表(含有头节点)表示的链队的队尾在链表的链尾位置

6. 若借助栈可由输入序列$1,2,3, \dots, n$得到一个输出序列$p_1,p_2,p_3, \dots, p_n$，则在输出序列中不可以出现以下情况：存在$i \lt j \lt k$，使得$p_j \lt p_k \lt p_i$

7. 假设以I和O分别表示入栈和出栈操作。若栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由I和O组成的序列，则称可以操作的序列为合法序列，否则称为非法序列

	==是否合法的一般规则==为：

	- 给定序列中，I的个数和O的个数相等
	- 从给定序列的开始到给定序列中的任一位置，I的个数要大于或等于O的个数

8. **运算符操作优先级**
	$$
	算术 \lt 位运算 \lt 关系运算符 \lt ! \lt \&\& \lt ||
	\tag{1}
	$$

9. 求n个不同字符的所有全排序列

	设perm(str,k-1,n)为str[0]到str[n-1]的所有全排序列

	则perm(str,k-1,n)处理比perm(str,k,n)少一个，若perm(str,k-1,n)可求，则perm(str,k-1,n)组合一个从str[0]到str[n]内任何值，则有perm(str,k,n)

	```c
	void perm(char str[], int k, int n){
	    int i;
	    char temp;
	    if(k==0)
	        printf("%s", str);
	    else
	    {
	        for(i=0; i<k; i++)
	        {
	            temp = str[k];
	            str[k] = str[i];
	            str[i] = temp;
	            perm(str, k-1, n);
	            temp = str[i];
	            str[i] = str[k];
	            str[k] = temp;
	        }
	    }
	}
	```


## 串

1. 串是一种特殊的线性表，其特殊性体现在其数据元素是一个字符

2. 串长为n，则包含空串和其本身的子串数目有$\frac{n(n+1)}{2}+1$
	$$
	长度为0的子串有1个 \\
	长度为n的子串有1个 \\
	长度为1的子串有n-(1-1)=n个 \\
	长度为2的子串有n-(2-1)=n-1个 \\
	\cdots
	长度为n-1的子串有n-(n-1-1)=2个 \\
	故子串共有\frac{n(n+1)}{2}+1个
	\tag{1}
	$$

3. **==KMP算法==**

	见一些重点算法第一个

	```c
	int Index_KMP(Str str, Str substr, int next[])
	{
	    int i=1, j=1;
	    while(i<=str.length && j<=substr.length)
	    {
	        if(j==0 || str.ch[i]==substr.ch[j])
	        {
	            ++i;
	            ++j;
	        }
	        else
	        {
	            j = next[j];
	        }
	    }
	    if(j > substr.length)
	        return i-substr.length;
	    else
	        return -1;
	}
	
	int GetNext(Str str, int next[])
	{
	    next[1] = 0;
	    int i=1, j=0;
	    while(i < str.length)
	    {
	        if(j==0 || str.ch[i]==str.ch[j])
	            next[++i]=++j;
	        else
	            j = next[j];
	    }
	}
	```

	KMP算法继续改进版，由于KMP在一些情况下还可以继续优化，如模式串aaaab和主串aaabaaaab在匹配时当i=j=4时失配，且next数组还需要让b和前三个a进行匹配，这显然毫无意义，出现这种情况的原因如下：

	- 当$p_i!=s_j$时，下次匹配必然是$p_{next[i]}$跟$s_j$比较，如果$p_i==p_{next[i]}$，则导致必然继续失配

	解决方法如下：

	- 若出现这种情况则需要再次递归，将$next[i]$修正为$next[next[i]]$，直至两者不相等为止，更新后的数组命名为nextval，计算nextval的算法如下：

		```c
		void GetNextVal(Str str, int nextval[]){
		    int i=1, j=0;
		    nextval[1]=0;
		    while(i<str.length)
		    {
		        if(j==0 || str.ch[i]==str.ch[j])
		        {
		            ++i;++j;
		            if(str.ch[i]!=str.ch[j])
		                nextval[i] = j;
		            else
		                nextval[i] = nextval[j];
		        }
		        else
		            j = nextval[j];
		    }
		}
		```

	**手算方法：先算next数组，之后比较$p_i$和$p_{next[i]}$，若两者不等则$nextval[i]=next[i]$，若两者相等则$nextval[i]=nextval[next[i]]$**

## 链表

设线性表中最多可能有m个元素，存储每个元素需要a个字节，存储每个指针需要b个字节，当元素为多少个时，使用单链表比使用数组存储此线性表更加节约空间？

> 使用数组存储该线性表时，需要申请$m*a$个空间 
>
> 使用单链表存储该线性表时，需要申请$(a+b)*i$
>
> 故$ (a+b)*i \le m*a$，即$i \le \frac{m*a}{a+b}$

## 数组、矩阵与广义表

### 特殊矩阵和稀疏矩阵

#### 特殊矩阵

##### 对称矩阵

矩阵中的元素满足$a_{i,j}=a_{j,i}$的矩阵称为对称矩阵

![image-20220928161930047](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220928161930047.png)

| $a_{0,0}$ | $a_{0,0}$ | $\cdots$ |    $a_{n-1,0}$     |     $a_{n-1,1}$      | $\cdots$ |    $a_{n-1,n-1}$     |
| :-------: | :-------: | :------: | :----------------: | :------------------: | :------: | :------------------: |
|     0     |     1     |          | $\frac{n(n-1)}{2}$ | $\frac{n(n-1)}{2}+1$ |          | $\frac{n(n+1)}{2}-1$ |

**行优先**

![image-20220928163325561](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220928163325561.png)

**列优先**

![image-20220928163352714](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220928163352714.png)

##### 三角阵

**上三角阵**为矩阵下三角部分（不包括对角线）元素全为c（c可为0）的矩阵

**下三角阵**为矩阵上三角部分（不包括对角线）元素全为c（c可为0）的矩阵

存储方法与对称矩阵类似，以下三角阵为例，只需要存储对角线及其以下部分的元素和其上三角中的一个元素c即可

| $a_{0,0}$ | $a_{0,0}$ | $\cdots$ |    $a_{n-1,0}$     |     $a_{n-1,1}$      | $\cdots$ |    $a_{n-1,n-1}$     | c                  |
| :-------: | :-------: | :------: | :----------------: | :------------------: | :------: | :------------------: | ------------------ |
|     0     |     1     |          | $\frac{n(n-1)}{2}$ | $\frac{n(n-1)}{2}+1$ |          | $\frac{n(n+1)}{2}-1$ | $\frac{n(n+1)}{2}$ |

以下三角为例

**行优先**

![image-20220928163415730](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220928163415730.png)

**列优先**

![image-20220928163432395](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220928163432395.png)

##### 对角矩阵

如图的三对角矩阵，其特点是除了主对角线以及其上下两条带状区域内的元素外，其余元素皆为c

![image-20220928163039931](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220928163039931.png)

前$i-1$行共$3(i-2)+2=3i+4$个元素，$a_{ij}$是第i行第j-i+2个元素，故$a_{ij}$是第$2i+j-2$个元素，故$k=2i-j+3$个元素

> 已知k，求i，j
>
> ![image-20220928163852333](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220928163852333.png)

#### 稀疏矩阵

##### 三元组表示法

![image-20220928163946158](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220928163946158.png)

##### 链式存储

1. 邻接表

	![image-20220928164131980](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220928164131980.png)

2. 十字链表

	![image-20220928164226378](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220928164226378.png)

## 图

1. 强连通有向图的任何顶点到其他顶点都有路径，但不一定有弧

## 排序

1. 已知待排序的n个元素可分为n/k个组，每个组包含k个元素，且任一组内的各元素均大于前一组内的所有元素和小于后一组内的所有元素，若采用基于比较的排序，其时间下界应为？

	> 因组间已有序，故将n/k个组分别排序即可，基于比较的排序方法每组的时间下界为$O(k \log_2k)$，故全部时间下界为$O(n \log_2 k)$
