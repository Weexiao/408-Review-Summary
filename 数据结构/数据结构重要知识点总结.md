# 一些重点算法

## 串的模式匹配算法

1. 暴力求解法

  ```c
  // O(mn)
  int Index_Traverse(SString S, SString T){
      int i = 1, n = StrLength(S), m = StrLength(T);
      SString sub;
      while (i <= n-m+1)
      {
          SubString(&sub, S, i, m);
          if (StrCompare(sub, T) != 0)
          {
              i++;
          }
          else{
              return i;
          }
      }
      return 0;
  }
  ```

2. 跳跃求解法

  ```c
  // 最好O(m)，最差O(mn)
  // 跳跃着实现，因为子串比较实际上只需要主串i动即可
  int Index_Jump(SString S, SString T){
      int i=1, j=1;
      while (i<=S.length && j<=T.length)
      {
          if (S.ch[i] == T.ch[i])
          {
              ++i, ++j;
          }
          else
          {
              i = i-j+2;          //跳到下一个子串的第一个位置
              j=1;
          }
      }
      if (j > T.length)
      {
          return i-T.length;
      }
      else
      {
          return 0;
      }
  }
  ```

3. KMP算法

  <iframe height=498 width=510 src="//player.bilibili.com/player.html?aid=714697013&bvid=BV16X4y137qw&cid=311669862&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

  分两步，一步求解next数组(若匹配失败j要回溯到的位置)，第二步模式匹配

  > 求Next数组方法
  >
  > 设主串为$S_1S_2……S_n$，模式串为$P_1P_2……P_m$，设不匹配时应为第k个($k<j$)字符开始比较
  > $$
  > \begin{aligned}
  > & \because S_i \ne P_j \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} \dots S_{i-1} \qquad k \lt j \\
  > & 又\because P_1 \dots P_{j-1} = S_{i-j+1} \dots S_{i-1} \\
  > & \therefore P_{j-k+1} \dots P_{j-1} = S_{i-k+1} \dots S_{i-1} \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1} \\
  > & \therefore k就是P头一个k-1字符与P尾k-1个字符相等的最大值 \\
  > & \therefore next[j] = 
  > \begin{cases}
  > 0 & j=1 \\
  > max\{k | 1 \lt k \lt j 且 P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1}\} \\
  > 1 & 其他情况
  > \end{cases}
  > \end{aligned}
  > $$
  > 例如
  >
  > | 序列       |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
  > | ---------- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
  > | 模式串元素 |  a   |  b   |  a   |  a   |  b   |  c   |  a   |  c   |
  > | next数组   |  0   |  1   |  1   |  2   |  2   |  3   |  1   |  2   |
  >
  > next[1]，next[2]一定分别为0 1；next[j]=第j位字符组成的子串的前后缀重合字符数
  >
  > 故求解过程如下：
  >
  > 1. next[3]：看next[2]与next[1]，发现两个不一样，推到next[2]和next[0]，此时出现0故直接赋值为1
  > 2. next[4]：看next[3]与next[1]，发现一样，故next[3]+1为2
  > 3. next[5]：看next[4]与next[2]，发现不一样，看next[4]与next[1]，一样，则赋值为2
  > 4. next[6]：看next[5]与next[2]，发现一样，故next[5]+1为3
  > 5. next[7]：看next[6]与next[3]，不一样，看next[6]与next[1]不一样，看next[6]与next[0]，出现0直接赋值为1
  > 6. next[8]：看next[7]和next[1]，发现一样，则next[7]+1=2
  >
  > 在不匹配位置前面，划开一条分界线，模式串一步一步往后退，直到分界线前能对上，或模式串完全跨过分解线位置
  >
  > ![image-20220808191752236](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220808191752236.png)
  >
  > ![image-20220810182338505](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220810182338505.png)

```c
int Index_KMP(SString S, SString T, int next[]){
    int i=1, j=1;
    while (i <= S.length && j<=T.length){
        if (j == 0 || S.ch[i] == T.ch[j]){
            ++i;
            ++j;
        } else{
            j = next[j];
        }
    }
    if (j > T.length)
        return i-T.length;
    else
        return 0;
}

int GetNext(SString T, int length, int next[]){
    next[1] = 0;
    int i=1,j=0;
    while (i < length){
        if (j==0 || T.ch[i]==T.ch[j]) next[++i] = ++j;
        else j=next[j];
    }
}
```

# ==栈和队列==

见栈和队列.xmind

# ==树与二叉树==

## 树的基本概念

### 基本术语

#### 概念

树是n ($n \ge 0$) 个结点的有限集合，$n=0$是，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：

1. 有且仅有一个特定的称为根的结点
2. 当$n \gt 1$时，其余结点可分为m ($m \gt 0$) 个互不相交的有限集合$T_1,T_2, \dots ,T_m$，其中每个集合本身又是一个树，并且称为根结点的子树

$\emptyset$：空树，结点数为0的树

非空树特性：

1. 树有且只有一个根结点
2. 只有根结点没有前驱，只有叶子结点没有后继
3. 除了根结点之外，其他结点有且仅有一个前驱

树是一种递归定义的树形结构，即树可以看成是根节点与若干不相交的子树的集合

![image-20220810190101560](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220810190101560.png)

#### 关系描述

祖先结点：从前驱$\to$根结点上的所有结点

子孙结点：自己下面的所有结点

双亲结点：前驱

孩子：后继

兄弟：同层，同双亲结点

堂兄弟：同层，不同双亲结点

路径：从上到下

路径长度：经过几条边

#### 结点，树的属性描述

深度(层次)：从上往下数第几层

结点高度：从下往上数第几层

树的高度：总共多少次

度：有几个分支

树的度：各结点的度的最大值

#### 有序树、无序树

有序：逻辑上看，树中各子树从左到右有次序，不能互换

无序：逻辑上看，树中各子树从左到右无次序，可以互换

#### 树、森林

树：一棵

森林：m ($m \ge 0$) 棵互不相交的树的集合

### ==性质==

1. 结点数=度数+1

2. 度为m的树和m叉树的区别

	|      |             度为m的树             |               m叉树               |
	| :--: | :-------------------------------: | :-------------------------------: |
	| 概念 |        各结点度的最大值为m        |      各结点度的最大值不超过m      |
	| 性质 | 任意结点的度$\le$m（最多m个孩子） | 任意结点的度$\le$m（最多m个孩子） |
	|      | 至少有一个结点度$=$m（有m个孩子） |     允许所有结点的度都$\lt$m      |
	|      |   一定是非空树，至少有m+1个结点   |            可以是空树             |

3. 度为m的树第i层最多有$m^{i-1}$个结点，m叉树第i层最多有$m^{i-1}$个结点

4. 高度为h的m叉树(度为m的树)至多有$m^0+m^1+ \dots +m^{h-1}=\frac{1*(1-m^h)}{1-m}=\frac{m^h-1}{m-1}$个结点

5. 高度为h的m叉树至少有h个结点，高度为h的度为m的树至少有m+h-1个结点

6. 有n个结点的m叉树的最小高度为$h= \lceil \log_m(n(m-1)+1) \rceil$
	$$
	\begin{aligned}
	& \because \frac{m^{h-1}-1}{m-1} \lt n \le \frac{m^h-1}{m-1} \\
	& \therefore m^{h-1} \lt n(m-1)+1 \le m^h \\
	& \therefore h-1 \lt \log_m(n(m-1)+1) \le h \\
	& \therefore h= \lceil \log_m(n(m-1)+1) \rceil
	\end{aligned}
	\tag{1}
	$$

## 二叉树

### 定义及其主要特性

#### 定义

二叉树是n（$n \ge 0$）个结点的有序集合

1. 或者为空二叉树，即$n=0$
2. 或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一颗二叉树

特点

1. 每个结点有且仅有两棵子树
2. 左右子树不能颠倒(二叉树是有序树)

五种状态

1. 空二叉树
2. 只有根结点
3. 只有左子树
4. 只有右子树
5. 左右子树都有

#### 几个特殊的二叉树

- 满二叉树

	高度为h且含有$2^h-1$个结点的二叉树；$n=1+2+ \dots +2^{h-1}=\frac{2^h-1}{2-1}=2^h-1$

	特点

	1. 只有最后一层才有叶子结点
	2. 不存在度为1的结点
	3. 按层序开始编号，i结点左孩子为2i，右孩子为2i+1，其父节点为$\lfloor i/2 \rfloor$（若存在）

- 完全二叉树

	当且仅当每个结点都与高度为h的满二叉树中编号为1-n的结点一一对应时称其为完全二叉树

	特点

	1. 只有最后两层有叶子结点
	2. 只存在一个度为1的结点
	3. 按层序开始编号，i结点左孩子为2i，右孩子为2i+1，其父节点为$\lceil i/2 \rfloor$（若存在）
	4. $i \le \lfloor n/2 \rfloor$为分支结点，反之为叶子结点

	![image-20220812184623452](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220812184623452.png)

- 二叉排序树—搜索、排序

	左子树上的所有结点的关键字都小于根结点上的关键字

	根结点上的关键字都小于右子树上的所有结点上的关键字

	左右子树又是二叉排序树

	![image-20220812184732800](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220812184732800.png)

- 平衡二叉树—搜索效率更高

	二叉排序树的改进版，其任意结点左右子树高度差$\le$1

#### 性质

##### 普通二叉树性质

1. 设二叉树中度为0、1、2的结点个数分别为$n_0$、$n_1$、$n_2$，则
	$$
	\begin{aligned}
	& \because n_0+n_1+n_2=n_1+2*n_2+1 \\
	& \therefore n_0=n_2+1
	\end{aligned}
	\tag{1}
	$$

2. 二叉树第i层至多有$2^{i-1}$个结点，m叉树第i层至多有$m^{i-1}$个结点（$i \ge 1$）

3. 高度为h的二叉树至多有$2^h-1$个结点，此时其为满二叉树；高度为h的m叉树至多有$m^h-1$个结点

##### 完全二叉树性质

1. 有n个（$n \gt 0$）结点的完全二叉树的高度h为$\lceil \log_2(n+1) \rceil$或$\lfloor \log_2(n) \rfloor+1$
	$$
	\begin{aligned}
	& \because 2^{h-1}-1 \lt n \le 2^{h}-1 \\
	& \therefore 2^{h-1} \lt n+1 \le 2^{h} \\
	& \therefore {h-1} \lt \log_2(n+1) \le h \\
	& \therefore h=\lceil \log_2(n+1) \rceil \\
	& or \\
	& \because 2^{h-1} \le n \lt 2^{h} \\
	& \therefore {h-1} \le \log_2(n) \lt h \\
	& \therefore h=\lfloor \log_2(n) \rfloor +1 \\
	\end{aligned}
	\tag{2}
	$$

2. 对于完全二叉树，可以由结点数n推出度为0、1、2结点的个数$n_0$、$n_1$、$n_2$
	$$
	\begin{aligned}
	& \because n_0=n_2+1  且 n_1=0orn_1=1 \\
	& \therefore n_0+n_2一定为奇数 \\
	& \therefore 完全二叉树有2k个结点，则n_0=k,n_1=1,n_2=k-1 \\
	& 完全二叉树有2k+1个结点，则n_0=k+1,n_1=0,n_2=k
	\end{aligned}
	\tag{3}
	$$

### 二叉树的存储结构