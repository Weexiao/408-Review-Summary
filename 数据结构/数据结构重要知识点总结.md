# 一些重点算法

## 串的模式匹配算法

1. 暴力求解法

  ```c
  // O(mn)
  int Index_Traverse(SString S, SString T){
      int i = 1, n = StrLength(S), m = StrLength(T);
      SString sub;
      while (i <= n-m+1)
      {
          SubString(&sub, S, i, m);
          if (StrCompare(sub, T) != 0)
          {
              i++;
          }
          else{
              return i;
          }
      }
      return 0;
  }
  ```

2. 跳跃求解法

  ```c
  // 最好O(m)，最差O(mn)
  // 跳跃着实现，因为子串比较实际上只需要主串i动即可
  int Index_Jump(SString S, SString T){
      int i=1, j=1;
      while (i<=S.length && j<=T.length)
      {
          if (S.ch[i] == T.ch[i])
          {
              ++i, ++j;
          }
          else
          {
              i = i-j+2;          //跳到下一个子串的第一个位置
              j=1;
          }
      }
      if (j > T.length)
      {
          return i-T.length;
      }
      else
      {
          return 0;
      }
  }
  ```

3. KMP算法

  <iframe height=498 width=510 src="//player.bilibili.com/player.html?aid=714697013&bvid=BV16X4y137qw&cid=311669862&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

  分两步，一步求解next数组(若匹配失败j要回溯到的位置)，第二步模式匹配

  > 求Next数组方法
  >
  > 设主串为$S_1S_2……S_n$，模式串为$P_1P_2……P_m$，设不匹配时应为第k个($k<j$)字符开始比较
  > $$
  > \begin{aligned}
  > & \because S_i \ne P_j \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} \dots S_{i-1} \qquad k \lt j \\
  > & 又\because P_1 \dots P_{j-1} = S_{i-j+1} \dots S_{i-1} \\
  > & \therefore P_{j-k+1} \dots P_{j-1} = S_{i-k+1} \dots S_{i-1} \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1} \\
  > & \therefore k就是P头一个k-1字符与P尾k-1个字符相等的最大值 \\
  > & \therefore next[j] = 
  > \begin{cases}
  > 0 & j=1 \\
  > max\{k | 1 \lt k \lt j 且 P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1}\} \\
  > 1 & 其他情况
  > \end{cases}
  > \end{aligned}
  > $$
  > 例如
  >
  > | 序列       |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
  > | ---------- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
  > | 模式串元素 |  a   |  b   |  a   |  a   |  b   |  c   |  a   |  c   |
  > | next数组   |  0   |  1   |  1   |  2   |  2   |  3   |      |      |
  >
  > next[0]，next[1]一定分别为0 1；
  >
  > 在不匹配位置前面，划开一条分界线，模式串一步一步往后退，直到分界线前能对上，或模式串完全跨过分解线位置
  >
  > ![image-20220808191752236](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220808191752236.png)