# 一些重点算法

## 串的模式匹配算法

1. 暴力求解法

  ```c
  // O(mn)
  int Index_Traverse(SString S, SString T){
      int i = 1, n = StrLength(S), m = StrLength(T);
      SString sub;
      while (i <= n-m+1)
      {
          SubString(&sub, S, i, m);
          if (StrCompare(sub, T) != 0)
          {
              i++;
          }
          else{
              return i;
          }
      }
      return 0;
  }
  ```

2. 跳跃求解法

  ```c
  // 最好O(m)，最差O(mn)
  // 跳跃着实现，因为子串比较实际上只需要主串i动即可
  int Index_Jump(SString S, SString T){
      int i=1, j=1;
      while (i<=S.length && j<=T.length)
      {
          if (S.ch[i] == T.ch[i])
          {
              ++i, ++j;
          }
          else
          {
              i = i-j+2;          //跳到下一个子串的第一个位置
              j=1;
          }
      }
      if (j > T.length)
      {
          return i-T.length;
      }
      else
      {
          return 0;
      }
  }
  ```

3. KMP算法

  <iframe height=498 width=510 src="//player.bilibili.com/player.html?aid=714697013&bvid=BV16X4y137qw&cid=311669862&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

  分两步，一步求解next数组(若匹配失败j要回溯到的位置)，第二步模式匹配

  > 求Next数组方法
  >
  > 设主串为$S_1S_2……S_n$，模式串为$P_1P_2……P_m$，设不匹配时应为第k个($k<j$)字符开始比较
  > $$
  > \begin{aligned}
  > & \because S_i \ne P_j \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} \dots S_{i-1} \qquad k \lt j \\
  > & 又\because P_1 \dots P_{j-1} = S_{i-j+1} \dots S_{i-1} \\
  > & \therefore P_{j-k+1} \dots P_{j-1} = S_{i-k+1} \dots S_{i-1} \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1} \\
  > & \therefore k就是P头一个k-1字符与P尾k-1个字符相等的最大值 \\
  > & \therefore next[j] = 
  > \begin{cases}
  > 0 & j=1 \\
  > max\{k | 1 \lt k \lt j 且 P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1}\} \\
  > 1 & 其他情况
  > \end{cases}
  > \end{aligned}
  > $$
  > 例如
  >
  > | 序列       |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
  > | ---------- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
  > | 模式串元素 |  a   |  b   |  a   |  a   |  b   |  c   |  a   |  c   |
  > | next数组   |  0   |  1   |  1   |  2   |  2   |  3   |  1   |  2   |
  >
  > next[1]，next[2]一定分别为0 1；next[j]=第j位字符组成的子串的前后缀重合字符数
  >
  > 故求解过程如下：
  >
  > 1. next[3]：看next[2]与next[1]，发现两个不一样，推到next[2]和next[0]，此时出现0故直接赋值为1
  > 2. next[4]：看next[3]与next[1]，发现一样，故next[3]+1为2
  > 3. next[5]：看next[4]与next[2]，发现不一样，看next[4]与next[1]，一样，则赋值为2
  > 4. next[6]：看next[5]与next[2]，发现一样，故next[5]+1为3
  > 5. next[7]：看next[6]与next[3]，不一样，看next[6]与next[1]不一样，看next[6]与next[0]，出现0直接赋值为1
  > 6. next[8]：看next[7]和next[1]，发现一样，则next[7]+1=2
  >
  > 在不匹配位置前面，划开一条分界线，模式串一步一步往后退，直到分界线前能对上，或模式串完全跨过分解线位置
  >
  > ![image-20220808191752236](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220808191752236.png)
  >
  > ![image-20220810182338505](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220810182338505.png)

```c
int Index_KMP(SString S, SString T, int next[]){
    int i=1, j=1;
    while (i <= S.length && j<=T.length){
        if (j == 0 || S.ch[i] == T.ch[j]){
            ++i;
            ++j;
        } else{
            j = next[j];
        }
    }
    if (j > T.length)
        return i-T.length;
    else
        return 0;
}

int GetNext(SString T, int length, int next[]){
    next[1] = 0;
    int i=1,j=0;
    while (i < length){
        if (j==0 || T.ch[i]==T.ch[j]) next[++i] = ++j;
        else j=next[j];
    }
}
```

# ==栈和队列==

见栈和队列.xmind

# ==树与二叉树==

## 树的基本概念

### 基本术语

#### 概念

树是n ($n \ge 0$) 个结点的有限集合，$n=0$是，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：

1. 有且仅有一个特定的称为根的结点
2. 当$n \gt 1$时，其余结点可分为m ($m \gt 0$) 个互不相交的有限集合$T_1,T_2, \dots ,T_m$，其中每个集合本身又是一个树，并且称为根结点的子树

$\emptyset$：空树，结点数为0的树

非空树特性：

1. 树有且只有一个根结点
2. 只有根结点没有前驱，只有叶子结点没有后继
3. 除了根结点之外，其他结点有且仅有一个前驱

树是一种递归定义的树形结构，即树可以看成是根节点与若干不相交的子树的集合

![image-20220810190101560](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.assets/image-20220810190101560.png)

#### 关系描述

祖先结点：从前驱$\to$根结点上的所有结点

子孙结点：自己下面的所有结点

双亲结点：前驱

孩子：后继

兄弟：同层，同双亲结点

堂兄弟：同层，不同双亲结点

路径：从上到下

路径长度：经过几条边

#### 结点，树的属性描述

深度(层次)：从上往下数第几层

结点高度：从下往上数第几层

树的高度：总共多少次

度：有几个分支

树的度：各结点的度的最大值

#### 有序树、无序树

有序：逻辑上看，树中各子树从左到右有次序，不能互换

无序：逻辑上看，树中各子树从左到右无次序，可以互换

#### 树、森林

树：一棵

森林：m ($m \ge 0$) 棵互不相交的树的集合

### ==性质==