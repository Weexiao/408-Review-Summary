# 一些408算法原题

## 2009年42题

![image-20221017193559826](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221017193559826.png)

1. 使用双指针法，之间间隔为k，若一方变为NULL则输出另一方

2. 建立指针p、q都指向单链表第一个节点，将q向后移动k-1次，若次过程中q变空，则表示查找失败返回0，若成功则开始让p、q同步移动，若q为空时返回1，输出p

3. ```c
	int findKth(LinkedList L, int k)
	{
	    int i;
	    LNode *p, *q;
	    if(L->next == NULL)
	        return 0;
	    p = L->next, q = L->next;
	    for(i=0; i<k-1; i++)
	    {
	        if(q==NULL && i<k-1)
	            return 0;
	        q = q->next;
	    }
	    while(q != NULL)
	    {
	        p = p->next;
	        q = q->next;
	    }
	    printf("%d", p->data);
	    return 1;
	}
	```

## 2010年42题

![image-20221017194015498](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221017194015498.png)

**最优解**

1. 将数组$R$看作是数组$ab$，先将$a$逆置变成$a^{-1}b$，再将b逆置变为$a^{-1}b^{-1}$，再将$a^{-1}b^{-1}$整体逆置变为$ba$

2. ```c
	void Reverse(int R[], int low, int high)
	{
	    int i, temp;
	    for(i=0; i<(high-low+1)/2; i++)
	    {
	        temp = A[low+i];
	        A[low+1] = A[high-i];
	        A[high-i] = temp;
	    }
	}
	void Converse(int R[], int n, int p)
	{
	    Reverse(R, 0, p-1);
	    Reverse(R, p, n-1);
	    Reverse(R, 0, n-1);
	}
	```

3. 时间复杂度$O(\log_2n)$，空间复杂度$O(1)$

**其他解**

1. 借助辅助数组实现：将$R$中前$p$个序列保存在辅助数组中，然后将$R$中后面的序列整体向前移动p位，再将辅助数组中的值放回原数组

2. ```c
	void Converse(int R[], int n, int p)
	{
	    int i, temp[n];
	    for(i=0; i<p; i++)
	        temp[i] = A[i];
	    for(i=p; i<n; i++)
	        A[i-p] = A[i];
	    for(i=n-p; i<n; i++)
	        A[i] = temp[i-n+p];
	}
	```

3. 时间复杂度$O(n)$，空间复杂度$O(p)$

## 2011年42题

![image-20221017195047834](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221017195047834.png)

**最优解**

1. 分别求出序列$A$和$B$的中位数$m_1, m_2$，共有三种情况

	- $m_1==m_2$，则直接输出
	- $m_1 \lt m_2$，则丢弃A较小的一部分，B较大的一部分
	- $m_1 \gt m_2$，则丢弃A较大的一部分，B较小的一部分
	- 循环求解，直到一方只剩一个值

	输出两个值中较小的一方

2. ```c
	int M_Search(int A[], int B[], int n)
	{
	    int s1=0, e1=n-1, m1, s2=0, e2=n-1, m2;			// A,B的首位、末位、中位
	    while(s1!=e1 || s2!=e2`)
	    {
	        m1 = (s1+e1)/2;
	        m2 = (s2+e2)/2;
	        if(A[m1] == B[m2])
	            return A[m1];
	        else if(A[m1] < B[m2])
	        {
	            if((s1+e1)%2 == 0)						// A有奇数个
	            {
	                s1 = m1;			// 舍弃A中点以前的部分且保留中间点
	                e2 = m2;			// 舍弃B中点以后的部分且保留中间点
	            }
	            else									// A有偶数个
	            {
	                s1 = m1+1;			// 舍弃A中间点及中点以前的部分
	                e2 = m2;			// 舍弃B中点以前的部分且保留中间点
	            }
	        }
	        else
	        {
	            if((s1+e1)%2 == 0)						// A有奇数个
	            {
	                e1 = m1;			// 舍弃A中点以后的部分且保留中间点
	                s2 = m2;			// 舍弃B中点以前的部分且保留中间点
	            }
	            else									// A有偶数个
	            {
	                e1 = m1+1;			// 舍弃A中点以后的部分且保留中间点
	                e2 = m2;			// 舍弃B中间点及中点以前的部分
	            }
	        }
	    }
	    return A[m1]<B[m2] ? A[m1] : B[m2];
	}
	```

3. 时间复杂度$O(\log_2n)$，空间复杂度$O(1)$

**其他解**

1. 设两序列长为$n$，若假设将两序列合并成一个新序列，则该新序列长为$2n$，中位数一定在第n个位置，故问题转化为在两个有序序列中找第$n$个数

2. ```c
	int M_Search(int A[], int B[], int n)
	{
	    int i=0, j=0, k=n;
	    int result;
	    while(i<n && j<n)
	    {
	        if(k==0)
	            break;
	        if(A[i]<B[j])
	        {
	            result = A[i];
	            i++;
	        }
	        else
	        {
	            result = B[j];
	            j++;
	        }
	        k--;
	    }
	    return result;
	}
	```

3. 时间复杂度$O(n)$，空间复杂度$O(1)$

## 2012年42题

![image-20221018184221253](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221018184221253.png)

**最优解**

1. 经分析可得，两单词的后缀最大值即为长度较短的一个单词，故只需要保证两个链表能最终一起结束就可找到后缀的第一个值，问题转化为如何让两个长度不一定相等的链表遍历时能同时结束

	首先分别求出链表$A$、$B$的长度$m$、$n$，建立两个指针$p$、$q$，将其指向链表的第一个节点

	若$m \gt n$，则先让$p$向后移动$m-n$位；若$m \lt n$，则先让$q$向后移动$n-m$位

2. ```c
     LNode *findBack(LinkList A, LinkList B, int m, int n)
         // m,n分别为A、B长度
     {
         if(A->next==NULL || B->next==NULL)
             return NULL;
         LNode *p = A->next, *q = B->next;
         if(m > n)
             for(int i=0; i<m-n; i++)
                 p = p->next;
         else
             for(int i=0; i<n-m; i++)
                 q = q->next;
         while((p!=NULL || q!=NULL) && (p!=q))
         {
             p = p->next;
             q = q->next;
         }
         return p;
     }
     ```

3. 时间复杂度为$O(m+n)$

**其他解**

1. 暴力求解，分别求出链表$A$、$B$的长度$m$、$n$，建立两个指针$p$、$q$，将其指向链表的第一个节点；之后嵌套循环，比较$p$、$q$是否相等
2. 不写了
3. 时间复杂度为$O(mn)$

## 2013年41题

![image-20221019202055194](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221019202055194.png)

**最优解**

1. 本题实际上是在查找序列中值个数超过$\frac{n}{2}$的值

	设$count$变量用来计数，$key$变量记录可能的主元素，二者初值分别为0、$A[0]$，循环从$i=0$开始，每次比较$key$和$A[i]$的值，二者相等则$count+1$反之$count-1$。若$count==0$则将$key$设为当前$A[i]$，$count$设为1。这种方法可以找到序列中最多的元素，若$count \gt 1$则统计序列中有多少个$key$，若大于$\frac{n}{2}$则输出，其余情况输出-1

2. ```c
	int MainElement(int A[], int n)
	{
	    int i, count=0, key=A[0];
	    for(i=0; i<n; i++)
	    {
	        if(A[i] != key)
	            count--;
	        else
	            count++;
	        if(count == 0)
	        {
	            key = A[i];
	            count = 1;
	        }
	    }
	    if(count > 1)
	    {
	        int m = 0;
	        for(i=0; i<n; i++)
	            if(A[i] == key)
	                m++;
	        if(m > n/2)
	            return key;
	        else
	            return -1;
	    }
	    else
	        return -1;
	}
	```

3. 时间复杂度$O(n)$，空间复杂度$O(1)$

**其他解**

1. 采用计数排序的方法：时间复杂度$O(n)$，空间复杂度$O(n)$

	```c
	int Majority(int A[], int n)
	{
	    int i, *p, max;
	    p = (int *)malloc(sizeof(int)*n);			// 申请辅助计数数组
	    for(i=0; i<n; i++)
	        p[i] = 0;
	    max = 0;
	    for(i=0; i<n; i++)
	    {
	        p[A[i]]++;								// 计数器加1
	        if(p[A[i]] > p[max])					// 记录出现次数最多的元素
	            max = A[i];
	    }
	    if(p[max] > n/2)
	        return max;
	    else
	        return -1;
	}
	```

2. 采用其他排序的方法：时间复杂度$O(n \log_2n)$，空间复杂度其他

3. 暴力求解

## 2014年41题

![image-20221019203509525](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221019203509525.png)

**先序遍历**

1. 使用递归方法，类似于二叉树的先序遍历

	- 若当前节点为叶节点，则WPL += root->weight*deepth;
	- 若当前节点有左孩子，则递归遍历左孩子，且deepth+1
	- 若当前节点有右孩子，则递归遍历右孩子，且deepth+1

2. ```c
	typedef struct BiNode
	{
	    int weight;					// 权值
	    struct BiNode *left;		// 左孩子
	    struct BiNode *right;		// 右孩子
	}BiNode, *BiTree;
	```

3. ```c
	int WPL(BiTree root)
	{
	    int deepth=0, WPL=0;
	    calculateWPL(root, deepth, &WPL);
	    return WPL;
	}
	void calculateWPL(BiTree root, int deepth, int *WPL)
	{
	    if(root != NULL)
	    {
	        if(root->left == NULL && root->right == NULL)
	            (*WPL) += root->weight*deepth;
	        if(root->left != NULL)
	            calculateWPL(root->left, deepth+1, WPL);
	        if(root->right != NULL)
	            calculateWPL(root->right, deepth+1, WPL);
	    }
	}
	```

**层序遍历**

1. 使用队列进行层次遍历，并记录当前的层数

	- 当遍历到叶子节点时，累计WPL
	- 当遍历到非叶子节点时把该节点的子树加入队列，若当某节点为该层的最后一个节点时，层数+1
	- 队列空则遍历结束，返回WPL

2. 与上一致

3. ```c
	#define MaxSize 100						// 设置队列的最大容量
	int WPL(BiTree root)
	{
	    BiTree q[MaxSize];					// 声明队列，end1为头指针，end2为尾指针
	    int end1, end2;
	    end1=end2=0;						// 初始化队列，头指针指向队头，尾指针指向队尾的最后一个元素
	    int WPL=0, deepth=0;
	    BiNode *lastNode=root;				// 记录当前层最后一个节点
	    BiNode *newlastNode=NULL;			// 记录下一层最后一个节点
	    q[end2++] = root;					// 入队
	    while(end1 != end2)					// 队不为空
	    {
	        BiNode *t = q[end1++];			// 出队
	        if(t->left == NULL && t->right==NULL)
	            WPL += t->weight * deepth;
	        if(t->left != NULL)
	        {
	            q[end2++] = t->left;		// 左孩子入队
	            newlastNode = t->left;		// 更新下一次最后一个节点
	        }
	        if(t->right != NULL)
	        {
	            q[end2++] = t->right;		// 左孩子入队
	            newlastNode = t->right;		// 更新下一次最后一个节点
	        }
	        if(t == lastNode)
	        {
	            lastNode = newlastNode;		// 若本节点为最后一个节点，则更新lastNode
	            deepth++;
	        }
	    }
	    return WPL;
	}
	```


## 2015年41题

![image-20221020205939637](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221020205939637.png)

![image-20221020205952343](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221020205952343.png)

1. 通过牺牲空间来换取时间，设置一个辅助数组flag[n+1]，遍历列表，设置一个指针p用来表示不需要删除的第一个节点，对每个节点进行如下操作

  - 若当前节点值的绝对值第一次出现，即flag[i]=0，将p->next指向当前节点，再将p向后移动一位
  - 若当前节点值的绝对值出现过，则删除该节点

2. ```c
    typedef struct LNode
    {
      int data;
      struct LNode *next;
    }LNode, *LinkList;
  ```

3. ```c
  void delete(LinkList *L, int n)
  {
      if((*L)->next==NULL)
          return;
      LNode *p=(*L), *q=(*L)->next, *t;
      int m;
      int flag[n+1];
      while(q != NULL)
      {
          m = q->data>0 ? q->data : -q->data;
          if(flag[m] == 0)
          {
              p->next = q;
              p = q;
              q = q->next;
          }
          else
          {
              t = q;
              q = q->next;
              free(t);
          }
      }
  }
  ```

4. 时间复杂度$O(m)$，空间复杂度$O(n)$

## 2016年43题

![image-20221023193937232](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221023193937232-1666525177849-1.png)

**最优解**

1. 由题意可得，将最小的$\lfloor n/2 \rfloor$个元素放在$A_1$中，其余的元素放在$A_2$中，分组结果即可满足题目要求。仿照快速排序的思想，基于枢轴将n个整数划分为两个子集，根据划分后枢轴所处的位置$i$分别处理

	- 若$i = \lfloor n/2 \rfloor$则分组完成，算法结束
	- 若$i \lt \lfloor n/2 \rfloor$，则枢轴及之前的所有元素均属于$A_1$，继续对$i$之后的元素进行划分
	- 若$i \gt \lfloor n/2 \rfloor$，则枢轴及之后的所有元素均属于$A_2$，继续对$i$之后的元素进行划分

	基于这种设计思想的算法，不需要对全部元素进行全排序，其平均时间复杂度为$O(n)$，空间复杂度为$O(1)$

2. ```c
	int Partition(int A[], int n)
	{
	    int pivotkey, low = 0,low0 = 0, high = n-1, high0 = n-1, flag = 1, k = n/2, i;
	    int s1=0, s2=0;
	    while(flag)
	    {
	        pivotkey = A[low];			// 选择枢轴
	        while(low < high)			// 基于枢轴对数据进行划分
	        {
	            while(low < high && A[high] >= pivotkey) --high;
	            A[low] = A[high];
	            while(low < high && A[low] <= pivotkey) ++low;
	            A[high] = A[low];
	        }
	        A[low] = pivot;
	        if(low = k-1)				// 如果枢轴是第n/2小元素，则划分成功
	            flag = 0;
	        else						// 否则继续划分					
	        {
	            if(low < k-1)
	            {
	                low0 = ++low;
	                high = high0;
	            }
	            else
	            {
	                high0 = --low;
	                low = low0;
	            }
	        }
	    }
	    for(i=0; i<k; i++) s1+=A[i];
	    for(i=k; i<n; i++) s2+=A[i];
	    return s2-s1;
	}
	```

3. 时间复杂度为$O(n)$，空间复杂度为$O(1)$

**其他解**

1. 可以使用快速排序将原序列转为有序序列，求其前一半和后一半的差

2. ```c
	void Partition(int A[], int low, int high)
	{
		int pivot = A[low];
	    while(low < high)
	    {
	        while(low<high && A[high] > pivot) --high;
	        A[low] = A[high];
	        while(low<high && A[low] < pivot) ++low;
	        A[high] = A[low];
	    }
	    A[low] = pivot;
	    return low;
	}
	void QuickSort(int A[], int low, int high)
	{
	    if(low < high)
	    {
	        int pivotpos = Partition(A, low, high);
	        QuickSort(A, low, pivotpos-1);
	        QuickSort(A, pivotpos+1, high);
	    }
	}
	int function(int A[], int n)
	{
	    QuickSort(A, 0, n-1);
	    int i, s1=0, s2=0;
	    for(i=0; i<n/2; i++)
	        s1 += A[i];
	    for(i=n/2; i<n; i++)
	        s2 += A[i];
	    return s2-s1;
	}
	```

3. 时间复杂度为$O(n \log_2 n)$，空间复杂度为$O(1)$

## 2017年41题

![image-20221023203516876](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221023203516876.png)

**最优解**

1. 表达式树种分支节点所对应的子表达式的计算次序，由该分支结点所处的位置绝对。为得到正确的中序表达式，需要在生成遍历序列的同时，在必要的位置加上括号。显然，表达式的最外层(根节点)及操作数(叶结点)不需要添加括号

2. ```c
	void BTree2Exp(BTree *T)
	{
		if(T == NULL) return;
	    else if(T->left == NULL && T->right == NULL)		//若为叶子结点
	        printf("%s", T->data);			// 输出操作数
	    else
	    {
	        if(deep > 1)
	            printf("(");
	        BTree2Exp(T->left, deep+1);
	        printf("%s", T->data);			// 输出操作符
	        BTree2Exp(T->right, deep+1);
	        if(deep > 1)
	            printf(")");
	    }
	}
	void BTree2E(BTree *T)
	{
	    BTree2Exp(T, 1);			// 根高度为1
	}
	```

**其他解**

1. 本质上该算法还是二叉树的中序遍历，只需要在遍历过程中加上括号表示运算顺序即可，由题意可知，只有中间节点(非根、非叶)才需要输出括号，故使用flag表示当前节点是否是根节点，之后直接中序遍历即可

2. ```c
	void InOrder(BTree *T, int flag)
	{
	    if(T != NULL)
	    {
	        if(flag == 1 && (T->left != NULL || T->right != NULL))
	            printf("(");
	        InOrder(T->left, 1);
	        printf("%s", T->data);
	        InOrder(T->right, 1);
	        if(flag == 1 && (T->left != NULL || T->right != NULL))
	            printf(")");
	    }
	}
	void Print(BTree T)
	{
	    InOrder(T, 0);
	}
	```


## 2018年41题

![image-20221024203948120](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221024203948120.png)

1. 使用空间换取时间的算法，声明辅助数组$flag[n]$，$flag[i]=1$表示$i-1$已经存在

	容易得到，若数组A中依次出现1~n时，返回n+1，当数组A中出现小于0或者大于n的数，则$flag$数组中一定有0值

	故算法流程如下：

	- 初始化$flag$数组全0
	- 遍历数组A，若数组A中出现大于0且小于n+1的数，则将$flag[i-1]$置为1，反之不操作
	- 数组A遍历结束后，遍历$flag$数组，当第一个不为0的数出现时，输出i+1

2. ```c
    int findMinInteger(int A[], int n)
  {
         int flag[n];					// 辅助数组
         int i;
         for(i=0; i<n; i++)
             flag[i] = 0;
         for(i=0; i<n; i++)
             if(A[i]>0 && A[i]<n+1)
                 flag[A[i]-1] = 1;
         i = 0;
         while(flag[i] != 0) i++;
         return i+1;
     }
     ```
     
3. 时间复杂度为$O(n)$，空间复杂度为$O(n)$

## 2019年41题

![image-20221025214106321](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221025214106321.png)

![image-20221025214119566](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221025214119566.png)

1. 先找出链表的中间结点，然后将后半部分逆置，在将前后两端中依次取一个结点并按要求重排

2. ```c
	void change_list(Node *L)
	{
	    Node *p, *q, *r, *s;
	    p = q = L;
	    while(q->next != NULL)				// 让p指向中间结点
	    {
			p = p->next;
	        q = q->next;
	        if(q->next != NULL)
	            q = q->next;
	    }
	    q = p->next;						// q指向后半个链表
	    p->next = NULL;
	    while(q != NULL)
	    {
			r = q->next;
	        q->next = p->next;
	        p->next = q;
	        q = r;
	    }
	    s = L->next;						// s指向前半部分
	    q = p->next;						// q指向后半部分
	    while(q != NULL)
	    {
	        r = q->next;
	        q->next = s->next;
	        s->next = q;
	        s = q->next;
	        q = r;
	    }
	}
	```

3. 时间复杂度为$O(n)$

## 2020年41题

![image-20221029195834643](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221029195834643.png)

1. 由题意可得，若三元组存在最小距离，则三元组$(a,b,c)$中的$a,b,c$值之间绝对值的差一定最小，且最小值一定大于0，则声明一变量$min$记录当前最小值

	算法执行过程如下

	- 声明三个变量$i$、$j$、$k$分别用来遍历$A$、$B$、$C$三个数组
	- 若三个数组中各值分别为$A[i]$、$B[j]$、$C[k]$，三者中哪个是最小值则让其索引加一，找到三数更接近距离

2. ```c
	#include<math.h>			// 引入abs绝对值函数
	#include<limits.h>			// 引入INT_MAX的值
	int IsMin(int a, int b, int c)
	{
	    return a<=b && a<=c;
	}
	int MinDistance(int A[], int n1, int B[], int n2, int C[], int n3)
	{
	    int i=0, j=0, k=0, min=INT_MAX;
	    while(i<n1 && j<n2 && k<n3 && min > 0)
	    {
			if(min > abs(A[i]-B[j])+abs(B[j]-C[k])+abs(A[i]-C[k]))
	            min = abs(A[i]-B[j])+abs(B[j]-C[k])+abs(A[i]-C[k]);
	        else
	        {
	            if(IsMin(A[i], B[j], C[k]))	i++;
	            else if(IsMin(B[j], A[i], C[k])) j++;
	            else k++;
	        }
	    }
	    return min;
	}
	```

3. 时间复杂度$O(n)$，空间复杂度$O(1)$

## 2021年41题

![image-20221029201139731](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221029201139731.png)

![image-20221029201151580](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221029201151580.png)

1. 此题只能使用复杂的方法，即遍历顶点的度，若度为奇数则count++，最后判断是否存在EL路径

	算法基本运行过程如下：

	- 遍历各顶点，计算各顶点的度，若度为奇数则count++
	- 遍历完各顶点后，若count==0或count\==2则说明存在EL路径，返回1，反之返回0

2. ```c
	int IsExistEL(MGraph G)
	{
	    int i, j, degree, count=0;
	    for(i=0; i<G.numVertices;i++)
	    {
	        degree = 0;
	        for(j=0; j<G.numVertices; j++)
	            degree += G.Edge[i][j];
	        if(degree % 2 != 0)
	            count++;
	    }
	    if(count==0 || count==2)
	        return 1;
	    else
	        return 0;
	}
	```

3. 时间复杂度$O(n)$，空间复杂度$O(1)$

# 一些重点算法

## 串的模式匹配算法

### 暴力求解法

  ```c
// O(mn)
int Index_Traverse(SString S, SString T){
    int i = 1, n = StrLength(S), m = StrLength(T);
    SString sub;
    while (i <= n-m+1)
    {
        SubString(&sub, S, i, m);
        if (StrCompare(sub, T) != 0)
        {
            i++;
        }
        else{
            return i;
        }
    }
    return 0;
}
  ```

### 跳跃求解法

  ```c
// 最好O(m)，最差O(mn)
// 跳跃着实现，因为子串比较实际上只需要主串i动即可
int Index_Jump(SString S, SString T){
    int i=1, j=1;
    while (i<=S.length && j<=T.length)
    {
        if (S.ch[i] == T.ch[i])
        {
            ++i, ++j;
        }
        else
        {
            i = i-j+2;          //跳到下一个子串的第一个位置
            j=1;
        }
    }
    if (j > T.length)
    {
        return i-T.length;
    }
    else
    {
        return 0;
    }
}
  ```

### KMP算法

  <iframe height=498 width=510 src="//player.bilibili.com/player.html?aid=714697013&bvid=BV16X4y137qw&cid=311669862&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

  分两步，一步求解next数组(若匹配失败j要回溯到的位置)，第二步模式匹配

  > 求Next数组方法
  >
  > 设主串为$S_1S_2……S_n$，模式串为$P_1P_2……P_m$，设不匹配时应为第k个($k<j$)字符开始比较
  > $$
  > \begin{aligned}
  > & \because S_i \ne P_j \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} \dots S_{i-1} \qquad k \lt j \\
  > & 又\because P_1 \dots P_{j-1} = S_{i-j+1} \dots S_{i-1} \\
  > & \therefore P_{j-k+1} \dots P_{j-1} = S_{i-k+1} \dots S_{i-1} \\
  > & \therefore P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1} \\
  > & \therefore k就是P头一个k-1字符与P尾k-1个字符相等的最大值 \\
  > & \therefore next[j] = 
  > \begin{cases}
  > 0 & j=1 \\
  > max\{k | 1 \lt k \lt j 且 P_1 \dots P_k=S_{i-k+1} = P_{j-k+1} \dots P_{j-1}\} \\
  > 1 & 其他情况
  > \end{cases}
  > \end{aligned}
  > $$
  > 例如
  >
  > | 序列       |  1   |  2   |  3   |  4   |  5   |  6   |  7   |  8   |
  > | ---------- | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
  > | 模式串元素 |  a   |  b   |  a   |  a   |  b   |  c   |  a   |  c   |
  > | next数组   |  0   |  1   |  1   |  2   |  2   |  3   |  1   |  2   |
  >
  > next[1]，next[2]一定分别为0 1；next[j]=第j位字符组成的子串的前后缀重合字符数
  >
  > 故求解过程如下：
  >
  > 1. next[3]：看next[2]与next[1]，发现两个不一样，推到next[2]和next[0]，此时出现0故直接赋值为1
  > 2. next[4]：看next[3]与next[1]，发现一样，故next[3]+1为2
  > 3. next[5]：看next[4]与next[2]，发现不一样，看next[4]与next[1]，一样，则赋值为2
  > 4. next[6]：看next[5]与next[2]，发现一样，故next[5]+1为3
  > 5. next[7]：看next[6]与next[3]，不一样，看next[6]与next[1]不一样，看next[6]与next[0]，出现0直接赋值为1
  > 6. next[8]：看next[7]和next[1]，发现一样，则next[7]+1=2
  >
  > 在不匹配位置前面，划开一条分界线，模式串一步一步往后退，直到分界线前能对上，或模式串完全跨过分解线位置
  >
  > ![image-20220808191752236](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20220808191752236.png)
  >
  > ![image-20220810182338505](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20220810182338505.png)

```c
int Index_KMP(SString S, SString T, int next[]){
    int i=1, j=1;
    while (i <= S.length && j<=T.length){
        if (j == 0 || S.ch[i] == T.ch[j]){
            ++i;
            ++j;
        } else{
            j = next[j];
        }
    }
    if (j > T.length)
        return i-T.length;
    else
        return 0;
}

int GetNext(SString T, int next[]){
    next[1] = 0;
    int i=1,j=0;
    while (i < T.length){
        if (j==0 || T.ch[i]==T.ch[j]) next[++i] = ++j;
        else j=next[j];
    }
}
```

KMP算法继续改进版，由于KMP在一些情况下还可以继续优化，如模式串aaaab和主串aaabaaaab在匹配时当i=j=4时失配，且next数组还需要让b和前三个a进行匹配，这显然毫无意义，出现这种情况的原因如下：

- 当$p_i!=s_j$时，下次匹配必然是$p_{next[i]}$跟$s_j$比较，如果$p_i==p_{next[i]}$，则导致必然继续失配

解决方法如下：

- 若出现这种情况则需要再次递归，将$next[i]$修正为$next[next[i]]$，直至两者不相等为止，更新后的数组命名为nextval，计算nextval的算法如下：

	```c
	void GetNextVal(Str str, int nextval[]){
	    int i=1, j=0;
	    nextval[1]=0;
	    while(i<str.length)
	    {
	        if(j==0 || str.ch[i]==str.ch[j])
	        {
	            ++i;++j;
	            if(str.ch[i]!=str.ch[j])
	                nextval[i] = j;
	            else
	                nextval[i] = nextval[j];
	        }
	        else
	            j = nextval[j];
	    }
	}
	```

**手算方法：先算next数组，之后比较$p_i$和$p_{next[i]}$，若两者不等则$nextval[i]=next[i]$，若两者相等则$nextval[i]=nextval[next[i]]$**

需要注意，KMP计算的是模式串的next数组，变动的是模式串的j

## 数组、矩阵与广义表

![image-20220929162357423](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20220929162357423.png)

1. ```c
	void move(int A[], int n)
	{
	    int flag = -1, i, temp;
	    for(i=0; i<n; i++)
	    {
	        if(A[i] != 0)
	            flag++;
	        if(flag != i)
	        {
	            temp = A[flag];
	            A[flag] = A[i];
	            A[i] = temp;
	        }
	    }
	}
	```

2. ```c
	float getMax(float A[], int k, int n)
	{
	    float Max;
	    if (k==n)
	        return A[k];
	    else
	    {
	        Max = getMax(A, k+1, n);
	        return A[k]>Max?A[k]:Max;
	    }
	}
	
	getMax(A, 0, n-1);
	```

	```c
	float getSum(float A[], int k, int n)
	{
	    if (k == n)
	        return A[k];
	    else
	        return A[k]+getSum(A, k+1, n);
	}
	
	getSum(A, 0, n-1);
	```

	```c
	float getAvg(float A[], int k, int n)
	{
	    if (k == n)
	        return A[k];
	    else
	        return (A[k] + (n-k)getAvg(A, k+1, n))/(n-k+1);
	}
	
	getAvg(A, 0, n-1);
	```

3. ```c
	void divide(int A[], int n)
	{
	    int low = 0, high = n-1;
	    while(low < high)
	    {
	        while(low<high && A[low]%2==1) low++;
	        while(low<high && A[low]%2==0) high--;
	        if(low < high)
	        {
	            int temp = A[low];
	            A[low] = A[high];
	            A[high] = temp;
	            low++;
	            high--;
	        }
	    }
	}
	```

4. ```c
	void divide(int A[], int n)
	{
	    int low=0, high=n-1, pivot=A[n-1];
	    while(low<high)
	    {
	        while(low<high && A[low]<=pivot) low++;
	        A[low] = A[high];
	        while(low<high && A[high] > pivot) high--;
	        A[high] = A[low];
	    }
	    A[low] = pivot;
	}
	```

5. ```c
	int printMin(int A[][MaxSize], int m, int n)
	{
	    int i, j, k, min, minj;
	    int flag;
	    for(i=0; i<m; i++)
	    {
			min = A[i][0];
	        minj = 0;
	        for(j=1; j<n; j++)
	        {
	            if(A[i][j] < min)
	            {
	                min = A[i][j];
	                minj = j;
	            }
	            flag = 1;
	        }
	    }
	    for(k=0; k<m ; k++)
	    {
			if(min > A[k][minj])
	        {
	            flag = 0;
	            break;
	        }
	    }
	    if(flag == 1)
	        printf("%d", min);
	}
	
	int printMax(int A[][MaxSize], int m, int n)
	{
	    int i, j, k, max, maxj;
	    int flag;
	    for(i=0; i<m; i++)
	    {
			max = A[i][0];
	        maxj = 0;
	        for(j=1; j<n; j++)
	        {
	            if(A[i][j] > max)
	            {
	                max = A[i][j];
	                maxj = j;
	            }
	            flag = 1;
	        }
	    }
	    for(k=0; k<m ; k++)
	    {
			if(max < A[k][maxj])
	        {
	            flag = 0;
	            break;
	        }
	    }
	    if(flag == 1)
	        printf("%d", max);
	}
	```

6. ```c
	void create(int A[][MaxSize], int m, int n, int B[][3])
	{
	    int i, j, k=1;
	    for(i=0; i<m; i++)
	    {
	        for(j=0; j<n ;j++)
	        {
				if(A[i][j] != 0)
	            {
	                B[k][0] = A[i][j];
	                B[k][1] = i;
	                B[k][2] = j;
	                k++;
	            }
	        }
	    }
	    B[0][0] = k-1;
	    B[0][1] = m;
	    B[0][2] = n;
	}
	
	int isIn(int B[][3], int x)
	{
	    int i;
	    for(i=1; i<=B[0][0]; i++)
	    {
	        if(B[i][0] == x)
	            return 1;
	    }
	    return 0;
	}
	```

7. ```c
	void Transpose(int A[][3], int B[][3])
	{
		B[0][0] = A[0][0];
	    B[0][1] = A[0][2];
	    B[0][2] = A[0][1];
	    int i, j, col;
	    if(B[0][0] > 0)
	    {
	        i = 1;
	        for(col = 0; col < B[0][1]; ++col)
	        {
	            for(j = 1; j<=B[0][0]; ++p)
	            {
	            	if(A[j][2] == col)
	                {
	                    B[i][0] = A[j][0];
	                    B[i][1] = A[j][2];
	                    B[i][2] = A[j][1];
	                    i++;
	                }
	            }
	        }
	    }
	}
	```

8. ```c
	void add(int A[][3], int B[][3], int C[][3])
	{
	    int i=1, j=1, k=1, temp;
	    while(i<=A[0][0] && j<=B[0][0])
	    {
	        if(A[i][1] == B[i][1])
	        {
	            if(A[i][2] < B[j][2])
	            {
	                C[k][0] = A[i][0];
	                C[k][1] = A[i][1];
	                C[k][2] = A[i][2];
	                k++;
	                i++;
	            }
	            else if(A[i][2] == B[j][2])
	            {
	                temp = A[i][0] + B[j][0];
	                if(temp != 0)
	                {
	                    C[k][0] = temp;
	                	C[k][1] = A[i][1];
	                	C[k][2] = A[i][2];
	                	k++;
	                }
	                i++;
	                j++;
	            }
	            else
	            {
	                C[k][0] = B[j][0];
	                C[k][1] = B[j][1];
	                C[k][2] = B[j][2];
	                k++;
	                j++;
	            }
	        }
	        else if (A[i][1] < B[i][1])
	        {
	            C[k][0] = A[i][0];
	            C[k][1] = A[i][1];
	            C[k][2] = A[i][2];
	            k++;
	            i++;
	        }
	        else
	        {
	            C[k][0] = B[j][0];
	            C[k][1] = B[j][1];
	            C[k][2] = B[j][2];
	            k++;
	            j++;
	        }
	    }
	}
	```

9. ```c
	int getValue(int A[][3], int i, int j)
	{
	    int k=1;
	    while(k<=A[0][0] && A[k][1] == i && A[k][2] == j)
	        k++;
	    if(k<=A[0][0])
	        return A[k][0];
	    else
	        return 0;
	}
	
	int mul(int A[][3], int B[][3], int C[][3], int m, int n, int k)
	{
		int i, j, l, p=1, s;
	    for(i=0; i<m; i++)
	    {
	        for(j=0; j<k; j++)
	        {
	            s=0;
	            for(l=0; l<n; l++)
	                s += getValue(A, i, l)*getValue(A, l, j);
	            if(s!=0)
	            {
	                C[p][0] = s;
	                C[p][1] = i;
	                C[p][2] = j;
	                p++;
	            }
	        }
	    }
	    C[0][0] = p-1;
		C[0][1] = m;
		C[0][2] = k;
	}
	```

## 并查集

可以将并查集看作树的双亲结点表示法，即通过树中的一个结点，可以快速找到其双亲结点，进而找到根节点。

这种特性有两个好处

- 可以快速地将两个含有很多元素的集合并为一个

	将两个集合看作集合中的两棵树，只需找到其中一棵树的根，然后将其作为另一棵树中任何结点的孩子结点即可

- 可以方便地判断两个元素是否属于同一个集合

	通过两个元素所在的结点找到它们的根结点，如果有相同的根，则说明它们属于同一个集合，否则属于不同集合

并查集可以用一维数组来表示，如图即为并查集在数组中的表示和合并过程

![image-20220929183636089](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20220929183636089.png)

## 二叉树的非递归遍历算法

### 先序遍历

使用栈即可实现，主要思想是先将根结点压入栈，然后结点出栈并访问结点，然后依次将结点的右孩子、左孩子压入栈，直到栈为空为止

```c
void PreOrderIter(BiTree T)
{    
    if (T==NULL) return;
    Stack S;
    InitStack(&S);
    BiNode *t;
    Push(&S, T);
    while(!IsEmpty(S))
    {
        Pop(&S, t);
        visit(t);
        if(t->rchild != NULL)
            Push(&S, t->rchild);
        if(t->lchild != NULL)
            Push(&S, t->lchild);
    }
}
```

另一种使用栈的方法，当左子树遍历完后，需要回溯并访问右子树，每次Pop出结点时都是回溯到父节点的过程，即左子树已空，可以访问右子树了

```c
void PreOrderIter(BiTree T)
{
    if (T == NULL) return;
    Stack S;
    InitStack(&S);
    BiNode *t = T;
    while(t != NULL || !IsEmpty(S))
    {
        if(t->lchild != NULL)
        {
            visit(t);
            Push(&S, t->lchild);
            t = t-> lchild;
        }
        else
        {
            Pop(&S, t);
            t = t->rchild;
        }
    }
}
```

### 中序遍历

也使用栈实现，与先序遍历算法2类似，但算法访问结点时机不同

```c
void InOrderIter(BiTree T){
    if (T == NULL) return;
    Stack S;
    InitStack(&S);
    BiNode *t == T;
    while(t != NULL || !IsEmpty(S))
    {
        if(t->lchild != NULL)
        {
            Push(&S, t);
            t = t->lchild;
        }
        else
        {
            Pop(&S, t);
            visit(t);
            t = t->rchild;
        }
    }
}
```

### 后序遍历

可以使用两个栈实现后序遍历非递归算法，可以将后序算法看作是先访问根节点，再访问右孩子之后访问左孩子的逆过程，算法步骤如下：

1. Push结点到第一个栈s中
2. 从第一个栈s中Pop出一个结点，并将其Push到第二个栈Output中
3. 然后依次Push结点的左、右孩子到第一个栈s中
4. 重复2、3步直到栈s为空
5. 完成后，所有结点都在output栈里，而且按后序遍历的顺序存放，直接全部Pop出来就是二叉树后序遍历结果

```c
void PostOrderIter(BiTree T){
    Stack S, Output;
    InitStack(&S);
    InitStack(&Output);
    
    BiNode *t;
    Push(&S, T);
    while(!IsEmpty(S))
    {
        Pop(&S, t);
        Push(&Output, t);
        if(t->lchild != NULL)
            Push(&S, t->lchild);
        if(t->rchild != NULL)
            Push(&S, t->rchild);
    }
    
    while(!IsEmpty(Output))
    {
        Pop(&Output, t);
        visit(t);
    }
}
```

> 不是说先访问右节点再访问左结点吗，为什么在栈S中先压左再压右？
>
> - 因为先访问右节点再访问左结点说的是Output，所以相应的在栈S中先压左再压右

## 判断一个查找序列是否是二叉排序树的查找序列

例如，给定一个值60，在二叉排序树上寻找关键字值为60的结点时，访问的关键字值序列S={20，30，90，80，40，50，70，60}。若将S分为两个子序列，S1所包含的都是小于或等于60的数据，S1={20，30，40，50，60}；S2所包含的都是大于60的数据，S2={90，80，70}。如此可得判断是否是查找序列的原则:如果从S所生成的S1单调递增，S2单调递减，且除待查元素外，S1中的每个数据都小于给定值，S2中的每个数据都大于给定值，则S是一个查找序列，否则不是查找序列。算法描述如下:

```c
typedef struct 
{
    int elem[MaxSize];
    int len
}Sequence;

void reduce(Sequence *S, Sequence *S1, Sequence *S2)
{
    int i=0, j=0, k=0;
    while(i < S.len-1)
    {
        while(i < S.len-1 && S.elem[i] < S.elem[i+1])
            S1.elem[j++] = S.elem[i++];
        while(i < S.len-1 && S.elem[i] > S.elem[i+1])
            S2.elem[k++] = S.elem[i++];
    }
    S1.len = j;
    S2.len = k;
}

int judge(Sequence *S1, Sequence *S2, int x)
{
    int i=0, flag=1;
    while(i < S1.len-1 && flag)
    {
        if(S1[i] > S1[i+1] || S1[i] > x)
            flag = 0;
        else
            i++;
    }
    i = 0;
    while(i < S1.len-1 && flag)
    {
        if(S1[i] < S1[i+1] || S1[i] < x)
            flag = 0;
        else
            i++;
    }
    return flag;
}

int issearch(Sequence *S, Sequence *S1, Sequence *S2, int x)
{
    reduce(S, S1, S2);
    return judge(S1, S2, x);
}
```

## 堆排序

### 堆概念

若n个关键字序列$L[1 \dots n]$满足下面某一条性质，则称为**堆(Heap)**：

- 若满足：$L[i] \ge L[2i]且L[i] \ge L[2i+1], \quad (1\le i \le n/2)$，则为大顶堆（大根堆）
- 若满足：$L[i] \le L[2i]且L[i] \le L[2i+1], \quad (1\le i \le n/2)$，则为小顶堆（小根堆）

故大顶堆父节点一定大于子节点、小顶堆父节点一定小于子节点

### 堆排序思路

首先将存放在$L[1 \dots n]$中的n个元素建成初始堆，由于堆本身的特点(以大顶堆为例)，堆顶就是最大的元素。输出堆顶元素后，通常将堆底元素放在堆顶，此时需要重建堆，如此循环直到堆输出最后一个元素为止

### 建立堆

1. 大顶堆

	检查所有非终端($i \le \lfloor n/2 \rfloor$)节点，是否满足大顶堆，不满足就调整，将当前节点与一个更大的孩子互换

	从$\lfloor n/2 \rfloor$开始筛选，使该子树成为堆。之后向前依次堆各节点($\lfloor n/2 \rfloor-1 到 1$)为根的子树进行筛选，看该节点值是否大于其左右子节点的值，若不大于，则用较大值交换，交换后可能破坏下一级的堆，于是采用上述方法构造下一级的堆，直到以该节点为根的子树构成堆为止。反复如此，直到根节点

	![image-20220915174534632](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20220915174534632.png)

	```c
	// 建立大顶堆
	void BuildMaxHeap(int A[], int n){
	    // 从后往前建树
	    for(int i = n/2; i>0; i--)
	        HeadAdjust(A, i, n);
	}
	
	// 将以k为根的子树调整为大顶堆
	void HeadAdjust(int A[], int k, int len){
	    A[0] = A[k];				// 暂存
	    for(int i=2*k; i <= len; i*=2){
	        if(i<len && A[i]<A[i+1])// 取key值较大的子节点的下标
	            i+=1;
	        if(A[0] > A[i]) break;
	        else{
	            A[k] = A[i];		// 将A[i]放在双亲结点上
	            k = i;				// 修改k值，以便继续向下筛选
	        }
	    }
	    A[k] = A[0];				// 被筛选结点的值放入最终位置
	}
	```

	只有1~n-1层结点会下坠，故变焦关键字次数$\le$4n

	建堆$O(\log_ n)$

### 堆排序算法

```c
void HeapSort(int A[], int n){
    BuildMaxHeap(A, n);
    for(int i=n; i>1; i--){
        Swap(A[i], A[1]);		// 和堆底元素交换
        HeadAdjust(A, 1, i-1);
    }
}
```

适合关键字较多的情况

时间复杂度为$O(n \log n)$

空间复杂度为$O(1)$

稳定性：不稳定