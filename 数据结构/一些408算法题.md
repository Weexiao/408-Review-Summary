# 一些408算法原题

## 2009年42题

![image-20221017193559826](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221017193559826.png)

1. 使用双指针法，之间间隔为k，若一方变为NULL则输出另一方

2. 建立指针p、q都指向单链表第一个节点，将q向后移动k-1次，若次过程中q变空，则表示查找失败返回0，若成功则开始让p、q同步移动，若q为空时返回1，输出p

3. ```c
	int findKth(LinkedList L, int k)
	{
	    int i;
	    LNode *p, *q;
	    if(L->next == NULL)
	        return 0;
	    p = L->next, q = L->next;
	    for(i=0; i<k-1; i++)
	    {
	        if(q==NULL && i<k-1)
	            return 0;
	        q = q->next;
	    }
	    while(q != NULL)
	    {
	        p = p->next;
	        q = q->next;
	    }
	    printf("%d", p->data);
	    return 1;
	}
	```

## 2010年42题

![image-20221017194015498](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221017194015498.png)

**最优解**

1. 将数组$R$看作是数组$ab$，先将$a$逆置变成$a^{-1}b$，再将b逆置变为$a^{-1}b^{-1}$，再将$a^{-1}b^{-1}$整体逆置变为$ba$

2. ```c
	void Reverse(int R[], int low, int high)
	{
	    int i, temp;
	    for(i=0; i<(high-low+1)/2; i++)
	    {
	        temp = A[low+i];
	        A[low+1] = A[high-i];
	        A[high-i] = temp;
	    }
	}
	void Converse(int R[], int n, int p)
	{
	    Reverse(R, 0, p-1);
	    Reverse(R, p, n-1);
	    Reverse(R, 0, n-1);
	}
	```

3. 时间复杂度$O(\log_2n)$，空间复杂度$O(1)$

**其他解**

1. 借助辅助数组实现：将$R$中前$p$个序列保存在辅助数组中，然后将$R$中后面的序列整体向前移动p位，再将辅助数组中的值放回原数组

2. ```c
	void Converse(int R[], int n, int p)
	{
	    int i, temp[n];
	    for(i=0; i<p; i++)
	        temp[i] = A[i];
	    for(i=p; i<n; i++)
	        A[i-p] = A[i];
	    for(i=n-p; i<n; i++)
	        A[i] = temp[i-n+p];
	}
	```

3. 时间复杂度$O(n)$，空间复杂度$O(p)$

## 2011年42题

![image-20221017195047834](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221017195047834.png)

**最优解**

1. 分别求出序列$A$和$B$的中位数$m_1, m_2$，共有三种情况

	- $m_1==m_2$，则直接输出
	- $m_1 \lt m_2$，则丢弃A较小的一部分，B较大的一部分
	- $m_1 \gt m_2$，则丢弃A较大的一部分，B较小的一部分
	- 循环求解，直到一方只剩一个值

	输出两个值中较小的一方

2. ```c
	int M_Search(int A[], int B[], int n)
	{
	    int s1=0, e1=n-1, m1, s2=0, e2=n-1, m2;			// A,B的首位、末位、中位
	    while(s1!=e1 || s2!=e2`)
	    {
	        m1 = (s1+e1)/2;
	        m2 = (s2+e2)/2;
	        if(A[m1] == B[m2])
	            return A[m1];
	        else if(A[m1] < B[m2])
	        {
	            if((s1+e1)%2 == 0)						// A有奇数个
	            {
	                s1 = m1;			// 舍弃A中点以前的部分且保留中间点
	                e2 = m2;			// 舍弃B中点以后的部分且保留中间点
	            }
	            else									// A有偶数个
	            {
	                s1 = m1+1;			// 舍弃A中间点及中点以前的部分
	                e2 = m2;			// 舍弃B中点以前的部分且保留中间点
	            }
	        }
	        else
	        {
	            if((s1+e1)%2 == 0)						// A有奇数个
	            {
	                e1 = m1;			// 舍弃A中点以后的部分且保留中间点
	                s2 = m2;			// 舍弃B中点以前的部分且保留中间点
	            }
	            else									// A有偶数个
	            {
	                e1 = m1+1;			// 舍弃A中点以后的部分且保留中间点
	                e2 = m2;			// 舍弃B中间点及中点以前的部分
	            }
	        }
	    }
	    return A[m1]<B[m2] ? A[m1] : B[m2];
	}
	```

3. 时间复杂度$O(\log_2n)$，空间复杂度$O(1)$

**其他解**

1. 设两序列长为$n$，若假设将两序列合并成一个新序列，则该新序列长为$2n$，中位数一定在第n个位置，故问题转化为在两个有序序列中找第$n$个数

2. ```c
	int M_Search(int A[], int B[], int n)
	{
	    int i=0, j=0, k=n;
	    int result;
	    while(i<n && j<n)
	    {
	        if(k==0)
	            break;
	        if(A[i]<B[j])
	        {
	            result = A[i];
	            i++;
	        }
	        else
	        {
	            result = B[j];
	            j++;
	        }
	        k--;
	    }
	    return result;
	}
	```

3. 时间复杂度$O(n)$，空间复杂度$O(1)$

## 2012年42题

![image-20221018184221253](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221018184221253.png)

**最优解**

1. 经分析可得，两单词的后缀最大值即为长度较短的一个单词，故只需要保证两个链表能最终一起结束就可找到后缀的第一个值，问题转化为如何让两个长度不一定相等的链表遍历时能同时结束

	首先分别求出链表$A$、$B$的长度$m$、$n$，建立两个指针$p$、$q$，将其指向链表的第一个节点

	若$m \gt n$，则先让$p$向后移动$m-n$位；若$m \lt n$，则先让$q$向后移动$n-m$位

2. ```c
     LNode *findBack(LinkList A, LinkList B, int m, int n)
         // m,n分别为A、B长度
     {
         if(A->next==NULL || B->next==NULL)
             return NULL;
         LNode *p = A->next, *q = B->next;
         if(m > n)
             for(int i=0; i<m-n; i++)
                 p = p->next;
         else
             for(int i=0; i<n-m; i++)
                 q = q->next;
         while((p!=NULL || q!=NULL) && (p!=q))
         {
             p = p->next;
             q = q->next;
         }
         return p;
     }
     ```

3. 时间复杂度为$O(m+n)$

**其他解**

1. 暴力求解，分别求出链表$A$、$B$的长度$m$、$n$，建立两个指针$p$、$q$，将其指向链表的第一个节点；之后嵌套循环，比较$p$、$q$是否相等
2. 不写了
3. 时间复杂度为$O(mn)$

## 2013年41题

![image-20221019202055194](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221019202055194.png)

**最优解**

1. 本题实际上是在查找序列中值个数超过$\frac{n}{2}$的值

	设$count$变量用来计数，$key$变量记录可能的主元素，二者初值分别为0、$A[0]$，循环从$i=0$开始，每次比较$key$和$A[i]$的值，二者相等则$count+1$反之$count-1$。若$count==0$则将$key$设为当前$A[i]$，$count$设为1。这种方法可以找到序列中最多的元素，若$count \gt 1$则统计序列中有多少个$key$，若大于$\frac{n}{2}$则输出，其余情况输出-1

2. ```c
	int MainElement(int A[], int n)
	{
	    int i, count=0, key=A[0];
	    for(i=0; i<n; i++)
	    {
	        if(A[i] != key)
	            count--;
	        else
	            count++;
	        if(count == 0)
	        {
	            key = A[i];
	            count = 1;
	        }
	    }
	    if(count > 1)
	    {
	        int m = 0;
	        for(i=0; i<n; i++)
	            if(A[i] == key)
	                m++;
	        if(m > n/2)
	            return key;
	        else
	            return -1;
	    }
	    else
	        return -1;
	}
	```

3. 时间复杂度$O(n)$，空间复杂度$O(1)$

**其他解**

1. 采用计数排序的方法：时间复杂度$O(n)$，空间复杂度$O(n)$

	```c
	int Majority(int A[], int n)
	{
	    int i, *p, max;
	    p = (int *)malloc(sizeof(int)*n);			// 申请辅助计数数组
	    for(i=0; i<n; i++)
	        p[i] = 0;
	    max = 0;
	    for(i=0; i<n; i++)
	    {
	        p[A[i]]++;								// 计数器加1
	        if(p[A[i]] > p[max])					// 记录出现次数最多的元素
	            max = A[i];
	    }
	    if(p[max] > n/2)
	        return max;
	    else
	        return -1;
	}
	```

2. 采用其他排序的方法：时间复杂度$O(n \log_2n)$，空间复杂度其他

3. 暴力求解

## 2014年41题

![image-20221019203509525](%E4%B8%80%E4%BA%9B408%E7%AE%97%E6%B3%95%E9%A2%98.assets/image-20221019203509525.png)

**先序遍历**

1. 使用递归方法，类似于二叉树的先序遍历

	- 若当前节点为叶节点，则WPL += root->weight*deepth;
	- 若当前节点有左孩子，则递归遍历左孩子，且deepth+1
	- 若当前节点有右孩子，则递归遍历右孩子，且deepth+1

2. ```c
	typedef struct BiNode
	{
	    int weight;					// 权值
	    struct BiNode *left;		// 左孩子
	    struct BiNode *right;		// 右孩子
	}BiNode, *BiTree;
	```

3. ```c
	int WPL(BiTree root)
	{
	    int deepth=0, WPL=0;
	    calculateWPL(root, deepth, &WPL);
	    return WPL;
	}
	void calculateWPL(BiTree root, int deepth, int *WPL)
	{
	    if(root != NULL)
	    {
	        if(root->left == NULL && root->right == NULL)
	            (*WPL) += root->weight*deepth;
	        if(root->left != NULL)
	            calculateWPL(root->left, deepth+1, WPL);
	        if(root->right != NULL)
	            calculateWPL(root->right, deepth+1, WPL);
	    }
	}
	```

**层序遍历**

1. 使用队列进行层次遍历，并记录当前的层数

	- 当遍历到叶子节点时，累计WPL
	- 当遍历到非叶子节点时把该节点的子树加入队列，若当某节点为该层的最后一个节点时，层数+1
	- 队列空则遍历结束，返回WPL

2. 与上一致

3. ```c
	#define MaxSize 100						// 设置队列的最大容量
	int WPL(BiTree root)
	{
	    BiTree q[MaxSize];					// 声明队列，end1为头指针，end2为尾指针
	    int end1, end2;
	    end1=end2=0;						// 初始化队列，头指针指向队头，尾指针指向队尾的最后一个元素
	    int WPL=0, deepth=0;
	    BiNode *lastNode=root;				// 记录当前层最后一个节点
	    BiNode *newlastNode=NULL;			// 记录下一层最后一个节点
	    q[end2++] = root;					// 入队
	    while(end1 != end2)					// 队不为空
	    {
	        BiNode *t = q[end1++];			// 出队
	        if(t->left == NULL && t->right==NULL)
	            WPL += t->weight * deepth;
	        if(t->left != NULL)
	        {
	            q[end2++] = t->left;		// 左孩子入队
	            newlastNode = t->left;		// 更新下一次最后一个节点
	        }
	        if(t->right != NULL)
	        {
	            q[end2++] = t->right;		// 左孩子入队
	            newlastNode = t->right;		// 更新下一次最后一个节点
	        }
	        if(t == lastNode)
	        {
	            lastNode = newlastNode;		// 若本节点为最后一个节点，则更新lastNode
	            deepth++;
	        }
	    }
	    return WPL;
	}
	```

	